! function() {
    try {
        var m = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {},
            _ = (new m.Error).stack;
        _ && (m._sentryDebugIds = m._sentryDebugIds || {}, m._sentryDebugIds[_] = "e33cf387-4226-417c-b3e5-605d4f0dd3eb", m._sentryDebugIdIdentifier = "sentry-dbid-e33cf387-4226-417c-b3e5-605d4f0dd3eb")
    } catch (m) {}
}(), (self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [2888], {
        25387: function(m, _, C) {
            "use strict";
            C.d(_, {
                d: function() {
                    return B
                }
            });
            var R = C(93769),
                __read = function(m, _) {
                    var C = "function" == typeof Symbol && m[Symbol.iterator];
                    if (!C) return m;
                    var R, L, B = C.call(m),
                        F = [];
                    try {
                        for (;
                            (void 0 === _ || _-- > 0) && !(R = B.next()).done;) F.push(R.value)
                    } catch (m) {
                        L = {
                            error: m
                        }
                    } finally {
                        try {
                            R && !R.done && (C = B.return) && C.call(B)
                        } finally {
                            if (L) throw L.error
                        }
                    }
                    return F
                },
                L = new R.k("Amplify"),
                B = new(function() {
                    function AmplifyClass() {
                        this._components = [], this._config = {}, this._modules = {}, this.Auth = null, this.Analytics = null, this.API = null, this.Credentials = null, this.Storage = null, this.I18n = null, this.Cache = null, this.PubSub = null, this.Interactions = null, this.Pushnotification = null, this.UI = null, this.XR = null, this.Predictions = null, this.DataStore = null, this.Geo = null, this.Notifications = null, this.Logger = R.k, this.ServiceWorker = null
                    }
                    return AmplifyClass.prototype.register = function(m) {
                        L.debug("component registered in amplify", m), this._components.push(m), "function" == typeof m.getModuleName ? (this._modules[m.getModuleName()] = m, this[m.getModuleName()] = m) : L.debug("no getModuleName method for component", m), m.configure(this._config)
                    }, AmplifyClass.prototype.configure = function(m) {
                        var _ = this;
                        return m && (this._config = Object.assign(this._config, m), L.debug("amplify config", this._config), Object.entries(this._modules).forEach(function(m) {
                            var C = __read(m, 2),
                                R = (C[0], C[1]);
                            Object.keys(R).forEach(function(m) {
                                _._modules[m] && (R[m] = _._modules[m])
                            })
                        }), this._components.map(function(m) {
                            m.configure(_._config)
                        })), this._config
                    }, AmplifyClass.prototype.addPluggable = function(m) {
                        m && m.getCategory && "function" == typeof m.getCategory && this._components.map(function(_) {
                            _.addPluggable && "function" == typeof _.addPluggable && _.addPluggable(m)
                        })
                    }, AmplifyClass
                }())
        },
        93769: function(m, _, C) {
            "use strict";
            C.d(_, {
                k: function() {
                    return F
                }
            });
            var R, L, __values = function(m) {
                    var _ = "function" == typeof Symbol && Symbol.iterator,
                        C = _ && m[_],
                        R = 0;
                    if (C) return C.call(m);
                    if (m && "number" == typeof m.length) return {
                        next: function() {
                            return m && R >= m.length && (m = void 0), {
                                value: m && m[R++],
                                done: !m
                            }
                        }
                    };
                    throw TypeError(_ ? "Object is not iterable." : "Symbol.iterator is not defined.")
                },
                __read = function(m, _) {
                    var C = "function" == typeof Symbol && m[Symbol.iterator];
                    if (!C) return m;
                    var R, L, B = C.call(m),
                        F = [];
                    try {
                        for (;
                            (void 0 === _ || _-- > 0) && !(R = B.next()).done;) F.push(R.value)
                    } catch (m) {
                        L = {
                            error: m
                        }
                    } finally {
                        try {
                            R && !R.done && (C = B.return) && C.call(B)
                        } finally {
                            if (L) throw L.error
                        }
                    }
                    return F
                },
                __spreadArray = function(m, _, C) {
                    if (C || 2 == arguments.length)
                        for (var R, L = 0, B = _.length; L < B; L++) !R && L in _ || (R || (R = Array.prototype.slice.call(_, 0, L)), R[L] = _[L]);
                    return m.concat(R || Array.prototype.slice.call(_))
                },
                B = {
                    VERBOSE: 1,
                    DEBUG: 2,
                    INFO: 3,
                    WARN: 4,
                    ERROR: 5
                };
            (L = R || (R = {})).DEBUG = "DEBUG", L.ERROR = "ERROR", L.INFO = "INFO", L.WARN = "WARN", L.VERBOSE = "VERBOSE";
            var F = function() {
                function ConsoleLogger(m, _) {
                    void 0 === _ && (_ = R.WARN), this.name = m, this.level = _, this._pluggables = []
                }
                return ConsoleLogger.prototype._padding = function(m) {
                    return m < 10 ? "0" + m : "" + m
                }, ConsoleLogger.prototype._ts = function() {
                    var m = new Date;
                    return [this._padding(m.getMinutes()), this._padding(m.getSeconds())].join(":") + "." + m.getMilliseconds()
                }, ConsoleLogger.prototype.configure = function(m) {
                    return m && (this._config = m), this._config
                }, ConsoleLogger.prototype._log = function(m) {
                    for (var _, C, L = [], F = 1; F < arguments.length; F++) L[F - 1] = arguments[F];
                    var U = this.level;
                    ConsoleLogger.LOG_LEVEL && (U = ConsoleLogger.LOG_LEVEL), "undefined" != typeof window && window.LOG_LEVEL && (U = window.LOG_LEVEL);
                    var H = B[U];
                    if (B[m] >= H) {
                        var q = console.log.bind(console);
                        m === R.ERROR && console.error && (q = console.error.bind(console)), m === R.WARN && console.warn && (q = console.warn.bind(console));
                        var V = "[".concat(m, "] ").concat(this._ts(), " ").concat(this.name),
                            X = "";
                        if (1 === L.length && "string" == typeof L[0]) q(X = "".concat(V, " - ").concat(L[0]));
                        else if (1 === L.length) X = "".concat(V, " ").concat(L[0]), q(V, L[0]);
                        else if ("string" == typeof L[0]) {
                            var K = L.slice(1);
                            1 === K.length && (K = K[0]), X = "".concat(V, " - ").concat(L[0], " ").concat(K), q("".concat(V, " - ").concat(L[0]), K)
                        } else X = "".concat(V, " ").concat(L), q(V, L);
                        try {
                            for (var Y = __values(this._pluggables), Q = Y.next(); !Q.done; Q = Y.next()) {
                                var et = Q.value,
                                    er = {
                                        message: X,
                                        timestamp: Date.now()
                                    };
                                et.pushLogs([er])
                            }
                        } catch (m) {
                            _ = {
                                error: m
                            }
                        } finally {
                            try {
                                Q && !Q.done && (C = Y.return) && C.call(Y)
                            } finally {
                                if (_) throw _.error
                            }
                        }
                    }
                }, ConsoleLogger.prototype.log = function() {
                    for (var m = [], _ = 0; _ < arguments.length; _++) m[_] = arguments[_];
                    this._log.apply(this, __spreadArray([R.INFO], __read(m), !1))
                }, ConsoleLogger.prototype.info = function() {
                    for (var m = [], _ = 0; _ < arguments.length; _++) m[_] = arguments[_];
                    this._log.apply(this, __spreadArray([R.INFO], __read(m), !1))
                }, ConsoleLogger.prototype.warn = function() {
                    for (var m = [], _ = 0; _ < arguments.length; _++) m[_] = arguments[_];
                    this._log.apply(this, __spreadArray([R.WARN], __read(m), !1))
                }, ConsoleLogger.prototype.error = function() {
                    for (var m = [], _ = 0; _ < arguments.length; _++) m[_] = arguments[_];
                    this._log.apply(this, __spreadArray([R.ERROR], __read(m), !1))
                }, ConsoleLogger.prototype.debug = function() {
                    for (var m = [], _ = 0; _ < arguments.length; _++) m[_] = arguments[_];
                    this._log.apply(this, __spreadArray([R.DEBUG], __read(m), !1))
                }, ConsoleLogger.prototype.verbose = function() {
                    for (var m = [], _ = 0; _ < arguments.length; _++) m[_] = arguments[_];
                    this._log.apply(this, __spreadArray([R.VERBOSE], __read(m), !1))
                }, ConsoleLogger.prototype.addPluggable = function(m) {
                    m && "Logging" === m.getCategoryName() && (this._pluggables.push(m), m.configure(this._config))
                }, ConsoleLogger.prototype.listPluggables = function() {
                    return this._pluggables
                }, ConsoleLogger.LOG_LEVEL = null, ConsoleLogger
            }()
        },
        81361: function(m, _, C) {
            "use strict";
            C.d(_, {
                Gr: function() {
                    return GrowthBook_GrowthBook
                },
                Ny: function() {
                    return GrowthBookProvider
                },
                cC: function() {
                    return useFeatureIsOn
                }
            });
            var R, L, B = /^[a-zA-Z:_][a-zA-Z0-9:_.-]*$/,
                F = {
                    revert: function() {}
                },
                U = new Map,
                H = new Set;

            function getElementRecord(m) {
                var _ = U.get(m);
                return _ || (_ = {
                    element: m,
                    attributes: {}
                }, U.set(m, _)), _
            }

            function createElementPropertyRecord(m, _, C, R, L) {
                var B = C(m),
                    F = {
                        isDirty: !1,
                        originalValue: B,
                        virtualValue: B,
                        mutations: [],
                        el: m,
                        observer: new MutationObserver(function() {
                            var _ = C(m);
                            _ !== F.virtualValue && (F.originalValue = _, L(F))
                        }),
                        mutationRunner: L,
                        setValue: R,
                        getCurrentValue: C
                    };
                return F.observer.observe(m, "html" === _ ? {
                    childList: !0,
                    subtree: !0,
                    attributes: !0,
                    characterData: !0
                } : {
                    childList: !1,
                    subtree: !1,
                    attributes: !0,
                    attributeFilter: [_]
                }), F
            }

            function queueIfNeeded(m, _) {
                var C = _.getCurrentValue(_.el);
                _.virtualValue = m, m && "string" != typeof m ? C && m.parentNode === C.parentNode && m.insertBeforeNode === C.insertBeforeNode || (_.isDirty = !0, queueDOMUpdates()) : m !== C && (_.isDirty = !0, queueDOMUpdates())
            }

            function htmlMutationRunner(m) {
                var _, C = m.originalValue;
                m.mutations.forEach(function(m) {
                    return C = m.mutate(C)
                }), queueIfNeeded((_ = C, R || (R = document.createElement("div")), R.innerHTML = _, R.innerHTML), m)
            }

            function classMutationRunner(m) {
                var _ = new Set(m.originalValue.split(/\s+/).filter(Boolean));
                m.mutations.forEach(function(m) {
                    return m.mutate(_)
                }), queueIfNeeded(Array.from(_).filter(Boolean).join(" "), m)
            }

            function attrMutationRunner(m) {
                var _ = m.originalValue;
                m.mutations.forEach(function(m) {
                    return _ = m.mutate(_)
                }), queueIfNeeded(_, m)
            }

            function positionMutationRunner(m) {
                var _ = m.originalValue;
                m.mutations.forEach(function(m) {
                    _ = function(m) {
                        var _ = m.parentSelector,
                            C = m.insertBeforeSelector,
                            R = document.querySelector(_);
                        if (!R) return null;
                        var L = C ? document.querySelector(C) : null;
                        return C && !L ? null : {
                            parentNode: R,
                            insertBeforeNode: L
                        }
                    }(m.mutate()) || _
                }), queueIfNeeded(_, m)
            }
            var getHTMLValue = function(m) {
                    return m.innerHTML
                },
                setHTMLValue = function(m, _) {
                    return m.innerHTML = _
                };

            function getElementHTMLRecord(m) {
                var _ = getElementRecord(m);
                return _.html || (_.html = createElementPropertyRecord(m, "html", getHTMLValue, setHTMLValue, htmlMutationRunner)), _.html
            }
            var getElementPosition = function(m) {
                    return {
                        parentNode: m.parentElement,
                        insertBeforeNode: m.nextElementSibling
                    }
                },
                setElementPosition = function(m, _) {
                    _.parentNode.insertBefore(m, _.insertBeforeNode)
                };

            function getElementPositionRecord(m) {
                var _ = getElementRecord(m);
                return _.position || (_.position = createElementPropertyRecord(m, "position", getElementPosition, setElementPosition, positionMutationRunner)), _.position
            }
            var setClassValue = function(m, _) {
                    return _ ? m.className = _ : m.removeAttribute("class")
                },
                getClassValue = function(m) {
                    return m.className
                };

            function getElementClassRecord(m) {
                var _ = getElementRecord(m);
                return _.classes || (_.classes = createElementPropertyRecord(m, "class", getClassValue, setClassValue, classMutationRunner)), _.classes
            }

            function getElementAttributeRecord(m, _) {
                var C = getElementRecord(m);
                return C.attributes[_] || (C.attributes[_] = createElementPropertyRecord(m, _, function(m) {
                    var C;
                    return null != (C = m.getAttribute(_)) ? C : null
                }, function(m, C) {
                    return null !== C ? m.setAttribute(_, C) : m.removeAttribute(_)
                }, attrMutationRunner)), C.attributes[_]
            }

            function setPropertyValue(m, _, C) {
                if (C.isDirty) {
                    C.isDirty = !1;
                    var R, L, B, F, H, q, V, X, K, Y, Q = C.virtualValue;
                    !C.mutations.length && (Y = U.get(m)) && ("html" === _ ? (null == (R = Y.html) || null == (L = R.observer) || L.disconnect(), delete Y.html) : "class" === _ ? (null == (B = Y.classes) || null == (F = B.observer) || F.disconnect(), delete Y.classes) : "position" === _ ? (null == (H = Y.position) || null == (q = H.observer) || q.disconnect(), delete Y.position) : (null == (V = Y.attributes) || null == (X = V[_]) || null == (K = X.observer) || K.disconnect(), delete Y.attributes[_])), C.setValue(m, Q)
                }
            }
            var q = !1;

            function setValue(m, _) {
                m.html && setPropertyValue(_, "html", m.html), m.classes && setPropertyValue(_, "class", m.classes), m.position && setPropertyValue(_, "position", m.position), Object.keys(m.attributes).forEach(function(C) {
                    setPropertyValue(_, C, m.attributes[C])
                })
            }

            function setValues() {
                q = !1, U.forEach(setValue)
            }

            function queueDOMUpdates() {
                q || (q = !0, requestAnimationFrame(setValues))
            }

            function stopMutating(m, _) {
                var C = null;
                if ("html" === m.kind ? C = getElementHTMLRecord(_) : "class" === m.kind ? C = getElementClassRecord(_) : "attribute" === m.kind ? C = getElementAttributeRecord(_, m.attribute) : "position" === m.kind && (C = getElementPositionRecord(_)), C) {
                    var R = C.mutations.indexOf(m); - 1 !== R && C.mutations.splice(R, 1), C.mutationRunner(C)
                }
            }

            function refreshElementsSet(m) {
                var _ = new Set(m.elements),
                    C = new Set;
                document.querySelectorAll(m.selector).forEach(function(R) {
                    if (C.add(R), !_.has(R)) {
                        var L;
                        m.elements.add(R), L = null, "html" === m.kind ? L = getElementHTMLRecord(R) : "class" === m.kind ? L = getElementClassRecord(R) : "attribute" === m.kind ? L = getElementAttributeRecord(R, m.attribute) : "position" === m.kind && (L = getElementPositionRecord(R)), L && (L.mutations.push(m), L.mutationRunner(L))
                    }
                }), _.forEach(function(_) {
                    C.has(_) || (m.elements.delete(_), stopMutating(m, _))
                })
            }

            function refreshAllElementSets() {
                H.forEach(refreshElementsSet)
            }

            function newMutation(m) {
                return "undefined" == typeof document ? F : (H.add(m), refreshElementsSet(m), {
                    revert: function() {
                        m.elements.forEach(function(_) {
                            return stopMutating(m, _)
                        }), m.elements.clear(), H.delete(m)
                    }
                })
            }

            function html(m, _) {
                return newMutation({
                    kind: "html",
                    elements: new Set,
                    mutate: _,
                    selector: m
                })
            }

            function position(m, _) {
                return newMutation({
                    kind: "position",
                    elements: new Set,
                    mutate: _,
                    selector: m
                })
            }

            function classes(m, _) {
                return newMutation({
                    kind: "class",
                    elements: new Set,
                    mutate: _,
                    selector: m
                })
            }

            function attribute(m, _, C) {
                return B.test(_) ? "class" === _ || "className" === _ ? classes(m, function(m) {
                    var _ = C(Array.from(m).join(" "));
                    m.clear(), _ && _.split(/\s+/g).filter(Boolean).forEach(function(_) {
                        return m.add(_)
                    })
                }) : newMutation({
                    kind: "attribute",
                    attribute: _,
                    elements: new Set,
                    mutate: C,
                    selector: m
                }) : F
            }
            "undefined" != typeof document && (L || (L = new MutationObserver(function() {
                refreshAllElementSets()
            })), refreshAllElementSets(), L.observe(document.documentElement, {
                childList: !0,
                subtree: !0,
                attributes: !1,
                characterData: !1
            }));
            var V = {
                html: html,
                classes: classes,
                attribute: attribute,
                position: position,
                declarative: function(m) {
                    var _ = m.selector,
                        C = m.action,
                        R = m.value,
                        L = m.attribute,
                        B = m.parentSelector,
                        U = m.insertBeforeSelector;
                    if ("html" === L) {
                        if ("append" === C) return html(_, function(m) {
                            return m + (null != R ? R : "")
                        });
                        if ("set" === C) return html(_, function() {
                            return null != R ? R : ""
                        })
                    } else if ("class" === L) {
                        if ("append" === C) return classes(_, function(m) {
                            R && m.add(R)
                        });
                        if ("remove" === C) return classes(_, function(m) {
                            R && m.delete(R)
                        });
                        if ("set" === C) return classes(_, function(m) {
                            m.clear(), R && m.add(R)
                        })
                    } else if ("position" === L) {
                        if ("set" === C && B) return position(_, function() {
                            return {
                                insertBeforeSelector: U,
                                parentSelector: B
                            }
                        })
                    } else {
                        if ("append" === C) return attribute(_, L, function(m) {
                            return null !== m ? m + (null != R ? R : "") : null != R ? R : ""
                        });
                        if ("set" === C) return attribute(_, L, function() {
                            return null != R ? R : ""
                        });
                        if ("remove" === C) return attribute(_, L, function() {
                            return null
                        })
                    }
                    return F
                }
            };

            function hashFnv32a(m) {
                let _ = 2166136261,
                    C = m.length;
                for (let R = 0; R < C; R++) _ ^= m.charCodeAt(R), _ += (_ << 1) + (_ << 4) + (_ << 7) + (_ << 8) + (_ << 24);
                return _ >>> 0
            }

            function hash(m, _, C) {
                return 2 === C ? hashFnv32a(hashFnv32a(m + _) + "") % 1e4 / 1e4 : 1 === C ? hashFnv32a(_ + m) % 1e3 / 1e3 : null
            }

            function inRange(m, _) {
                return m >= _[0] && m < _[1]
            }

            function getUrlRegExp(m) {
                try {
                    let _ = m.replace(/([^\\])\//g, "$1\\/");
                    return new RegExp(_)
                } catch (m) {
                    console.error(m);
                    return
                }
            }
            let base64ToBuf = m => Uint8Array.from(atob(m), m => m.charCodeAt(0));
            async function decrypt(m, _, C) {
                if (_ = _ || "", !(C = C || globalThis.crypto && globalThis.crypto.subtle)) throw Error("No SubtleCrypto implementation found");
                try {
                    let R = await C.importKey("raw", base64ToBuf(_), {
                            name: "AES-CBC",
                            length: 128
                        }, !0, ["encrypt", "decrypt"]),
                        [L, B] = m.split("."),
                        F = await C.decrypt({
                            name: "AES-CBC",
                            iv: base64ToBuf(L)
                        }, R, base64ToBuf(B));
                    return new TextDecoder().decode(F)
                } catch (m) {
                    throw Error("Failed to decrypt")
                }
            }

            function paddedVersionString(m) {
                let _ = m.replace(/(^v|\+.*$)/g, "").split(/[-.]/);
                return 3 === _.length && _.push("~"), _.map(m => m.match(/^[0-9]+$/) ? m.padStart(5, " ") : m).join("-")
            }
            let X = {};

            function evalCondition(m, _) {
                if ("$or" in _) return evalOr(m, _.$or);
                if ("$nor" in _) return !evalOr(m, _.$nor);
                if ("$and" in _) return function(m, _) {
                    for (let C = 0; C < _.length; C++)
                        if (!evalCondition(m, _[C])) return !1;
                    return !0
                }(m, _.$and);
                if ("$not" in _) return !evalCondition(m, _.$not);
                for (let [C, R] of Object.entries(_))
                    if (! function evalConditionValue(m, _) {
                            if ("string" == typeof m) return _ + "" === m;
                            if ("number" == typeof m) return 1 * _ === m;
                            if ("boolean" == typeof m) return !!_ === m;
                            if (null === m) return null === _;
                            if (Array.isArray(m) || !isOperatorObject(m)) return JSON.stringify(_) === JSON.stringify(m);
                            for (let C in m)
                                if (! function(m, _, C) {
                                        switch (m) {
                                            case "$veq":
                                                return paddedVersionString(_) === paddedVersionString(C);
                                            case "$vne":
                                                return paddedVersionString(_) !== paddedVersionString(C);
                                            case "$vgt":
                                                return paddedVersionString(_) > paddedVersionString(C);
                                            case "$vgte":
                                                return paddedVersionString(_) >= paddedVersionString(C);
                                            case "$vlt":
                                                return paddedVersionString(_) < paddedVersionString(C);
                                            case "$vlte":
                                                return paddedVersionString(_) <= paddedVersionString(C);
                                            case "$eq":
                                                return _ === C;
                                            case "$ne":
                                                return _ !== C;
                                            case "$lt":
                                                return _ < C;
                                            case "$lte":
                                                return _ <= C;
                                            case "$gt":
                                                return _ > C;
                                            case "$gte":
                                                return _ >= C;
                                            case "$exists":
                                                return C ? null !== _ : null === _;
                                            case "$in":
                                                if (!Array.isArray(C)) return !1;
                                                return isIn(_, C);
                                            case "$nin":
                                                if (!Array.isArray(C)) return !1;
                                                return !isIn(_, C);
                                            case "$not":
                                                return !evalConditionValue(C, _);
                                            case "$size":
                                                if (!Array.isArray(_)) return !1;
                                                return evalConditionValue(C, _.length);
                                            case "$elemMatch":
                                                return function(m, _) {
                                                    if (!Array.isArray(m)) return !1;
                                                    let C = isOperatorObject(_) ? m => evalConditionValue(_, m) : m => evalCondition(m, _);
                                                    for (let _ = 0; _ < m.length; _++)
                                                        if (m[_] && C(m[_])) return !0;
                                                    return !1
                                                }(_, C);
                                            case "$all":
                                                if (!Array.isArray(_)) return !1;
                                                for (let m = 0; m < C.length; m++) {
                                                    let R = !1;
                                                    for (let L = 0; L < _.length; L++)
                                                        if (evalConditionValue(C[m], _[L])) {
                                                            R = !0;
                                                            break
                                                        }
                                                    if (!R) return !1
                                                }
                                                return !0;
                                            case "$regex":
                                                try {
                                                    return (X[C] || (X[C] = new RegExp(C.replace(/([^\\])\//g, "$1\\/"))), X[C]).test(_)
                                                } catch (m) {
                                                    return !1
                                                }
                                            case "$type":
                                                return function(m) {
                                                    if (null === m) return "null";
                                                    if (Array.isArray(m)) return "array";
                                                    let _ = typeof m;
                                                    return ["string", "number", "boolean", "object", "undefined"].includes(_) ? _ : "unknown"
                                                }(_) === C;
                                            default:
                                                return console.error("Unknown operator: " + m), !1
                                        }
                                    }(C, _, m[C])) return !1;
                            return !0
                        }(R, function(m, _) {
                            let C = _.split("."),
                                R = m;
                            for (let m = 0; m < C.length; m++) {
                                if (!R || "object" != typeof R || !(C[m] in R)) return null;
                                R = R[C[m]]
                            }
                            return R
                        }(m, C))) return !1;
                return !0
            }

            function isOperatorObject(m) {
                let _ = Object.keys(m);
                return _.length > 0 && _.filter(m => "$" === m[0]).length === _.length
            }

            function isIn(m, _) {
                return Array.isArray(m) ? m.some(m => _.includes(m)) : _.includes(m)
            }

            function evalOr(m, _) {
                if (!_.length) return !0;
                for (let C = 0; C < _.length; C++)
                    if (evalCondition(m, _[C])) return !0;
                return !1
            }
            let K = {
                    staleTTL: 6e4,
                    cacheKey: "gbFeaturesCache",
                    backgroundSync: !0
                },
                Y = {
                    fetch: globalThis.fetch ? globalThis.fetch.bind(globalThis) : void 0,
                    SubtleCrypto: globalThis.crypto ? globalThis.crypto.subtle : void 0,
                    EventSource: globalThis.EventSource
                };
            try {
                globalThis.localStorage && (Y.localStorage = globalThis.localStorage)
            } catch (m) {}
            let Q = new Map,
                et = !1,
                er = new Map,
                en = new Map,
                ei = new Map,
                eo = new Set;
            async function refreshFeatures(m, _, C, R, L) {
                let B = await fetchFeaturesWithCache(m, R, _, C);
                L && B && await refreshInstance(m, B)
            }
            async function updatePersistentCache() {
                try {
                    if (!Y.localStorage) return;
                    await Y.localStorage.setItem(K.cacheKey, JSON.stringify(Array.from(er.entries())))
                } catch (m) {}
            }
            async function fetchFeaturesWithCache(m, _, C, R) {
                let [L] = getKey(m), B = new Date;
                await initializeCache();
                let F = er.get(L);
                if (F && !R && (_ || F.staleAt > B)) return F.staleAt < B ? fetchFeatures(m) : startAutoRefresh(m), F.data; {
                    var U;
                    let _ = await (U = fetchFeatures(m), new Promise(m => {
                        let _, R = !1,
                            finish = C => {
                                R || (R = !0, _ && clearTimeout(_), m(C || null))
                            };
                        C && (_ = setTimeout(() => finish(), C)), U.then(m => finish(m)).catch(() => finish())
                    }));
                    return _
                }
            }

            function getKey(m) {
                let [_, C] = m.getApiInfo();
                return ["".concat(_, "||").concat(C), _, C]
            }
            async function initializeCache() {
                if (!et) {
                    et = !0;
                    try {
                        if (Y.localStorage) {
                            let m = await Y.localStorage.getItem(K.cacheKey);
                            if (m) {
                                let _ = JSON.parse(m);
                                _ && Array.isArray(_) && _.forEach(m => {
                                    let [_, C] = m;
                                    er.set(_, { ...C,
                                        staleAt: new Date(C.staleAt)
                                    })
                                })
                            }
                        }
                    } catch (m) {}
                }
            }

            function onNewFeatureData(m, _) {
                let C = _.dateUpdated || "",
                    R = new Date(Date.now() + K.staleTTL),
                    L = er.get(m);
                if (L && C && L.version === C) {
                    L.staleAt = R, updatePersistentCache();
                    return
                }
                er.set(m, {
                    data: _,
                    version: C,
                    staleAt: R
                }), updatePersistentCache();
                let B = Q.get(m);
                B && B.forEach(m => refreshInstance(m, _))
            }
            async function refreshInstance(m, _) {
                await (_.encryptedExperiments ? m.setEncryptedExperiments(_.encryptedExperiments, void 0, Y.SubtleCrypto) : m.setExperiments(_.experiments || m.getExperiments())), await (_.encryptedFeatures ? m.setEncryptedFeatures(_.encryptedFeatures, void 0, Y.SubtleCrypto) : m.setFeatures(_.features || m.getFeatures()))
            }
            async function fetchFeatures(m) {
                let [_, C, R] = getKey(m), L = en.get(_);
                return L || (L = Y.fetch(C + "/api/features/" + R).then(m => ("enabled" === m.headers.get("x-sse-support") && eo.add(_), m.json())).then(C => (onNewFeatureData(_, C), startAutoRefresh(m), en.delete(_), C)).catch(m => (en.delete(_), Promise.resolve({}))), en.set(_, L)), await L
            }

            function startAutoRefresh(m) {
                let [_, C, R] = getKey(m);
                if (K.backgroundSync && eo.has(_) && Y.EventSource) {
                    if (ei.has(_)) return;
                    let m = {
                        src: null,
                        cb: L => {
                            try {
                                let C = JSON.parse(L.data);
                                onNewFeatureData(_, C), m.errors = 0
                            } catch (_) {
                                onSSEError(m, C, R)
                            }
                        },
                        errors: 0
                    };
                    ei.set(_, m), enableChannel(m, C, R)
                }
            }

            function onSSEError(m, _, C) {
                if (m.errors++, m.errors > 3 || m.src && 2 === m.src.readyState) {
                    let R = Math.pow(3, m.errors - 3) * (1e3 + 1e3 * Math.random());
                    m.src && (m.src.onopen = null, m.src.onerror = null, m.src.close(), m.src = null), setTimeout(() => {
                        enableChannel(m, _, C)
                    }, Math.min(R, 3e5))
                }
            }

            function enableChannel(m, _, C) {
                m.src = new Y.EventSource("".concat(_, "/sub/").concat(C)), m.src.addEventListener("features", m.cb), m.src.onerror = () => {
                    onSSEError(m, _, C)
                }, m.src.onopen = () => {
                    m.errors = 0
                }
            }
            let ea = "undefined" != typeof window && "undefined" != typeof document;
            let GrowthBook_GrowthBook = class GrowthBook_GrowthBook {
                constructor(m) {
                    m = m || {}, this._ctx = this.context = m, this._renderer = null, this._trackedExperiments = new Set, this._trackedFeatures = {}, this.debug = !1, this._subscriptions = new Set, this._rtQueue = [], this._rtTimer = 0, this.ready = !1, this._assigned = new Map, this._forcedFeatureValues = new Map, this._attributeOverrides = {}, this._activeAutoExperiments = new Map, m.features && (this.ready = !0), ea && m.enableDevMode && (window._growthbook = this, document.dispatchEvent(new Event("gbloaded"))), m.experiments && (this.ready = !0, this._updateAllAutoExperiments()), m.clientKey && this._refresh({}, !0, !1)
                }
                async loadFeatures(m) {
                    await this._refresh(m, !0, !0), m && m.autoRefresh && function(m) {
                        let [_] = getKey(m), C = Q.get(_) || new Set;
                        C.add(m), Q.set(_, C)
                    }(this)
                }
                async refreshFeatures(m) {
                    await this._refresh(m, !1, !0)
                }
                getApiInfo() {
                    return [(this._ctx.apiHost || "https://cdn.growthbook.io").replace(/\/*$/, ""), this._ctx.clientKey || ""]
                }
                async _refresh(m, _, C) {
                    if (m = m || {}, !this._ctx.clientKey) throw Error("Missing clientKey");
                    await refreshFeatures(this, m.timeout, m.skipCache || this._ctx.enableDevMode, _, C)
                }
                _render() {
                    this._renderer && this._renderer()
                }
                setFeatures(m) {
                    this._ctx.features = m, this.ready = !0, this._render()
                }
                async setEncryptedFeatures(m, _, C) {
                    let R = await decrypt(m, _ || this._ctx.decryptionKey, C);
                    this.setFeatures(JSON.parse(R))
                }
                setExperiments(m) {
                    this._ctx.experiments = m, this.ready = !0, this._updateAllAutoExperiments()
                }
                async setEncryptedExperiments(m, _, C) {
                    let R = await decrypt(m, _ || this._ctx.decryptionKey, C);
                    this.setExperiments(JSON.parse(R))
                }
                setAttributes(m) {
                    this._ctx.attributes = m, this._render(), this._updateAllAutoExperiments()
                }
                setAttributeOverrides(m) {
                    this._attributeOverrides = m, this._render(), this._updateAllAutoExperiments()
                }
                setForcedVariations(m) {
                    this._ctx.forcedVariations = m || {}, this._render(), this._updateAllAutoExperiments()
                }
                setForcedFeatures(m) {
                    this._forcedFeatureValues = m, this._render()
                }
                setURL(m) {
                    this._ctx.url = m, this._updateAllAutoExperiments(!0)
                }
                getAttributes() {
                    return { ...this._ctx.attributes,
                        ...this._attributeOverrides
                    }
                }
                getFeatures() {
                    return this._ctx.features || {}
                }
                getExperiments() {
                    return this._ctx.experiments || []
                }
                subscribe(m) {
                    return this._subscriptions.add(m), () => {
                        this._subscriptions.delete(m)
                    }
                }
                getAllResults() {
                    return new Map(this._assigned)
                }
                destroy() {
                    var m;
                    this._subscriptions.clear(), this._assigned.clear(), this._trackedExperiments.clear(), this._trackedFeatures = {}, this._rtQueue = [], this._rtTimer && clearTimeout(this._rtTimer), m = this, Q.forEach(_ => _.delete(m)), ea && window._growthbook === this && delete window._growthbook, this._activeAutoExperiments.forEach(m => {
                        m.undo()
                    }), this._activeAutoExperiments.clear()
                }
                setRenderer(m) {
                    this._renderer = m
                }
                forceVariation(m, _) {
                    this._ctx.forcedVariations = this._ctx.forcedVariations || {}, this._ctx.forcedVariations[m] = _, this._render()
                }
                run(m) {
                    let _ = this._run(m, null);
                    return this._fireSubscriptions(m, _), _
                }
                triggerExperiment(m) {
                    if (!this._ctx.experiments) return null;
                    let _ = this._ctx.experiments.find(_ => _.key === m);
                    return _ && _.manual ? this._runAutoExperiment(_, !0) : null
                }
                _runAutoExperiment(m, _, C) {
                    let R = m.key,
                        L = this._activeAutoExperiments.get(R);
                    if (m.manual && !_ && !L) return null;
                    let B = this.run(m),
                        F = JSON.stringify(B.value);
                    if (!C && B.inExperiment && L && L.valueHash === F) return B;
                    if (L && this._undoActiveAutoExperiment(R), B.inExperiment) {
                        let _ = this._applyDOMChanges(B.value);
                        _ && this._activeAutoExperiments.set(m.key, {
                            undo: _,
                            valueHash: F
                        })
                    }
                    return B
                }
                _undoActiveAutoExperiment(m) {
                    let _ = this._activeAutoExperiments.get(m);
                    _ && (_.undo(), this._activeAutoExperiments.delete(m))
                }
                _updateAllAutoExperiments(m) {
                    let _ = this._ctx.experiments || [],
                        C = new Set(_.map(m => m.key));
                    this._activeAutoExperiments.forEach((m, _) => {
                        C.has(_) || (m.undo(), this._activeAutoExperiments.delete(_))
                    }), _.forEach(_ => {
                        this._runAutoExperiment(_, !1, m)
                    })
                }
                _fireSubscriptions(m, _) {
                    let C = m.key,
                        R = this._assigned.get(C);
                    R && R.result.inExperiment === _.inExperiment && R.result.variationId === _.variationId || (this._assigned.set(C, {
                        experiment: m,
                        result: _
                    }), this._subscriptions.forEach(C => {
                        try {
                            C(m, _)
                        } catch (m) {
                            console.error(m)
                        }
                    }))
                }
                _trackFeatureUsage(m, _) {
                    if ("override" === _.source) return;
                    let C = JSON.stringify(_.value);
                    if (this._trackedFeatures[m] !== C) {
                        if (this._trackedFeatures[m] = C, this._ctx.onFeatureUsage) try {
                            this._ctx.onFeatureUsage(m, _)
                        } catch (m) {}
                        ea && window.fetch && (this._rtQueue.push({
                            key: m,
                            on: _.on
                        }), this._rtTimer || (this._rtTimer = window.setTimeout(() => {
                            this._rtTimer = 0;
                            let m = [...this._rtQueue];
                            this._rtQueue = [], this._ctx.realtimeKey && window.fetch("https://rt.growthbook.io/?key=".concat(this._ctx.realtimeKey, "&events=").concat(encodeURIComponent(JSON.stringify(m))), {
                                cache: "no-cache",
                                mode: "no-cors"
                            }).catch(() => {})
                        }, this._ctx.realtimeInterval || 2e3)))
                    }
                }
                _getFeatureResult(m, _, C, R, L, B) {
                    let F = {
                        value: _,
                        on: !!_,
                        off: !_,
                        source: C,
                        ruleId: R || ""
                    };
                    return L && (F.experiment = L), B && (F.experimentResult = B), this._trackFeatureUsage(m, F), F
                }
                isOn(m) {
                    return this.evalFeature(m).on
                }
                isOff(m) {
                    return this.evalFeature(m).off
                }
                getFeatureValue(m, _) {
                    let C = this.evalFeature(m).value;
                    return null === C ? _ : C
                }
                feature(m) {
                    return this.evalFeature(m)
                }
                evalFeature(m) {
                    if (this._forcedFeatureValues.has(m)) return this._getFeatureResult(m, this._forcedFeatureValues.get(m), "override");
                    if (!this._ctx.features || !this._ctx.features[m]) return this._getFeatureResult(m, null, "unknownFeature");
                    let _ = this._ctx.features[m];
                    if (_.rules)
                        for (let C of _.rules) {
                            if (C.condition && !this._conditionPasses(C.condition) || C.filters && this._isFilteredOut(C.filters)) continue;
                            if ("force" in C) {
                                if (!this._isIncludedInRollout(C.seed || m, C.hashAttribute, C.range, C.coverage, C.hashVersion)) continue;
                                return C.tracks && C.tracks.forEach(m => {
                                    this._track(m.experiment, m.result)
                                }), this._getFeatureResult(m, C.force, "force", C.id)
                            }
                            if (!C.variations) continue;
                            let _ = {
                                variations: C.variations,
                                key: C.key || m
                            };
                            "coverage" in C && (_.coverage = C.coverage), C.weights && (_.weights = C.weights), C.hashAttribute && (_.hashAttribute = C.hashAttribute), C.namespace && (_.namespace = C.namespace), C.meta && (_.meta = C.meta), C.ranges && (_.ranges = C.ranges), C.name && (_.name = C.name), C.phase && (_.phase = C.phase), C.seed && (_.seed = C.seed), C.hashVersion && (_.hashVersion = C.hashVersion), C.filters && (_.filters = C.filters);
                            let R = this._run(_, m);
                            if (this._fireSubscriptions(_, R), R.inExperiment && !R.passthrough) return this._getFeatureResult(m, R.value, "experiment", C.id, _, R)
                        }
                    return this._getFeatureResult(m, void 0 === _.defaultValue ? null : _.defaultValue, "defaultValue")
                }
                _isIncludedInRollout(m, _, C, R, L) {
                    if (!C && void 0 === R) return !0;
                    let {
                        hashValue: B
                    } = this._getHashAttribute(_);
                    if (!B) return !1;
                    let F = hash(m, B, L || 1);
                    return null !== F && (C ? inRange(F, C) : void 0 === R || F <= R)
                }
                _conditionPasses(m) {
                    return evalCondition(this.getAttributes(), m)
                }
                _isFilteredOut(m) {
                    return m.some(m => {
                        let {
                            hashValue: _
                        } = this._getHashAttribute(m.attribute);
                        if (!_) return !0;
                        let C = hash(m.seed, _, m.hashVersion || 2);
                        return null === C || !m.ranges.some(m => inRange(C, m))
                    })
                }
                _run(m, _) {
                    let C = m.key,
                        R = m.variations.length;
                    if (R < 2 || !1 === this._ctx.enabled) return this._getResult(m, -1, !1, _);
                    m = this._mergeOverrides(m);
                    let L = function(m, _, C) {
                        if (!_) return null;
                        let R = _.split("?")[1];
                        if (!R) return null;
                        let L = R.replace(/#.*/, "").split("&").map(m => m.split("=", 2)).filter(_ => {
                            let [C] = _;
                            return C === m
                        }).map(m => {
                            let [, _] = m;
                            return parseInt(_)
                        });
                        return L.length > 0 && L[0] >= 0 && L[0] < C ? L[0] : null
                    }(C, this._getContextUrl(), R);
                    if (null !== L) return this._getResult(m, L, !1, _);
                    if (this._ctx.forcedVariations && C in this._ctx.forcedVariations) {
                        let R = this._ctx.forcedVariations[C];
                        return this._getResult(m, R, !1, _)
                    }
                    if ("draft" === m.status || !1 === m.active) return this._getResult(m, -1, !1, _);
                    let {
                        hashValue: B
                    } = this._getHashAttribute(m.hashAttribute);
                    if (!B) return this._getResult(m, -1, !1, _);
                    if (m.filters) {
                        if (this._isFilteredOut(m.filters)) return this._getResult(m, -1, !1, _)
                    } else if (m.namespace && ! function(m, _) {
                            let C = hash("__" + _[0], m, 1);
                            return null !== C && C >= _[1] && C < _[2]
                        }(B, m.namespace)) return this._getResult(m, -1, !1, _);
                    if (m.include && ! function(m) {
                            try {
                                return m()
                            } catch (m) {
                                return console.error(m), !1
                            }
                        }(m.include) || m.condition && !this._conditionPasses(m.condition) || m.groups && !this._hasGroupOverlap(m.groups) || m.url && !this._urlIsValid(m.url) || m.urlPatterns && ! function(m, _) {
                            if (!_.length) return !1;
                            let C = !1,
                                R = !1;
                            for (let L = 0; L < _.length; L++) {
                                let B = function(m, _, C) {
                                    try {
                                        let R = new URL(m, "https://_");
                                        if ("regex" === _) {
                                            let m = getUrlRegExp(C);
                                            if (!m) return !1;
                                            return m.test(R.href) || m.test(R.href.substring(R.origin.length))
                                        }
                                        if ("simple" === _) return function(m, _) {
                                            try {
                                                let C = new URL(_.replace(/^([^:/?]*)\./i, "https://$1.").replace(/\*/g, "_____"), "https://_____"),
                                                    R = [
                                                        [m.host, C.host, !1],
                                                        [m.pathname, C.pathname, !0]
                                                    ];
                                                return C.hash && R.push([m.hash, C.hash, !1]), C.searchParams.forEach((_, C) => {
                                                    R.push([m.searchParams.get(C) || "", _, !1])
                                                }), !R.some(m => ! function(m, _, C) {
                                                    try {
                                                        let R = _.replace(/[*.+?^${}()|[\]\\]/g, "\\$&").replace(/_____/g, ".*");
                                                        C && (R = "\\/?" + R.replace(/(^\/|\/$)/g, "") + "\\/?");
                                                        let L = RegExp("^" + R + "$", "i");
                                                        return L.test(m)
                                                    } catch (m) {
                                                        return !1
                                                    }
                                                }(m[0], m[1], m[2]))
                                            } catch (m) {
                                                return !1
                                            }
                                        }(R, C);
                                        return !1
                                    } catch (m) {
                                        return !1
                                    }
                                }(m, _[L].type, _[L].pattern);
                                if (!1 === _[L].include) {
                                    if (B) return !1
                                } else C = !0, B && (R = !0)
                            }
                            return R || !C
                        }(this._getContextUrl(), m.urlPatterns)) return this._getResult(m, -1, !1, _);
                    let F = hash(m.seed || C, B, m.hashVersion || 1);
                    if (null === F) return this._getResult(m, -1, !1, _);
                    let U = m.ranges || function(m, _, C) {
                            (_ = void 0 === _ ? 1 : _) < 0 ? _ = 0 : _ > 1 && (_ = 1);
                            let R = m <= 0 ? [] : Array(m).fill(1 / m);
                            (C = C || R).length !== m && (C = R);
                            let L = C.reduce((m, _) => _ + m, 0);
                            (L < .99 || L > 1.01) && (C = R);
                            let B = 0;
                            return C.map(m => {
                                let C = B;
                                return B += m, [C, C + _ * m]
                            })
                        }(R, void 0 === m.coverage ? 1 : m.coverage, m.weights),
                        H = function(m, _) {
                            for (let C = 0; C < _.length; C++)
                                if (inRange(m, _[C])) return C;
                            return -1
                        }(F, U);
                    if (H < 0) return this._getResult(m, -1, !1, _);
                    if ("force" in m) return this._getResult(m, void 0 === m.force ? -1 : m.force, !1, _);
                    if (this._ctx.qaMode || "stopped" === m.status) return this._getResult(m, -1, !1, _);
                    let q = this._getResult(m, H, !0, _, F);
                    return this._track(m, q), q
                }
                log(m, _) {
                    this.debug && (this._ctx.log ? this._ctx.log(m, _) : console.log(m, _))
                }
                _track(m, _) {
                    if (!this._ctx.trackingCallback) return;
                    let C = m.key,
                        R = _.hashAttribute + _.hashValue + C + _.variationId;
                    if (!this._trackedExperiments.has(R)) {
                        this._trackedExperiments.add(R);
                        try {
                            this._ctx.trackingCallback(m, _)
                        } catch (m) {
                            console.error(m)
                        }
                    }
                }
                _mergeOverrides(m) {
                    let _ = m.key,
                        C = this._ctx.overrides;
                    return C && C[_] && "string" == typeof(m = Object.assign({}, m, C[_])).url && (m.url = getUrlRegExp(m.url)), m
                }
                _getHashAttribute(m) {
                    let _ = m || "id",
                        C = "";
                    return this._attributeOverrides[_] ? C = this._attributeOverrides[_] : this._ctx.attributes ? C = this._ctx.attributes[_] || "" : this._ctx.user && (C = this._ctx.user[_] || ""), {
                        hashAttribute: _,
                        hashValue: C
                    }
                }
                _getResult(m, _, C, R, L) {
                    let B = !0;
                    (_ < 0 || _ >= m.variations.length) && (_ = 0, B = !1);
                    let {
                        hashAttribute: F,
                        hashValue: U
                    } = this._getHashAttribute(m.hashAttribute), H = m.meta ? m.meta[_] : {}, q = {
                        key: H.key || "" + _,
                        featureId: R,
                        inExperiment: B,
                        hashUsed: C,
                        variationId: _,
                        value: m.variations[_],
                        hashAttribute: F,
                        hashValue: U
                    };
                    return H.name && (q.name = H.name), void 0 !== L && (q.bucket = L), H.passthrough && (q.passthrough = H.passthrough), q
                }
                _getContextUrl() {
                    return this._ctx.url || (ea ? window.location.href : "")
                }
                _urlIsValid(m) {
                    let _ = this._getContextUrl();
                    if (!_) return !1;
                    let C = _.replace(/^https?:\/\//, "").replace(/^[^/]*\//, "/");
                    return !!(m.test(_) || m.test(C))
                }
                _hasGroupOverlap(m) {
                    let _ = this._ctx.groups || {};
                    for (let C = 0; C < m.length; C++)
                        if (_[m[C]]) return !0;
                    return !1
                }
                _applyDOMChanges(m) {
                    if (!ea) return;
                    let _ = [];
                    if (m.css) {
                        let C = document.createElement("style");
                        C.innerHTML = m.css, document.head.appendChild(C), _.push(() => C.remove())
                    }
                    if (m.js) {
                        let C = document.createElement("script");
                        C.innerHTML = m.js, document.body.appendChild(C), _.push(() => C.remove())
                    }
                    return m.domMutations && m.domMutations.forEach(m => {
                        _.push(V.declarative(m).revert)
                    }), () => {
                        _.forEach(m => m())
                    }
                }
            };
            var es = C(67294);
            let ec = es.createContext({});

            function useFeatureIsOn(m) {
                let _ = function() {
                    let {
                        growthbook: m
                    } = es.useContext(ec);
                    return m
                }();
                return !!_ && _.isOn(m)
            }
            let GrowthBookProvider = ({
                children: m,
                growthbook: _
            }) => {
                let [C, R] = es.useState(0);
                return es.useEffect(() => {
                    if (_ && _.setRenderer) return _.setRenderer(() => {
                        R(m => m + 1)
                    }), () => {
                        _.setRenderer(() => {})
                    }
                }, [_]), es.createElement(ec.Provider, {
                    value: {
                        growthbook: _
                    }
                }, m)
            }
        },
        27243: function(m, _) {
            "use strict";
            let r = () => "undefined" != typeof window,
                t = () => !(!r() || !window.hj),
                e = (m, ..._) => {
                    if (r() && window.hj) return window.hj(m, ..._);
                    throw Error("Hotjar is not available, make sure init has been called.")
                },
                n = (m, _, C) => {
                    if (!((m, _, C) => {
                            try {
                                let R = document.getElementById(_) || document.createElement("script");
                                return R.id = _, R.nonce = C, R.innerText = m, R.crossOrigin = "anonymous", document.head.appendChild(R), !0
                            } catch (m) {
                                return !1
                            }
                        })(`(function(h,o,t,j,a,r){h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};h._hjSettings={hjid:${m},hjsv:${_},hjdebug:${(null==C?void 0:C.debug)||!1}};a=o.getElementsByTagName('head')[0];r=o.createElement('script');r.async=1;r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;a.appendChild(r);})(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');`, "hotjar-init-script", null == C ? void 0 : C.nonce) || !t()) throw Error("Failed to initialize Hotjar tracking script.")
                };
            _.Z = {
                init: (m, _, C) => {
                    try {
                        return n(m, _, C), !0
                    } catch (m) {
                        return console.error("Error:", m), !1
                    }
                },
                event: m => {
                    try {
                        return e("event", m), !0
                    } catch (m) {
                        return console.error("Error:", m), !1
                    }
                },
                identify: (m, _) => {
                    try {
                        return e("identify", m, _), !0
                    } catch (m) {
                        return console.error("Error:", m), !1
                    }
                },
                stateChange: m => {
                    try {
                        return e("stateChange", m), !0
                    } catch (m) {
                        return console.error("Error:", m), !1
                    }
                },
                isReady: t
            }
        },
        9669: function(m, _, C) {
            m.exports = C(51609)
        },
        55448: function(m, _, C) {
            "use strict";
            var R = C(64867),
                L = C(36026),
                B = C(4372),
                F = C(15327),
                U = C(94097),
                H = C(16373),
                q = C(67985),
                V = C(77874),
                X = C(82648),
                K = C(60644),
                Y = C(90205);
            m.exports = function(m) {
                return new Promise(function(_, C) {
                    var Q, et = m.data,
                        er = m.headers,
                        en = m.responseType;

                    function done() {
                        m.cancelToken && m.cancelToken.unsubscribe(Q), m.signal && m.signal.removeEventListener("abort", Q)
                    }
                    R.isFormData(et) && R.isStandardBrowserEnv() && delete er["Content-Type"];
                    var ei = new XMLHttpRequest;
                    if (m.auth) {
                        var eo = m.auth.username || "",
                            ea = m.auth.password ? unescape(encodeURIComponent(m.auth.password)) : "";
                        er.Authorization = "Basic " + btoa(eo + ":" + ea)
                    }
                    var es = U(m.baseURL, m.url);

                    function onloadend() {
                        if (ei) {
                            var R = "getAllResponseHeaders" in ei ? H(ei.getAllResponseHeaders()) : null;
                            L(function(m) {
                                _(m), done()
                            }, function(m) {
                                C(m), done()
                            }, {
                                data: en && "text" !== en && "json" !== en ? ei.response : ei.responseText,
                                status: ei.status,
                                statusText: ei.statusText,
                                headers: R,
                                config: m,
                                request: ei
                            }), ei = null
                        }
                    }
                    if (ei.open(m.method.toUpperCase(), F(es, m.params, m.paramsSerializer), !0), ei.timeout = m.timeout, "onloadend" in ei ? ei.onloadend = onloadend : ei.onreadystatechange = function() {
                            ei && 4 === ei.readyState && (0 !== ei.status || ei.responseURL && 0 === ei.responseURL.indexOf("file:")) && setTimeout(onloadend)
                        }, ei.onabort = function() {
                            ei && (C(new X("Request aborted", X.ECONNABORTED, m, ei)), ei = null)
                        }, ei.onerror = function() {
                            C(new X("Network Error", X.ERR_NETWORK, m, ei, ei)), ei = null
                        }, ei.ontimeout = function() {
                            var _ = m.timeout ? "timeout of " + m.timeout + "ms exceeded" : "timeout exceeded",
                                R = m.transitional || V;
                            m.timeoutErrorMessage && (_ = m.timeoutErrorMessage), C(new X(_, R.clarifyTimeoutError ? X.ETIMEDOUT : X.ECONNABORTED, m, ei)), ei = null
                        }, R.isStandardBrowserEnv()) {
                        var ec = (m.withCredentials || q(es)) && m.xsrfCookieName ? B.read(m.xsrfCookieName) : void 0;
                        ec && (er[m.xsrfHeaderName] = ec)
                    }
                    "setRequestHeader" in ei && R.forEach(er, function(m, _) {
                        void 0 === et && "content-type" === _.toLowerCase() ? delete er[_] : ei.setRequestHeader(_, m)
                    }), R.isUndefined(m.withCredentials) || (ei.withCredentials = !!m.withCredentials), en && "json" !== en && (ei.responseType = m.responseType), "function" == typeof m.onDownloadProgress && ei.addEventListener("progress", m.onDownloadProgress), "function" == typeof m.onUploadProgress && ei.upload && ei.upload.addEventListener("progress", m.onUploadProgress), (m.cancelToken || m.signal) && (Q = function(m) {
                        ei && (C(!m || m && m.type ? new K : m), ei.abort(), ei = null)
                    }, m.cancelToken && m.cancelToken.subscribe(Q), m.signal && (m.signal.aborted ? Q() : m.signal.addEventListener("abort", Q))), et || (et = null);
                    var el = Y(es);
                    if (el && -1 === ["http", "https", "file"].indexOf(el)) {
                        C(new X("Unsupported protocol " + el + ":", X.ERR_BAD_REQUEST, m));
                        return
                    }
                    ei.send(et)
                })
            }
        },
        51609: function(m, _, C) {
            "use strict";
            var R = C(64867),
                L = C(91849),
                B = C(30321),
                F = C(47185),
                U = function createInstance(m) {
                    var _ = new B(m),
                        C = L(B.prototype.request, _);
                    return R.extend(C, B.prototype, _), R.extend(C, _), C.create = function(_) {
                        return createInstance(F(m, _))
                    }, C
                }(C(45546));
            U.Axios = B, U.CanceledError = C(60644), U.CancelToken = C(14972), U.isCancel = C(26502), U.VERSION = C(97288).version, U.toFormData = C(47675), U.AxiosError = C(82648), U.Cancel = U.CanceledError, U.all = function(m) {
                return Promise.all(m)
            }, U.spread = C(8713), U.isAxiosError = C(16268), m.exports = U, m.exports.default = U
        },
        14972: function(m, _, C) {
            "use strict";
            var R = C(60644);

            function CancelToken(m) {
                if ("function" != typeof m) throw TypeError("executor must be a function.");
                this.promise = new Promise(function(m) {
                    _ = m
                });
                var _, C = this;
                this.promise.then(function(m) {
                    if (C._listeners) {
                        var _, R = C._listeners.length;
                        for (_ = 0; _ < R; _++) C._listeners[_](m);
                        C._listeners = null
                    }
                }), this.promise.then = function(m) {
                    var _, R = new Promise(function(m) {
                        C.subscribe(m), _ = m
                    }).then(m);
                    return R.cancel = function() {
                        C.unsubscribe(_)
                    }, R
                }, m(function(m) {
                    C.reason || (C.reason = new R(m), _(C.reason))
                })
            }
            CancelToken.prototype.throwIfRequested = function() {
                if (this.reason) throw this.reason
            }, CancelToken.prototype.subscribe = function(m) {
                if (this.reason) {
                    m(this.reason);
                    return
                }
                this._listeners ? this._listeners.push(m) : this._listeners = [m]
            }, CancelToken.prototype.unsubscribe = function(m) {
                if (this._listeners) {
                    var _ = this._listeners.indexOf(m); - 1 !== _ && this._listeners.splice(_, 1)
                }
            }, CancelToken.source = function() {
                var m;
                return {
                    token: new CancelToken(function(_) {
                        m = _
                    }),
                    cancel: m
                }
            }, m.exports = CancelToken
        },
        60644: function(m, _, C) {
            "use strict";
            var R = C(82648);

            function CanceledError(m) {
                R.call(this, null == m ? "canceled" : m, R.ERR_CANCELED), this.name = "CanceledError"
            }
            C(64867).inherits(CanceledError, R, {
                __CANCEL__: !0
            }), m.exports = CanceledError
        },
        26502: function(m) {
            "use strict";
            m.exports = function(m) {
                return !!(m && m.__CANCEL__)
            }
        },
        30321: function(m, _, C) {
            "use strict";
            var R = C(64867),
                L = C(15327),
                B = C(80782),
                F = C(13572),
                U = C(47185),
                H = C(94097),
                q = C(54875),
                V = q.validators;

            function Axios(m) {
                this.defaults = m, this.interceptors = {
                    request: new B,
                    response: new B
                }
            }
            Axios.prototype.request = function(m, _) {
                "string" == typeof m ? (_ = _ || {}).url = m : _ = m || {}, (_ = U(this.defaults, _)).method ? _.method = _.method.toLowerCase() : this.defaults.method ? _.method = this.defaults.method.toLowerCase() : _.method = "get";
                var C, R = _.transitional;
                void 0 !== R && q.assertOptions(R, {
                    silentJSONParsing: V.transitional(V.boolean),
                    forcedJSONParsing: V.transitional(V.boolean),
                    clarifyTimeoutError: V.transitional(V.boolean)
                }, !1);
                var L = [],
                    B = !0;
                this.interceptors.request.forEach(function(m) {
                    ("function" != typeof m.runWhen || !1 !== m.runWhen(_)) && (B = B && m.synchronous, L.unshift(m.fulfilled, m.rejected))
                });
                var H = [];
                if (this.interceptors.response.forEach(function(m) {
                        H.push(m.fulfilled, m.rejected)
                    }), !B) {
                    var X = [F, void 0];
                    for (Array.prototype.unshift.apply(X, L), X = X.concat(H), C = Promise.resolve(_); X.length;) C = C.then(X.shift(), X.shift());
                    return C
                }
                for (var K = _; L.length;) {
                    var Y = L.shift(),
                        Q = L.shift();
                    try {
                        K = Y(K)
                    } catch (m) {
                        Q(m);
                        break
                    }
                }
                try {
                    C = F(K)
                } catch (m) {
                    return Promise.reject(m)
                }
                for (; H.length;) C = C.then(H.shift(), H.shift());
                return C
            }, Axios.prototype.getUri = function(m) {
                return L(H((m = U(this.defaults, m)).baseURL, m.url), m.params, m.paramsSerializer)
            }, R.forEach(["delete", "get", "head", "options"], function(m) {
                Axios.prototype[m] = function(_, C) {
                    return this.request(U(C || {}, {
                        method: m,
                        url: _,
                        data: (C || {}).data
                    }))
                }
            }), R.forEach(["post", "put", "patch"], function(m) {
                function generateHTTPMethod(_) {
                    return function(C, R, L) {
                        return this.request(U(L || {}, {
                            method: m,
                            headers: _ ? {
                                "Content-Type": "multipart/form-data"
                            } : {},
                            url: C,
                            data: R
                        }))
                    }
                }
                Axios.prototype[m] = generateHTTPMethod(), Axios.prototype[m + "Form"] = generateHTTPMethod(!0)
            }), m.exports = Axios
        },
        82648: function(m, _, C) {
            "use strict";
            var R = C(64867);

            function AxiosError(m, _, C, R, L) {
                Error.call(this), this.message = m, this.name = "AxiosError", _ && (this.code = _), C && (this.config = C), R && (this.request = R), L && (this.response = L)
            }
            R.inherits(AxiosError, Error, {
                toJSON: function() {
                    return {
                        message: this.message,
                        name: this.name,
                        description: this.description,
                        number: this.number,
                        fileName: this.fileName,
                        lineNumber: this.lineNumber,
                        columnNumber: this.columnNumber,
                        stack: this.stack,
                        config: this.config,
                        code: this.code,
                        status: this.response && this.response.status ? this.response.status : null
                    }
                }
            });
            var L = AxiosError.prototype,
                B = {};
            ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED"].forEach(function(m) {
                B[m] = {
                    value: m
                }
            }), Object.defineProperties(AxiosError, B), Object.defineProperty(L, "isAxiosError", {
                value: !0
            }), AxiosError.from = function(m, _, C, B, F, U) {
                var H = Object.create(L);
                return R.toFlatObject(m, H, function(m) {
                    return m !== Error.prototype
                }), AxiosError.call(H, m.message, _, C, B, F), H.name = m.name, U && Object.assign(H, U), H
            }, m.exports = AxiosError
        },
        80782: function(m, _, C) {
            "use strict";
            var R = C(64867);

            function InterceptorManager() {
                this.handlers = []
            }
            InterceptorManager.prototype.use = function(m, _, C) {
                return this.handlers.push({
                    fulfilled: m,
                    rejected: _,
                    synchronous: !!C && C.synchronous,
                    runWhen: C ? C.runWhen : null
                }), this.handlers.length - 1
            }, InterceptorManager.prototype.eject = function(m) {
                this.handlers[m] && (this.handlers[m] = null)
            }, InterceptorManager.prototype.forEach = function(m) {
                R.forEach(this.handlers, function(_) {
                    null !== _ && m(_)
                })
            }, m.exports = InterceptorManager
        },
        94097: function(m, _, C) {
            "use strict";
            var R = C(91793),
                L = C(7303);
            m.exports = function(m, _) {
                return m && !R(_) ? L(m, _) : _
            }
        },
        13572: function(m, _, C) {
            "use strict";
            var R = C(64867),
                L = C(18527),
                B = C(26502),
                F = C(45546),
                U = C(60644);

            function throwIfCancellationRequested(m) {
                if (m.cancelToken && m.cancelToken.throwIfRequested(), m.signal && m.signal.aborted) throw new U
            }
            m.exports = function(m) {
                return throwIfCancellationRequested(m), m.headers = m.headers || {}, m.data = L.call(m, m.data, m.headers, m.transformRequest), m.headers = R.merge(m.headers.common || {}, m.headers[m.method] || {}, m.headers), R.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(_) {
                    delete m.headers[_]
                }), (m.adapter || F.adapter)(m).then(function(_) {
                    return throwIfCancellationRequested(m), _.data = L.call(m, _.data, _.headers, m.transformResponse), _
                }, function(_) {
                    return !B(_) && (throwIfCancellationRequested(m), _ && _.response && (_.response.data = L.call(m, _.response.data, _.response.headers, m.transformResponse))), Promise.reject(_)
                })
            }
        },
        47185: function(m, _, C) {
            "use strict";
            var R = C(64867);
            m.exports = function(m, _) {
                _ = _ || {};
                var C = {};

                function getMergedValue(m, _) {
                    return R.isPlainObject(m) && R.isPlainObject(_) ? R.merge(m, _) : R.isPlainObject(_) ? R.merge({}, _) : R.isArray(_) ? _.slice() : _
                }

                function mergeDeepProperties(C) {
                    return R.isUndefined(_[C]) ? R.isUndefined(m[C]) ? void 0 : getMergedValue(void 0, m[C]) : getMergedValue(m[C], _[C])
                }

                function valueFromConfig2(m) {
                    if (!R.isUndefined(_[m])) return getMergedValue(void 0, _[m])
                }

                function defaultToConfig2(C) {
                    return R.isUndefined(_[C]) ? R.isUndefined(m[C]) ? void 0 : getMergedValue(void 0, m[C]) : getMergedValue(void 0, _[C])
                }

                function mergeDirectKeys(C) {
                    return C in _ ? getMergedValue(m[C], _[C]) : C in m ? getMergedValue(void 0, m[C]) : void 0
                }
                var L = {
                    url: valueFromConfig2,
                    method: valueFromConfig2,
                    data: valueFromConfig2,
                    baseURL: defaultToConfig2,
                    transformRequest: defaultToConfig2,
                    transformResponse: defaultToConfig2,
                    paramsSerializer: defaultToConfig2,
                    timeout: defaultToConfig2,
                    timeoutMessage: defaultToConfig2,
                    withCredentials: defaultToConfig2,
                    adapter: defaultToConfig2,
                    responseType: defaultToConfig2,
                    xsrfCookieName: defaultToConfig2,
                    xsrfHeaderName: defaultToConfig2,
                    onUploadProgress: defaultToConfig2,
                    onDownloadProgress: defaultToConfig2,
                    decompress: defaultToConfig2,
                    maxContentLength: defaultToConfig2,
                    maxBodyLength: defaultToConfig2,
                    beforeRedirect: defaultToConfig2,
                    transport: defaultToConfig2,
                    httpAgent: defaultToConfig2,
                    httpsAgent: defaultToConfig2,
                    cancelToken: defaultToConfig2,
                    socketPath: defaultToConfig2,
                    responseEncoding: defaultToConfig2,
                    validateStatus: mergeDirectKeys
                };
                return R.forEach(Object.keys(m).concat(Object.keys(_)), function(m) {
                    var _ = L[m] || mergeDeepProperties,
                        B = _(m);
                    R.isUndefined(B) && _ !== mergeDirectKeys || (C[m] = B)
                }), C
            }
        },
        36026: function(m, _, C) {
            "use strict";
            var R = C(82648);
            m.exports = function(m, _, C) {
                var L = C.config.validateStatus;
                !C.status || !L || L(C.status) ? m(C) : _(new R("Request failed with status code " + C.status, [R.ERR_BAD_REQUEST, R.ERR_BAD_RESPONSE][Math.floor(C.status / 100) - 4], C.config, C.request, C))
            }
        },
        18527: function(m, _, C) {
            "use strict";
            var R = C(64867),
                L = C(45546);
            m.exports = function(m, _, C) {
                var B = this || L;
                return R.forEach(C, function(C) {
                    m = C.call(B, m, _)
                }), m
            }
        },
        45546: function(m, _, C) {
            "use strict";
            var R, L = C(34155),
                B = C(64867),
                F = C(16016),
                U = C(82648),
                H = C(77874),
                q = C(47675),
                V = {
                    "Content-Type": "application/x-www-form-urlencoded"
                };

            function setContentTypeIfUnset(m, _) {
                !B.isUndefined(m) && B.isUndefined(m["Content-Type"]) && (m["Content-Type"] = _)
            }
            var X = {
                transitional: H,
                adapter: ("undefined" != typeof XMLHttpRequest ? R = C(55448) : void 0 !== L && "[object process]" === Object.prototype.toString.call(L) && (R = C(55448)), R),
                transformRequest: [function(m, _) {
                    if (F(_, "Accept"), F(_, "Content-Type"), B.isFormData(m) || B.isArrayBuffer(m) || B.isBuffer(m) || B.isStream(m) || B.isFile(m) || B.isBlob(m)) return m;
                    if (B.isArrayBufferView(m)) return m.buffer;
                    if (B.isURLSearchParams(m)) return setContentTypeIfUnset(_, "application/x-www-form-urlencoded;charset=utf-8"), m.toString();
                    var C, R = B.isObject(m),
                        L = _ && _["Content-Type"];
                    if ((C = B.isFileList(m)) || R && "multipart/form-data" === L) {
                        var U = this.env && this.env.FormData;
                        return q(C ? {
                            "files[]": m
                        } : m, U && new U)
                    }
                    return R || "application/json" === L ? (setContentTypeIfUnset(_, "application/json"), function(m, _, C) {
                        if (B.isString(m)) try {
                            return (0, JSON.parse)(m), B.trim(m)
                        } catch (m) {
                            if ("SyntaxError" !== m.name) throw m
                        }
                        return (0, JSON.stringify)(m)
                    }(m)) : m
                }],
                transformResponse: [function(m) {
                    var _ = this.transitional || X.transitional,
                        C = _ && _.silentJSONParsing,
                        R = _ && _.forcedJSONParsing,
                        L = !C && "json" === this.responseType;
                    if (L || R && B.isString(m) && m.length) try {
                        return JSON.parse(m)
                    } catch (m) {
                        if (L) {
                            if ("SyntaxError" === m.name) throw U.from(m, U.ERR_BAD_RESPONSE, this, null, this.response);
                            throw m
                        }
                    }
                    return m
                }],
                timeout: 0,
                xsrfCookieName: "XSRF-TOKEN",
                xsrfHeaderName: "X-XSRF-TOKEN",
                maxContentLength: -1,
                maxBodyLength: -1,
                env: {
                    FormData: C(91623)
                },
                validateStatus: function(m) {
                    return m >= 200 && m < 300
                },
                headers: {
                    common: {
                        Accept: "application/json, text/plain, */*"
                    }
                }
            };
            B.forEach(["delete", "get", "head"], function(m) {
                X.headers[m] = {}
            }), B.forEach(["post", "put", "patch"], function(m) {
                X.headers[m] = B.merge(V)
            }), m.exports = X
        },
        77874: function(m) {
            "use strict";
            m.exports = {
                silentJSONParsing: !0,
                forcedJSONParsing: !0,
                clarifyTimeoutError: !1
            }
        },
        97288: function(m) {
            m.exports = {
                version: "0.27.2"
            }
        },
        91849: function(m) {
            "use strict";
            m.exports = function(m, _) {
                return function() {
                    for (var C = Array(arguments.length), R = 0; R < C.length; R++) C[R] = arguments[R];
                    return m.apply(_, C)
                }
            }
        },
        15327: function(m, _, C) {
            "use strict";
            var R = C(64867);

            function encode(m) {
                return encodeURIComponent(m).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
            }
            m.exports = function(m, _, C) {
                if (!_) return m;
                if (C) L = C(_);
                else if (R.isURLSearchParams(_)) L = _.toString();
                else {
                    var L, B = [];
                    R.forEach(_, function(m, _) {
                        null != m && (R.isArray(m) ? _ += "[]" : m = [m], R.forEach(m, function(m) {
                            R.isDate(m) ? m = m.toISOString() : R.isObject(m) && (m = JSON.stringify(m)), B.push(encode(_) + "=" + encode(m))
                        }))
                    }), L = B.join("&")
                }
                if (L) {
                    var F = m.indexOf("#"); - 1 !== F && (m = m.slice(0, F)), m += (-1 === m.indexOf("?") ? "?" : "&") + L
                }
                return m
            }
        },
        7303: function(m) {
            "use strict";
            m.exports = function(m, _) {
                return _ ? m.replace(/\/+$/, "") + "/" + _.replace(/^\/+/, "") : m
            }
        },
        4372: function(m, _, C) {
            "use strict";
            var R = C(64867);
            m.exports = R.isStandardBrowserEnv() ? {
                write: function(m, _, C, L, B, F) {
                    var U = [];
                    U.push(m + "=" + encodeURIComponent(_)), R.isNumber(C) && U.push("expires=" + new Date(C).toGMTString()), R.isString(L) && U.push("path=" + L), R.isString(B) && U.push("domain=" + B), !0 === F && U.push("secure"), document.cookie = U.join("; ")
                },
                read: function(m) {
                    var _ = document.cookie.match(RegExp("(^|;\\s*)(" + m + ")=([^;]*)"));
                    return _ ? decodeURIComponent(_[3]) : null
                },
                remove: function(m) {
                    this.write(m, "", Date.now() - 864e5)
                }
            } : {
                write: function() {},
                read: function() {
                    return null
                },
                remove: function() {}
            }
        },
        91793: function(m) {
            "use strict";
            m.exports = function(m) {
                return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(m)
            }
        },
        16268: function(m, _, C) {
            "use strict";
            var R = C(64867);
            m.exports = function(m) {
                return R.isObject(m) && !0 === m.isAxiosError
            }
        },
        67985: function(m, _, C) {
            "use strict";
            var R = C(64867);
            m.exports = R.isStandardBrowserEnv() ? function() {
                var m, _ = /(msie|trident)/i.test(navigator.userAgent),
                    C = document.createElement("a");

                function resolveURL(m) {
                    var R = m;
                    return _ && (C.setAttribute("href", R), R = C.href), C.setAttribute("href", R), {
                        href: C.href,
                        protocol: C.protocol ? C.protocol.replace(/:$/, "") : "",
                        host: C.host,
                        search: C.search ? C.search.replace(/^\?/, "") : "",
                        hash: C.hash ? C.hash.replace(/^#/, "") : "",
                        hostname: C.hostname,
                        port: C.port,
                        pathname: "/" === C.pathname.charAt(0) ? C.pathname : "/" + C.pathname
                    }
                }
                return m = resolveURL(window.location.href),
                    function(_) {
                        var C = R.isString(_) ? resolveURL(_) : _;
                        return C.protocol === m.protocol && C.host === m.host
                    }
            }() : function() {
                return !0
            }
        },
        16016: function(m, _, C) {
            "use strict";
            var R = C(64867);
            m.exports = function(m, _) {
                R.forEach(m, function(C, R) {
                    R !== _ && R.toUpperCase() === _.toUpperCase() && (m[_] = C, delete m[R])
                })
            }
        },
        91623: function(m) {
            m.exports = null
        },
        16373: function(m, _, C) {
            "use strict";
            var R = C(64867),
                L = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
            m.exports = function(m) {
                var _, C, B, F = {};
                return m && R.forEach(m.split("\n"), function(m) {
                    B = m.indexOf(":"), _ = R.trim(m.substr(0, B)).toLowerCase(), C = R.trim(m.substr(B + 1)), _ && !(F[_] && L.indexOf(_) >= 0) && ("set-cookie" === _ ? F[_] = (F[_] ? F[_] : []).concat([C]) : F[_] = F[_] ? F[_] + ", " + C : C)
                }), F
            }
        },
        90205: function(m) {
            "use strict";
            m.exports = function(m) {
                var _ = /^([-+\w]{1,25})(:?\/\/|:)/.exec(m);
                return _ && _[1] || ""
            }
        },
        8713: function(m) {
            "use strict";
            m.exports = function(m) {
                return function(_) {
                    return m.apply(null, _)
                }
            }
        },
        47675: function(m, _, C) {
            "use strict";
            var R = C(48764).lW,
                L = C(64867);
            m.exports = function(m, _) {
                _ = _ || new FormData;
                var C = [];

                function convertValue(m) {
                    return null === m ? "" : L.isDate(m) ? m.toISOString() : L.isArrayBuffer(m) || L.isTypedArray(m) ? "function" == typeof Blob ? new Blob([m]) : R.from(m) : m
                }
                return function build(m, R) {
                    if (L.isPlainObject(m) || L.isArray(m)) {
                        if (-1 !== C.indexOf(m)) throw Error("Circular reference detected in " + R);
                        C.push(m), L.forEach(m, function(m, C) {
                            if (!L.isUndefined(m)) {
                                var B, F = R ? R + "." + C : C;
                                if (m && !R && "object" == typeof m) {
                                    if (L.endsWith(C, "{}")) m = JSON.stringify(m);
                                    else if (L.endsWith(C, "[]") && (B = L.toArray(m))) {
                                        B.forEach(function(m) {
                                            L.isUndefined(m) || _.append(F, convertValue(m))
                                        });
                                        return
                                    }
                                }
                                build(m, F)
                            }
                        }), C.pop()
                    } else _.append(R, convertValue(m))
                }(m), _
            }
        },
        54875: function(m, _, C) {
            "use strict";
            var R = C(97288).version,
                L = C(82648),
                B = {};
            ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(m, _) {
                B[m] = function(C) {
                    return typeof C === m || "a" + (_ < 1 ? "n " : " ") + m
                }
            });
            var F = {};
            B.transitional = function(m, _, C) {
                function formatMessage(m, _) {
                    return "[Axios v" + R + "] Transitional option '" + m + "'" + _ + (C ? ". " + C : "")
                }
                return function(C, R, B) {
                    if (!1 === m) throw new L(formatMessage(R, " has been removed" + (_ ? " in " + _ : "")), L.ERR_DEPRECATED);
                    return _ && !F[R] && (F[R] = !0, console.warn(formatMessage(R, " has been deprecated since v" + _ + " and will be removed in the near future"))), !m || m(C, R, B)
                }
            }, m.exports = {
                assertOptions: function(m, _, C) {
                    if ("object" != typeof m) throw new L("options must be an object", L.ERR_BAD_OPTION_VALUE);
                    for (var R = Object.keys(m), B = R.length; B-- > 0;) {
                        var F = R[B],
                            U = _[F];
                        if (U) {
                            var H = m[F],
                                q = void 0 === H || U(H, F, m);
                            if (!0 !== q) throw new L("option " + F + " must be " + q, L.ERR_BAD_OPTION_VALUE);
                            continue
                        }
                        if (!0 !== C) throw new L("Unknown option " + F, L.ERR_BAD_OPTION)
                    }
                },
                validators: B
            }
        },
        64867: function(m, _, C) {
            "use strict";
            var R, L, B = C(91849),
                F = Object.prototype.toString,
                U = (R = Object.create(null), function(m) {
                    var _ = F.call(m);
                    return R[_] || (R[_] = _.slice(8, -1).toLowerCase())
                });

            function kindOfTest(m) {
                return m = m.toLowerCase(),
                    function(_) {
                        return U(_) === m
                    }
            }

            function isArray(m) {
                return Array.isArray(m)
            }

            function isUndefined(m) {
                return void 0 === m
            }
            var H = kindOfTest("ArrayBuffer");

            function isObject(m) {
                return null !== m && "object" == typeof m
            }

            function isPlainObject(m) {
                if ("object" !== U(m)) return !1;
                var _ = Object.getPrototypeOf(m);
                return null === _ || _ === Object.prototype
            }
            var q = kindOfTest("Date"),
                V = kindOfTest("File"),
                X = kindOfTest("Blob"),
                K = kindOfTest("FileList");

            function isFunction(m) {
                return "[object Function]" === F.call(m)
            }
            var Y = kindOfTest("URLSearchParams");

            function forEach(m, _) {
                if (null != m) {
                    if ("object" != typeof m && (m = [m]), isArray(m))
                        for (var C = 0, R = m.length; C < R; C++) _.call(null, m[C], C, m);
                    else
                        for (var L in m) Object.prototype.hasOwnProperty.call(m, L) && _.call(null, m[L], L, m)
                }
            }
            var Q = (L = "undefined" != typeof Uint8Array && Object.getPrototypeOf(Uint8Array), function(m) {
                return L && m instanceof L
            });
            m.exports = {
                isArray: isArray,
                isArrayBuffer: H,
                isBuffer: function(m) {
                    return null !== m && !isUndefined(m) && null !== m.constructor && !isUndefined(m.constructor) && "function" == typeof m.constructor.isBuffer && m.constructor.isBuffer(m)
                },
                isFormData: function(m) {
                    var _ = "[object FormData]";
                    return m && ("function" == typeof FormData && m instanceof FormData || F.call(m) === _ || isFunction(m.toString) && m.toString() === _)
                },
                isArrayBufferView: function(m) {
                    return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(m) : m && m.buffer && H(m.buffer)
                },
                isString: function(m) {
                    return "string" == typeof m
                },
                isNumber: function(m) {
                    return "number" == typeof m
                },
                isObject: isObject,
                isPlainObject: isPlainObject,
                isUndefined: isUndefined,
                isDate: q,
                isFile: V,
                isBlob: X,
                isFunction: isFunction,
                isStream: function(m) {
                    return isObject(m) && isFunction(m.pipe)
                },
                isURLSearchParams: Y,
                isStandardBrowserEnv: function() {
                    return ("undefined" == typeof navigator || "ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product) && "undefined" != typeof window && "undefined" != typeof document
                },
                forEach: forEach,
                merge: function merge() {
                    var m = {};

                    function assignValue(_, C) {
                        isPlainObject(m[C]) && isPlainObject(_) ? m[C] = merge(m[C], _) : isPlainObject(_) ? m[C] = merge({}, _) : isArray(_) ? m[C] = _.slice() : m[C] = _
                    }
                    for (var _ = 0, C = arguments.length; _ < C; _++) forEach(arguments[_], assignValue);
                    return m
                },
                extend: function(m, _, C) {
                    return forEach(_, function(_, R) {
                        C && "function" == typeof _ ? m[R] = B(_, C) : m[R] = _
                    }), m
                },
                trim: function(m) {
                    return m.trim ? m.trim() : m.replace(/^\s+|\s+$/g, "")
                },
                stripBOM: function(m) {
                    return 65279 === m.charCodeAt(0) && (m = m.slice(1)), m
                },
                inherits: function(m, _, C, R) {
                    m.prototype = Object.create(_.prototype, R), m.prototype.constructor = m, C && Object.assign(m.prototype, C)
                },
                toFlatObject: function(m, _, C) {
                    var R, L, B, F = {};
                    _ = _ || {};
                    do {
                        for (L = (R = Object.getOwnPropertyNames(m)).length; L-- > 0;) F[B = R[L]] || (_[B] = m[B], F[B] = !0);
                        m = Object.getPrototypeOf(m)
                    } while (m && (!C || C(m, _)) && m !== Object.prototype);
                    return _
                },
                kindOf: U,
                kindOfTest: kindOfTest,
                endsWith: function(m, _, C) {
                    m = String(m), (void 0 === C || C > m.length) && (C = m.length), C -= _.length;
                    var R = m.indexOf(_, C);
                    return -1 !== R && R === C
                },
                toArray: function(m) {
                    if (!m) return null;
                    var _ = m.length;
                    if (isUndefined(_)) return null;
                    for (var C = Array(_); _-- > 0;) C[_] = m[_];
                    return C
                },
                isTypedArray: Q,
                isFileList: K
            }
        },
        79742: function(m, _) {
            "use strict";
            _.byteLength = function(m) {
                var _ = getLens(m),
                    C = _[0],
                    R = _[1];
                return (C + R) * 3 / 4 - R
            }, _.toByteArray = function(m) {
                var _, C, B = getLens(m),
                    F = B[0],
                    U = B[1],
                    H = new L((F + U) * 3 / 4 - U),
                    q = 0,
                    V = U > 0 ? F - 4 : F;
                for (C = 0; C < V; C += 4) _ = R[m.charCodeAt(C)] << 18 | R[m.charCodeAt(C + 1)] << 12 | R[m.charCodeAt(C + 2)] << 6 | R[m.charCodeAt(C + 3)], H[q++] = _ >> 16 & 255, H[q++] = _ >> 8 & 255, H[q++] = 255 & _;
                return 2 === U && (_ = R[m.charCodeAt(C)] << 2 | R[m.charCodeAt(C + 1)] >> 4, H[q++] = 255 & _), 1 === U && (_ = R[m.charCodeAt(C)] << 10 | R[m.charCodeAt(C + 1)] << 4 | R[m.charCodeAt(C + 2)] >> 2, H[q++] = _ >> 8 & 255, H[q++] = 255 & _), H
            }, _.fromByteArray = function(m) {
                for (var _, R = m.length, L = R % 3, B = [], F = 0, U = R - L; F < U; F += 16383) B.push(function(m, _, R) {
                    for (var L, B = [], F = _; F < R; F += 3) B.push(C[(L = (m[F] << 16 & 16711680) + (m[F + 1] << 8 & 65280) + (255 & m[F + 2])) >> 18 & 63] + C[L >> 12 & 63] + C[L >> 6 & 63] + C[63 & L]);
                    return B.join("")
                }(m, F, F + 16383 > U ? U : F + 16383));
                return 1 === L ? B.push(C[(_ = m[R - 1]) >> 2] + C[_ << 4 & 63] + "==") : 2 === L && B.push(C[(_ = (m[R - 2] << 8) + m[R - 1]) >> 10] + C[_ >> 4 & 63] + C[_ << 2 & 63] + "="), B.join("")
            };
            for (var C = [], R = [], L = "undefined" != typeof Uint8Array ? Uint8Array : Array, B = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", F = 0, U = B.length; F < U; ++F) C[F] = B[F], R[B.charCodeAt(F)] = F;

            function getLens(m) {
                var _ = m.length;
                if (_ % 4 > 0) throw Error("Invalid string. Length must be a multiple of 4");
                var C = m.indexOf("="); - 1 === C && (C = _);
                var R = C === _ ? 0 : 4 - C % 4;
                return [C, R]
            }
            R["-".charCodeAt(0)] = 62, R["_".charCodeAt(0)] = 63
        },
        48764: function(m, _, C) {
            "use strict";
            /*!
             * The buffer module from node.js, for the browser.
             *
             * @author   Feross Aboukhadijeh <http://feross.org>
             * @license  MIT
             */
            var R = C(79742),
                L = C(80645),
                B = C(87300);

            function kMaxLength() {
                return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
            }

            function createBuffer(m, _) {
                if (kMaxLength() < _) throw RangeError("Invalid typed array length");
                return Buffer.TYPED_ARRAY_SUPPORT ? (m = new Uint8Array(_)).__proto__ = Buffer.prototype : (null === m && (m = new Buffer(_)), m.length = _), m
            }

            function Buffer(m, _, C) {
                if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) return new Buffer(m, _, C);
                if ("number" == typeof m) {
                    if ("string" == typeof _) throw Error("If encoding is specified then the first argument must be a string");
                    return allocUnsafe(this, m)
                }
                return from(this, m, _, C)
            }

            function from(m, _, C, R) {
                if ("number" == typeof _) throw TypeError('"value" argument must not be a number');
                return "undefined" != typeof ArrayBuffer && _ instanceof ArrayBuffer ? function(m, _, C, R) {
                    if (_.byteLength, C < 0 || _.byteLength < C) throw RangeError("'offset' is out of bounds");
                    if (_.byteLength < C + (R || 0)) throw RangeError("'length' is out of bounds");
                    return _ = void 0 === C && void 0 === R ? new Uint8Array(_) : void 0 === R ? new Uint8Array(_, C) : new Uint8Array(_, C, R), Buffer.TYPED_ARRAY_SUPPORT ? (m = _).__proto__ = Buffer.prototype : m = fromArrayLike(m, _), m
                }(m, _, C, R) : "string" == typeof _ ? function(m, _, C) {
                    if (("string" != typeof C || "" === C) && (C = "utf8"), !Buffer.isEncoding(C)) throw TypeError('"encoding" must be a valid string encoding');
                    var R = 0 | byteLength(_, C),
                        L = (m = createBuffer(m, R)).write(_, C);
                    return L !== R && (m = m.slice(0, L)), m
                }(m, _, C) : function(m, _) {
                    if (Buffer.isBuffer(_)) {
                        var C, R = 0 | checked(_.length);
                        return 0 === (m = createBuffer(m, R)).length || _.copy(m, 0, 0, R), m
                    }
                    if (_) {
                        if ("undefined" != typeof ArrayBuffer && _.buffer instanceof ArrayBuffer || "length" in _) return "number" != typeof _.length || (C = _.length) != C ? createBuffer(m, 0) : fromArrayLike(m, _);
                        if ("Buffer" === _.type && B(_.data)) return fromArrayLike(m, _.data)
                    }
                    throw TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
                }(m, _)
            }

            function assertSize(m) {
                if ("number" != typeof m) throw TypeError('"size" argument must be a number');
                if (m < 0) throw RangeError('"size" argument must not be negative')
            }

            function allocUnsafe(m, _) {
                if (assertSize(_), m = createBuffer(m, _ < 0 ? 0 : 0 | checked(_)), !Buffer.TYPED_ARRAY_SUPPORT)
                    for (var C = 0; C < _; ++C) m[C] = 0;
                return m
            }

            function fromArrayLike(m, _) {
                var C = _.length < 0 ? 0 : 0 | checked(_.length);
                m = createBuffer(m, C);
                for (var R = 0; R < C; R += 1) m[R] = 255 & _[R];
                return m
            }

            function checked(m) {
                if (m >= kMaxLength()) throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
                return 0 | m
            }

            function byteLength(m, _) {
                if (Buffer.isBuffer(m)) return m.length;
                if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(m) || m instanceof ArrayBuffer)) return m.byteLength;
                "string" != typeof m && (m = "" + m);
                var C = m.length;
                if (0 === C) return 0;
                for (var R = !1;;) switch (_) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return C;
                    case "utf8":
                    case "utf-8":
                    case void 0:
                        return utf8ToBytes(m).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * C;
                    case "hex":
                        return C >>> 1;
                    case "base64":
                        return base64ToBytes(m).length;
                    default:
                        if (R) return utf8ToBytes(m).length;
                        _ = ("" + _).toLowerCase(), R = !0
                }
            }

            function slowToString(m, _, C) {
                var L, B, F = !1;
                if ((void 0 === _ || _ < 0) && (_ = 0), _ > this.length || ((void 0 === C || C > this.length) && (C = this.length), C <= 0 || (C >>>= 0) <= (_ >>>= 0))) return "";
                for (m || (m = "utf8");;) switch (m) {
                    case "hex":
                        return function(m, _, C) {
                            var R, L = m.length;
                            (!_ || _ < 0) && (_ = 0), (!C || C < 0 || C > L) && (C = L);
                            for (var B = "", F = _; F < C; ++F) B += (R = m[F]) < 16 ? "0" + R.toString(16) : R.toString(16);
                            return B
                        }(this, _, C);
                    case "utf8":
                    case "utf-8":
                        return utf8Slice(this, _, C);
                    case "ascii":
                        return function(m, _, C) {
                            var R = "";
                            C = Math.min(m.length, C);
                            for (var L = _; L < C; ++L) R += String.fromCharCode(127 & m[L]);
                            return R
                        }(this, _, C);
                    case "latin1":
                    case "binary":
                        return function(m, _, C) {
                            var R = "";
                            C = Math.min(m.length, C);
                            for (var L = _; L < C; ++L) R += String.fromCharCode(m[L]);
                            return R
                        }(this, _, C);
                    case "base64":
                        return L = _, B = C, 0 === L && B === this.length ? R.fromByteArray(this) : R.fromByteArray(this.slice(L, B));
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return function(m, _, C) {
                            for (var R = m.slice(_, C), L = "", B = 0; B < R.length; B += 2) L += String.fromCharCode(R[B] + 256 * R[B + 1]);
                            return L
                        }(this, _, C);
                    default:
                        if (F) throw TypeError("Unknown encoding: " + m);
                        m = (m + "").toLowerCase(), F = !0
                }
            }

            function swap(m, _, C) {
                var R = m[_];
                m[_] = m[C], m[C] = R
            }

            function bidirectionalIndexOf(m, _, C, R, L) {
                if (0 === m.length) return -1;
                if ("string" == typeof C ? (R = C, C = 0) : C > 2147483647 ? C = 2147483647 : C < -2147483648 && (C = -2147483648), isNaN(C = +C) && (C = L ? 0 : m.length - 1), C < 0 && (C = m.length + C), C >= m.length) {
                    if (L) return -1;
                    C = m.length - 1
                } else if (C < 0) {
                    if (!L) return -1;
                    C = 0
                }
                if ("string" == typeof _ && (_ = Buffer.from(_, R)), Buffer.isBuffer(_)) return 0 === _.length ? -1 : arrayIndexOf(m, _, C, R, L);
                if ("number" == typeof _) return (_ &= 255, Buffer.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf) ? L ? Uint8Array.prototype.indexOf.call(m, _, C) : Uint8Array.prototype.lastIndexOf.call(m, _, C) : arrayIndexOf(m, [_], C, R, L);
                throw TypeError("val must be string, number or Buffer")
            }

            function arrayIndexOf(m, _, C, R, L) {
                var B, F = 1,
                    U = m.length,
                    H = _.length;
                if (void 0 !== R && ("ucs2" === (R = String(R).toLowerCase()) || "ucs-2" === R || "utf16le" === R || "utf-16le" === R)) {
                    if (m.length < 2 || _.length < 2) return -1;
                    F = 2, U /= 2, H /= 2, C /= 2
                }

                function read(m, _) {
                    return 1 === F ? m[_] : m.readUInt16BE(_ * F)
                }
                if (L) {
                    var q = -1;
                    for (B = C; B < U; B++)
                        if (read(m, B) === read(_, -1 === q ? 0 : B - q)) {
                            if (-1 === q && (q = B), B - q + 1 === H) return q * F
                        } else -1 !== q && (B -= B - q), q = -1
                } else
                    for (C + H > U && (C = U - H), B = C; B >= 0; B--) {
                        for (var V = !0, X = 0; X < H; X++)
                            if (read(m, B + X) !== read(_, X)) {
                                V = !1;
                                break
                            }
                        if (V) return B
                    }
                return -1
            }

            function utf8Slice(m, _, C) {
                C = Math.min(m.length, C);
                for (var R = [], L = _; L < C;) {
                    var B, F, U, H, q = m[L],
                        V = null,
                        X = q > 239 ? 4 : q > 223 ? 3 : q > 191 ? 2 : 1;
                    if (L + X <= C) switch (X) {
                        case 1:
                            q < 128 && (V = q);
                            break;
                        case 2:
                            (192 & (B = m[L + 1])) == 128 && (H = (31 & q) << 6 | 63 & B) > 127 && (V = H);
                            break;
                        case 3:
                            B = m[L + 1], F = m[L + 2], (192 & B) == 128 && (192 & F) == 128 && (H = (15 & q) << 12 | (63 & B) << 6 | 63 & F) > 2047 && (H < 55296 || H > 57343) && (V = H);
                            break;
                        case 4:
                            B = m[L + 1], F = m[L + 2], U = m[L + 3], (192 & B) == 128 && (192 & F) == 128 && (192 & U) == 128 && (H = (15 & q) << 18 | (63 & B) << 12 | (63 & F) << 6 | 63 & U) > 65535 && H < 1114112 && (V = H)
                    }
                    null === V ? (V = 65533, X = 1) : V > 65535 && (V -= 65536, R.push(V >>> 10 & 1023 | 55296), V = 56320 | 1023 & V), R.push(V), L += X
                }
                return function(m) {
                    var _ = m.length;
                    if (_ <= 4096) return String.fromCharCode.apply(String, m);
                    for (var C = "", R = 0; R < _;) C += String.fromCharCode.apply(String, m.slice(R, R += 4096));
                    return C
                }(R)
            }

            function checkOffset(m, _, C) {
                if (m % 1 != 0 || m < 0) throw RangeError("offset is not uint");
                if (m + _ > C) throw RangeError("Trying to access beyond buffer length")
            }

            function checkInt(m, _, C, R, L, B) {
                if (!Buffer.isBuffer(m)) throw TypeError('"buffer" argument must be a Buffer instance');
                if (_ > L || _ < B) throw RangeError('"value" argument is out of bounds');
                if (C + R > m.length) throw RangeError("Index out of range")
            }

            function objectWriteUInt16(m, _, C, R) {
                _ < 0 && (_ = 65535 + _ + 1);
                for (var L = 0, B = Math.min(m.length - C, 2); L < B; ++L) m[C + L] = (_ & 255 << 8 * (R ? L : 1 - L)) >>> (R ? L : 1 - L) * 8
            }

            function objectWriteUInt32(m, _, C, R) {
                _ < 0 && (_ = 4294967295 + _ + 1);
                for (var L = 0, B = Math.min(m.length - C, 4); L < B; ++L) m[C + L] = _ >>> (R ? L : 3 - L) * 8 & 255
            }

            function checkIEEE754(m, _, C, R, L, B) {
                if (C + R > m.length || C < 0) throw RangeError("Index out of range")
            }

            function writeFloat(m, _, C, R, B) {
                return B || checkIEEE754(m, _, C, 4, 34028234663852886e22, -34028234663852886e22), L.write(m, _, C, R, 23, 4), C + 4
            }

            function writeDouble(m, _, C, R, B) {
                return B || checkIEEE754(m, _, C, 8, 17976931348623157e292, -17976931348623157e292), L.write(m, _, C, R, 52, 8), C + 8
            }
            _.lW = Buffer, _.h2 = 50, Buffer.TYPED_ARRAY_SUPPORT = void 0 !== C.g.TYPED_ARRAY_SUPPORT ? C.g.TYPED_ARRAY_SUPPORT : function() {
                try {
                    var m = new Uint8Array(1);
                    return m.__proto__ = {
                        __proto__: Uint8Array.prototype,
                        foo: function() {
                            return 42
                        }
                    }, 42 === m.foo() && "function" == typeof m.subarray && 0 === m.subarray(1, 1).byteLength
                } catch (m) {
                    return !1
                }
            }(), kMaxLength(), Buffer.poolSize = 8192, Buffer._augment = function(m) {
                return m.__proto__ = Buffer.prototype, m
            }, Buffer.from = function(m, _, C) {
                return from(null, m, _, C)
            }, Buffer.TYPED_ARRAY_SUPPORT && (Buffer.prototype.__proto__ = Uint8Array.prototype, Buffer.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && Buffer[Symbol.species] === Buffer && Object.defineProperty(Buffer, Symbol.species, {
                value: null,
                configurable: !0
            })), Buffer.alloc = function(m, _, C) {
                return (assertSize(m), m <= 0) ? createBuffer(null, m) : void 0 !== _ ? "string" == typeof C ? createBuffer(null, m).fill(_, C) : createBuffer(null, m).fill(_) : createBuffer(null, m)
            }, Buffer.allocUnsafe = function(m) {
                return allocUnsafe(null, m)
            }, Buffer.allocUnsafeSlow = function(m) {
                return allocUnsafe(null, m)
            }, Buffer.isBuffer = function(m) {
                return !!(null != m && m._isBuffer)
            }, Buffer.compare = function(m, _) {
                if (!Buffer.isBuffer(m) || !Buffer.isBuffer(_)) throw TypeError("Arguments must be Buffers");
                if (m === _) return 0;
                for (var C = m.length, R = _.length, L = 0, B = Math.min(C, R); L < B; ++L)
                    if (m[L] !== _[L]) {
                        C = m[L], R = _[L];
                        break
                    }
                return C < R ? -1 : R < C ? 1 : 0
            }, Buffer.isEncoding = function(m) {
                switch (String(m).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return !0;
                    default:
                        return !1
                }
            }, Buffer.concat = function(m, _) {
                if (!B(m)) throw TypeError('"list" argument must be an Array of Buffers');
                if (0 === m.length) return Buffer.alloc(0);
                if (void 0 === _)
                    for (C = 0, _ = 0; C < m.length; ++C) _ += m[C].length;
                var C, R = Buffer.allocUnsafe(_),
                    L = 0;
                for (C = 0; C < m.length; ++C) {
                    var F = m[C];
                    if (!Buffer.isBuffer(F)) throw TypeError('"list" argument must be an Array of Buffers');
                    F.copy(R, L), L += F.length
                }
                return R
            }, Buffer.byteLength = byteLength, Buffer.prototype._isBuffer = !0, Buffer.prototype.swap16 = function() {
                var m = this.length;
                if (m % 2 != 0) throw RangeError("Buffer size must be a multiple of 16-bits");
                for (var _ = 0; _ < m; _ += 2) swap(this, _, _ + 1);
                return this
            }, Buffer.prototype.swap32 = function() {
                var m = this.length;
                if (m % 4 != 0) throw RangeError("Buffer size must be a multiple of 32-bits");
                for (var _ = 0; _ < m; _ += 4) swap(this, _, _ + 3), swap(this, _ + 1, _ + 2);
                return this
            }, Buffer.prototype.swap64 = function() {
                var m = this.length;
                if (m % 8 != 0) throw RangeError("Buffer size must be a multiple of 64-bits");
                for (var _ = 0; _ < m; _ += 8) swap(this, _, _ + 7), swap(this, _ + 1, _ + 6), swap(this, _ + 2, _ + 5), swap(this, _ + 3, _ + 4);
                return this
            }, Buffer.prototype.toString = function() {
                var m = 0 | this.length;
                return 0 === m ? "" : 0 == arguments.length ? utf8Slice(this, 0, m) : slowToString.apply(this, arguments)
            }, Buffer.prototype.equals = function(m) {
                if (!Buffer.isBuffer(m)) throw TypeError("Argument must be a Buffer");
                return this === m || 0 === Buffer.compare(this, m)
            }, Buffer.prototype.inspect = function() {
                var m = "",
                    C = _.h2;
                return this.length > 0 && (m = this.toString("hex", 0, C).match(/.{2}/g).join(" "), this.length > C && (m += " ... ")), "<Buffer " + m + ">"
            }, Buffer.prototype.compare = function(m, _, C, R, L) {
                if (!Buffer.isBuffer(m)) throw TypeError("Argument must be a Buffer");
                if (void 0 === _ && (_ = 0), void 0 === C && (C = m ? m.length : 0), void 0 === R && (R = 0), void 0 === L && (L = this.length), _ < 0 || C > m.length || R < 0 || L > this.length) throw RangeError("out of range index");
                if (R >= L && _ >= C) return 0;
                if (R >= L) return -1;
                if (_ >= C) return 1;
                if (_ >>>= 0, C >>>= 0, R >>>= 0, L >>>= 0, this === m) return 0;
                for (var B = L - R, F = C - _, U = Math.min(B, F), H = this.slice(R, L), q = m.slice(_, C), V = 0; V < U; ++V)
                    if (H[V] !== q[V]) {
                        B = H[V], F = q[V];
                        break
                    }
                return B < F ? -1 : F < B ? 1 : 0
            }, Buffer.prototype.includes = function(m, _, C) {
                return -1 !== this.indexOf(m, _, C)
            }, Buffer.prototype.indexOf = function(m, _, C) {
                return bidirectionalIndexOf(this, m, _, C, !0)
            }, Buffer.prototype.lastIndexOf = function(m, _, C) {
                return bidirectionalIndexOf(this, m, _, C, !1)
            }, Buffer.prototype.write = function(m, _, C, R) {
                if (void 0 === _) R = "utf8", C = this.length, _ = 0;
                else if (void 0 === C && "string" == typeof _) R = _, C = this.length, _ = 0;
                else if (isFinite(_)) _ |= 0, isFinite(C) ? (C |= 0, void 0 === R && (R = "utf8")) : (R = C, C = void 0);
                else throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                var L, B, F, U, H, q, V, X, K, Y, Q, et, er = this.length - _;
                if ((void 0 === C || C > er) && (C = er), m.length > 0 && (C < 0 || _ < 0) || _ > this.length) throw RangeError("Attempt to write outside buffer bounds");
                R || (R = "utf8");
                for (var en = !1;;) switch (R) {
                    case "hex":
                        return function(m, _, C, R) {
                            C = Number(C) || 0;
                            var L = m.length - C;
                            R ? (R = Number(R)) > L && (R = L) : R = L;
                            var B = _.length;
                            if (B % 2 != 0) throw TypeError("Invalid hex string");
                            R > B / 2 && (R = B / 2);
                            for (var F = 0; F < R; ++F) {
                                var U = parseInt(_.substr(2 * F, 2), 16);
                                if (isNaN(U)) break;
                                m[C + F] = U
                            }
                            return F
                        }(this, m, _, C);
                    case "utf8":
                    case "utf-8":
                        return H = _, q = C, blitBuffer(utf8ToBytes(m, this.length - H), this, H, q);
                    case "ascii":
                        return V = _, X = C, blitBuffer(asciiToBytes(m), this, V, X);
                    case "latin1":
                    case "binary":
                        return L = this, B = m, F = _, U = C, blitBuffer(asciiToBytes(B), L, F, U);
                    case "base64":
                        return K = _, Y = C, blitBuffer(base64ToBytes(m), this, K, Y);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return Q = _, et = C, blitBuffer(function(m, _) {
                            for (var C, R, L = [], B = 0; B < m.length && !((_ -= 2) < 0); ++B) R = (C = m.charCodeAt(B)) >> 8, L.push(C % 256), L.push(R);
                            return L
                        }(m, this.length - Q), this, Q, et);
                    default:
                        if (en) throw TypeError("Unknown encoding: " + R);
                        R = ("" + R).toLowerCase(), en = !0
                }
            }, Buffer.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }, Buffer.prototype.slice = function(m, _) {
                var C, R = this.length;
                if (m = ~~m, _ = void 0 === _ ? R : ~~_, m < 0 ? (m += R) < 0 && (m = 0) : m > R && (m = R), _ < 0 ? (_ += R) < 0 && (_ = 0) : _ > R && (_ = R), _ < m && (_ = m), Buffer.TYPED_ARRAY_SUPPORT)(C = this.subarray(m, _)).__proto__ = Buffer.prototype;
                else {
                    var L = _ - m;
                    C = new Buffer(L, void 0);
                    for (var B = 0; B < L; ++B) C[B] = this[B + m]
                }
                return C
            }, Buffer.prototype.readUIntLE = function(m, _, C) {
                m |= 0, _ |= 0, C || checkOffset(m, _, this.length);
                for (var R = this[m], L = 1, B = 0; ++B < _ && (L *= 256);) R += this[m + B] * L;
                return R
            }, Buffer.prototype.readUIntBE = function(m, _, C) {
                m |= 0, _ |= 0, C || checkOffset(m, _, this.length);
                for (var R = this[m + --_], L = 1; _ > 0 && (L *= 256);) R += this[m + --_] * L;
                return R
            }, Buffer.prototype.readUInt8 = function(m, _) {
                return _ || checkOffset(m, 1, this.length), this[m]
            }, Buffer.prototype.readUInt16LE = function(m, _) {
                return _ || checkOffset(m, 2, this.length), this[m] | this[m + 1] << 8
            }, Buffer.prototype.readUInt16BE = function(m, _) {
                return _ || checkOffset(m, 2, this.length), this[m] << 8 | this[m + 1]
            }, Buffer.prototype.readUInt32LE = function(m, _) {
                return _ || checkOffset(m, 4, this.length), (this[m] | this[m + 1] << 8 | this[m + 2] << 16) + 16777216 * this[m + 3]
            }, Buffer.prototype.readUInt32BE = function(m, _) {
                return _ || checkOffset(m, 4, this.length), 16777216 * this[m] + (this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3])
            }, Buffer.prototype.readIntLE = function(m, _, C) {
                m |= 0, _ |= 0, C || checkOffset(m, _, this.length);
                for (var R = this[m], L = 1, B = 0; ++B < _ && (L *= 256);) R += this[m + B] * L;
                return R >= (L *= 128) && (R -= Math.pow(2, 8 * _)), R
            }, Buffer.prototype.readIntBE = function(m, _, C) {
                m |= 0, _ |= 0, C || checkOffset(m, _, this.length);
                for (var R = _, L = 1, B = this[m + --R]; R > 0 && (L *= 256);) B += this[m + --R] * L;
                return B >= (L *= 128) && (B -= Math.pow(2, 8 * _)), B
            }, Buffer.prototype.readInt8 = function(m, _) {
                return (_ || checkOffset(m, 1, this.length), 128 & this[m]) ? -((255 - this[m] + 1) * 1) : this[m]
            }, Buffer.prototype.readInt16LE = function(m, _) {
                _ || checkOffset(m, 2, this.length);
                var C = this[m] | this[m + 1] << 8;
                return 32768 & C ? 4294901760 | C : C
            }, Buffer.prototype.readInt16BE = function(m, _) {
                _ || checkOffset(m, 2, this.length);
                var C = this[m + 1] | this[m] << 8;
                return 32768 & C ? 4294901760 | C : C
            }, Buffer.prototype.readInt32LE = function(m, _) {
                return _ || checkOffset(m, 4, this.length), this[m] | this[m + 1] << 8 | this[m + 2] << 16 | this[m + 3] << 24
            }, Buffer.prototype.readInt32BE = function(m, _) {
                return _ || checkOffset(m, 4, this.length), this[m] << 24 | this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3]
            }, Buffer.prototype.readFloatLE = function(m, _) {
                return _ || checkOffset(m, 4, this.length), L.read(this, m, !0, 23, 4)
            }, Buffer.prototype.readFloatBE = function(m, _) {
                return _ || checkOffset(m, 4, this.length), L.read(this, m, !1, 23, 4)
            }, Buffer.prototype.readDoubleLE = function(m, _) {
                return _ || checkOffset(m, 8, this.length), L.read(this, m, !0, 52, 8)
            }, Buffer.prototype.readDoubleBE = function(m, _) {
                return _ || checkOffset(m, 8, this.length), L.read(this, m, !1, 52, 8)
            }, Buffer.prototype.writeUIntLE = function(m, _, C, R) {
                if (m = +m, _ |= 0, C |= 0, !R) {
                    var L = Math.pow(2, 8 * C) - 1;
                    checkInt(this, m, _, C, L, 0)
                }
                var B = 1,
                    F = 0;
                for (this[_] = 255 & m; ++F < C && (B *= 256);) this[_ + F] = m / B & 255;
                return _ + C
            }, Buffer.prototype.writeUIntBE = function(m, _, C, R) {
                if (m = +m, _ |= 0, C |= 0, !R) {
                    var L = Math.pow(2, 8 * C) - 1;
                    checkInt(this, m, _, C, L, 0)
                }
                var B = C - 1,
                    F = 1;
                for (this[_ + B] = 255 & m; --B >= 0 && (F *= 256);) this[_ + B] = m / F & 255;
                return _ + C
            }, Buffer.prototype.writeUInt8 = function(m, _, C) {
                return m = +m, _ |= 0, C || checkInt(this, m, _, 1, 255, 0), Buffer.TYPED_ARRAY_SUPPORT || (m = Math.floor(m)), this[_] = 255 & m, _ + 1
            }, Buffer.prototype.writeUInt16LE = function(m, _, C) {
                return m = +m, _ |= 0, C || checkInt(this, m, _, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[_] = 255 & m, this[_ + 1] = m >>> 8) : objectWriteUInt16(this, m, _, !0), _ + 2
            }, Buffer.prototype.writeUInt16BE = function(m, _, C) {
                return m = +m, _ |= 0, C || checkInt(this, m, _, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[_] = m >>> 8, this[_ + 1] = 255 & m) : objectWriteUInt16(this, m, _, !1), _ + 2
            }, Buffer.prototype.writeUInt32LE = function(m, _, C) {
                return m = +m, _ |= 0, C || checkInt(this, m, _, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[_ + 3] = m >>> 24, this[_ + 2] = m >>> 16, this[_ + 1] = m >>> 8, this[_] = 255 & m) : objectWriteUInt32(this, m, _, !0), _ + 4
            }, Buffer.prototype.writeUInt32BE = function(m, _, C) {
                return m = +m, _ |= 0, C || checkInt(this, m, _, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[_] = m >>> 24, this[_ + 1] = m >>> 16, this[_ + 2] = m >>> 8, this[_ + 3] = 255 & m) : objectWriteUInt32(this, m, _, !1), _ + 4
            }, Buffer.prototype.writeIntLE = function(m, _, C, R) {
                if (m = +m, _ |= 0, !R) {
                    var L = Math.pow(2, 8 * C - 1);
                    checkInt(this, m, _, C, L - 1, -L)
                }
                var B = 0,
                    F = 1,
                    U = 0;
                for (this[_] = 255 & m; ++B < C && (F *= 256);) m < 0 && 0 === U && 0 !== this[_ + B - 1] && (U = 1), this[_ + B] = (m / F >> 0) - U & 255;
                return _ + C
            }, Buffer.prototype.writeIntBE = function(m, _, C, R) {
                if (m = +m, _ |= 0, !R) {
                    var L = Math.pow(2, 8 * C - 1);
                    checkInt(this, m, _, C, L - 1, -L)
                }
                var B = C - 1,
                    F = 1,
                    U = 0;
                for (this[_ + B] = 255 & m; --B >= 0 && (F *= 256);) m < 0 && 0 === U && 0 !== this[_ + B + 1] && (U = 1), this[_ + B] = (m / F >> 0) - U & 255;
                return _ + C
            }, Buffer.prototype.writeInt8 = function(m, _, C) {
                return m = +m, _ |= 0, C || checkInt(this, m, _, 1, 127, -128), Buffer.TYPED_ARRAY_SUPPORT || (m = Math.floor(m)), m < 0 && (m = 255 + m + 1), this[_] = 255 & m, _ + 1
            }, Buffer.prototype.writeInt16LE = function(m, _, C) {
                return m = +m, _ |= 0, C || checkInt(this, m, _, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[_] = 255 & m, this[_ + 1] = m >>> 8) : objectWriteUInt16(this, m, _, !0), _ + 2
            }, Buffer.prototype.writeInt16BE = function(m, _, C) {
                return m = +m, _ |= 0, C || checkInt(this, m, _, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[_] = m >>> 8, this[_ + 1] = 255 & m) : objectWriteUInt16(this, m, _, !1), _ + 2
            }, Buffer.prototype.writeInt32LE = function(m, _, C) {
                return m = +m, _ |= 0, C || checkInt(this, m, _, 4, 2147483647, -2147483648), Buffer.TYPED_ARRAY_SUPPORT ? (this[_] = 255 & m, this[_ + 1] = m >>> 8, this[_ + 2] = m >>> 16, this[_ + 3] = m >>> 24) : objectWriteUInt32(this, m, _, !0), _ + 4
            }, Buffer.prototype.writeInt32BE = function(m, _, C) {
                return m = +m, _ |= 0, C || checkInt(this, m, _, 4, 2147483647, -2147483648), m < 0 && (m = 4294967295 + m + 1), Buffer.TYPED_ARRAY_SUPPORT ? (this[_] = m >>> 24, this[_ + 1] = m >>> 16, this[_ + 2] = m >>> 8, this[_ + 3] = 255 & m) : objectWriteUInt32(this, m, _, !1), _ + 4
            }, Buffer.prototype.writeFloatLE = function(m, _, C) {
                return writeFloat(this, m, _, !0, C)
            }, Buffer.prototype.writeFloatBE = function(m, _, C) {
                return writeFloat(this, m, _, !1, C)
            }, Buffer.prototype.writeDoubleLE = function(m, _, C) {
                return writeDouble(this, m, _, !0, C)
            }, Buffer.prototype.writeDoubleBE = function(m, _, C) {
                return writeDouble(this, m, _, !1, C)
            }, Buffer.prototype.copy = function(m, _, C, R) {
                if (C || (C = 0), R || 0 === R || (R = this.length), _ >= m.length && (_ = m.length), _ || (_ = 0), R > 0 && R < C && (R = C), R === C || 0 === m.length || 0 === this.length) return 0;
                if (_ < 0) throw RangeError("targetStart out of bounds");
                if (C < 0 || C >= this.length) throw RangeError("sourceStart out of bounds");
                if (R < 0) throw RangeError("sourceEnd out of bounds");
                R > this.length && (R = this.length), m.length - _ < R - C && (R = m.length - _ + C);
                var L, B = R - C;
                if (this === m && C < _ && _ < R)
                    for (L = B - 1; L >= 0; --L) m[L + _] = this[L + C];
                else if (B < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT)
                    for (L = 0; L < B; ++L) m[L + _] = this[L + C];
                else Uint8Array.prototype.set.call(m, this.subarray(C, C + B), _);
                return B
            }, Buffer.prototype.fill = function(m, _, C, R) {
                if ("string" == typeof m) {
                    if ("string" == typeof _ ? (R = _, _ = 0, C = this.length) : "string" == typeof C && (R = C, C = this.length), 1 === m.length) {
                        var L, B = m.charCodeAt(0);
                        B < 256 && (m = B)
                    }
                    if (void 0 !== R && "string" != typeof R) throw TypeError("encoding must be a string");
                    if ("string" == typeof R && !Buffer.isEncoding(R)) throw TypeError("Unknown encoding: " + R)
                } else "number" == typeof m && (m &= 255);
                if (_ < 0 || this.length < _ || this.length < C) throw RangeError("Out of range index");
                if (C <= _) return this;
                if (_ >>>= 0, C = void 0 === C ? this.length : C >>> 0, m || (m = 0), "number" == typeof m)
                    for (L = _; L < C; ++L) this[L] = m;
                else {
                    var F = Buffer.isBuffer(m) ? m : utf8ToBytes(new Buffer(m, R).toString()),
                        U = F.length;
                    for (L = 0; L < C - _; ++L) this[L + _] = F[L % U]
                }
                return this
            };
            var F = /[^+\/0-9A-Za-z-_]/g;

            function utf8ToBytes(m, _) {
                _ = _ || 1 / 0;
                for (var C, R = m.length, L = null, B = [], F = 0; F < R; ++F) {
                    if ((C = m.charCodeAt(F)) > 55295 && C < 57344) {
                        if (!L) {
                            if (C > 56319 || F + 1 === R) {
                                (_ -= 3) > -1 && B.push(239, 191, 189);
                                continue
                            }
                            L = C;
                            continue
                        }
                        if (C < 56320) {
                            (_ -= 3) > -1 && B.push(239, 191, 189), L = C;
                            continue
                        }
                        C = (L - 55296 << 10 | C - 56320) + 65536
                    } else L && (_ -= 3) > -1 && B.push(239, 191, 189);
                    if (L = null, C < 128) {
                        if ((_ -= 1) < 0) break;
                        B.push(C)
                    } else if (C < 2048) {
                        if ((_ -= 2) < 0) break;
                        B.push(C >> 6 | 192, 63 & C | 128)
                    } else if (C < 65536) {
                        if ((_ -= 3) < 0) break;
                        B.push(C >> 12 | 224, C >> 6 & 63 | 128, 63 & C | 128)
                    } else if (C < 1114112) {
                        if ((_ -= 4) < 0) break;
                        B.push(C >> 18 | 240, C >> 12 & 63 | 128, C >> 6 & 63 | 128, 63 & C | 128)
                    } else throw Error("Invalid code point")
                }
                return B
            }

            function asciiToBytes(m) {
                for (var _ = [], C = 0; C < m.length; ++C) _.push(255 & m.charCodeAt(C));
                return _
            }

            function base64ToBytes(m) {
                return R.toByteArray(function(m) {
                    var _;
                    if ((m = ((_ = m).trim ? _.trim() : _.replace(/^\s+|\s+$/g, "")).replace(F, "")).length < 2) return "";
                    for (; m.length % 4 != 0;) m += "=";
                    return m
                }(m))
            }

            function blitBuffer(m, _, C, R) {
                for (var L = 0; L < R && !(L + C >= _.length) && !(L >= m.length); ++L) _[L + C] = m[L];
                return L
            }
        },
        87300: function(m) {
            var _ = {}.toString;
            m.exports = Array.isArray || function(m) {
                return "[object Array]" == _.call(m)
            }
        },
        80645: function(m, _) { /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
            _.read = function(m, _, C, R, L) {
                var B, F, U = 8 * L - R - 1,
                    H = (1 << U) - 1,
                    q = H >> 1,
                    V = -7,
                    X = C ? L - 1 : 0,
                    K = C ? -1 : 1,
                    Y = m[_ + X];
                for (X += K, B = Y & (1 << -V) - 1, Y >>= -V, V += U; V > 0; B = 256 * B + m[_ + X], X += K, V -= 8);
                for (F = B & (1 << -V) - 1, B >>= -V, V += R; V > 0; F = 256 * F + m[_ + X], X += K, V -= 8);
                if (0 === B) B = 1 - q;
                else {
                    if (B === H) return F ? NaN : (Y ? -1 : 1) * (1 / 0);
                    F += Math.pow(2, R), B -= q
                }
                return (Y ? -1 : 1) * F * Math.pow(2, B - R)
            }, _.write = function(m, _, C, R, L, B) {
                var F, U, H, q = 8 * B - L - 1,
                    V = (1 << q) - 1,
                    X = V >> 1,
                    K = 23 === L ? 5960464477539062e-23 : 0,
                    Y = R ? 0 : B - 1,
                    Q = R ? 1 : -1,
                    et = _ < 0 || 0 === _ && 1 / _ < 0 ? 1 : 0;
                for (isNaN(_ = Math.abs(_)) || _ === 1 / 0 ? (U = isNaN(_) ? 1 : 0, F = V) : (F = Math.floor(Math.log(_) / Math.LN2), _ * (H = Math.pow(2, -F)) < 1 && (F--, H *= 2), F + X >= 1 ? _ += K / H : _ += K * Math.pow(2, 1 - X), _ * H >= 2 && (F++, H /= 2), F + X >= V ? (U = 0, F = V) : F + X >= 1 ? (U = (_ * H - 1) * Math.pow(2, L), F += X) : (U = _ * Math.pow(2, X - 1) * Math.pow(2, L), F = 0)); L >= 8; m[C + Y] = 255 & U, Y += Q, U /= 256, L -= 8);
                for (F = F << L | U, q += L; q > 0; m[C + Y] = 255 & F, Y += Q, F /= 256, q -= 8);
                m[C + Y - Q] |= 128 * et
            }
        },
        83198: function(m, _, C) {
            "use strict";
            let R, L, B, F, U, H;

            function isShadowRoot(m) {
                let _ = null == m ? void 0 : m.host;
                return (null == _ ? void 0 : _.shadowRoot) === m
            }

            function isNativeShadowDom(m) {
                return "[object ShadowRoot]" === Object.prototype.toString.call(m)
            }

            function stringifyStylesheet(m) {
                try {
                    var _;
                    let C = m.rules || m.cssRules;
                    return C ? ((_ = Array.from(C, stringifyRule).join("")).includes(" background-clip: text;") && !_.includes(" -webkit-background-clip: text;") && (_ = _.replace(" background-clip: text;", " -webkit-background-clip: text; background-clip: text;")), _) : null
                } catch (m) {
                    return null
                }
            }

            function stringifyRule(m) {
                let _;
                if ("styleSheet" in m) try {
                    _ = stringifyStylesheet(m.styleSheet) || function(m) {
                        let {
                            cssText: _
                        } = m;
                        if (_.split('"').length < 3) return _;
                        let C = ["@import", `url(${JSON.stringify(m.href)})`];
                        return "" === m.layerName ? C.push("layer") : m.layerName && C.push(`layer(${m.layerName})`), m.supportsText && C.push(`supports(${m.supportsText})`), m.media.length && C.push(m.media.mediaText), C.join(" ") + ";"
                    }(m)
                } catch (m) {} else if ("selectorText" in m && m.selectorText.includes(":")) return m.cssText.replace(/(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm, "$1\\$2");
                return _ || m.cssText
            }
            C.d(_, {
                Z: function() {
                    return t3
                }
            }), (eT = eR || (eR = {}))[eT.Document = 0] = "Document", eT[eT.DocumentType = 1] = "DocumentType", eT[eT.Element = 2] = "Element", eT[eT.Text = 3] = "Text", eT[eT.CDATA = 4] = "CDATA", eT[eT.Comment = 5] = "Comment";
            let Mirror = class Mirror {
                constructor() {
                    this.idNodeMap = new Map, this.nodeMetaMap = new WeakMap
                }
                getId(m) {
                    var _;
                    if (!m) return -1;
                    let C = null === (_ = this.getMeta(m)) || void 0 === _ ? void 0 : _.id;
                    return null != C ? C : -1
                }
                getNode(m) {
                    return this.idNodeMap.get(m) || null
                }
                getIds() {
                    return Array.from(this.idNodeMap.keys())
                }
                getMeta(m) {
                    return this.nodeMetaMap.get(m) || null
                }
                removeNodeFromMap(m) {
                    let _ = this.getId(m);
                    this.idNodeMap.delete(_), m.childNodes && m.childNodes.forEach(m => this.removeNodeFromMap(m))
                }
                has(m) {
                    return this.idNodeMap.has(m)
                }
                hasNode(m) {
                    return this.nodeMetaMap.has(m)
                }
                add(m, _) {
                    let C = _.id;
                    this.idNodeMap.set(C, m), this.nodeMetaMap.set(m, _)
                }
                replace(m, _) {
                    let C = this.getNode(m);
                    if (C) {
                        let m = this.nodeMetaMap.get(C);
                        m && this.nodeMetaMap.set(_, m)
                    }
                    this.idNodeMap.set(m, _)
                }
                reset() {
                    this.idNodeMap = new Map, this.nodeMetaMap = new WeakMap
                }
            };

            function maskInputValue({
                element: m,
                maskInputOptions: _,
                tagName: C,
                type: R,
                value: L,
                maskInputFn: B
            }) {
                let F = L || "",
                    U = R && toLowerCase(R);
                return (_[C.toLowerCase()] || U && _[U]) && (F = B ? B(F, m) : "*".repeat(F.length)), F
            }

            function toLowerCase(m) {
                return m.toLowerCase()
            }
            let q = "__rrweb_original__";

            function getInputType(m) {
                let _ = m.type;
                return m.hasAttribute("data-rr-is-password") ? "password" : _ ? toLowerCase(_) : null
            }

            function extractFileExtension(m, _) {
                var C;
                let R;
                try {
                    R = new URL(m, null != _ ? _ : window.location.href)
                } catch (m) {
                    return null
                }
                let L = R.pathname.match(/\.([0-9a-z]+)(?:$)/i);
                return null !== (C = null == L ? void 0 : L[1]) && void 0 !== C ? C : null
            }
            let V = 1,
                X = RegExp("[^a-z0-9-_:]");

            function genId() {
                return V++
            }
            let K = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm,
                Y = /^(?:[a-z+]+:)?\/\//i,
                Q = /^www\..*/i,
                et = /^(data:)([^,]*),(.*)/i;

            function absoluteToStylesheet(m, _) {
                return (m || "").replace(K, (m, C, R, L, B, F) => {
                    let U = R || B || F,
                        H = C || L || "";
                    if (!U) return m;
                    if (Y.test(U) || Q.test(U) || et.test(U)) return `url(${H}${U}${H})`;
                    if ("/" === U[0]) return `url(${H}${(_.indexOf("//")>-1?_.split("/").slice(0,3).join("/"):_.split("/")[0]).split("?")[0]+U}${H})`;
                    let q = _.split("/"),
                        V = U.split("/");
                    for (let m of (q.pop(), V)) "." !== m && (".." === m ? q.pop() : q.push(m));
                    return `url(${H}${q.join("/")}${H})`
                })
            }
            let er = /^[^ \t\n\r\u000c]+/,
                en = /^[, \t\n\r\u000c]+/;

            function absoluteToDoc(m, _) {
                if (!_ || "" === _.trim()) return _;
                let C = m.createElement("a");
                return C.href = _, C.href
            }

            function getHref() {
                let m = document.createElement("a");
                return m.href = "", m.href
            }

            function transformAttribute(m, _, C, R) {
                return R ? "src" !== C && ("href" !== C || "use" === _ && "#" === R[0]) && ("xlink:href" !== C || "#" === R[0]) && ("background" !== C || "table" !== _ && "td" !== _ && "th" !== _) ? "srcset" === C ? function(m, _) {
                    if ("" === _.trim()) return _;
                    let C = 0;

                    function collectCharacters(m) {
                        let R;
                        let L = m.exec(_.substring(C));
                        return L ? (R = L[0], C += R.length, R) : ""
                    }
                    let R = [];
                    for (; collectCharacters(en), !(C >= _.length);) {
                        let L = collectCharacters(er);
                        if ("," === L.slice(-1)) L = absoluteToDoc(m, L.substring(0, L.length - 1)), R.push(L);
                        else {
                            let B = "";
                            L = absoluteToDoc(m, L);
                            let F = !1;
                            for (;;) {
                                let m = _.charAt(C);
                                if ("" === m) {
                                    R.push((L + B).trim());
                                    break
                                }
                                if (F) ")" === m && (F = !1);
                                else {
                                    if ("," === m) {
                                        C += 1, R.push((L + B).trim());
                                        break
                                    }
                                    "(" === m && (F = !0)
                                }
                                B += m, C += 1
                            }
                        }
                    }
                    return R.join(", ")
                }(m, R) : "style" === C ? absoluteToStylesheet(R, getHref()) : "object" === _ && "data" === C ? absoluteToDoc(m, R) : R : absoluteToDoc(m, R) : R
            }

            function ignoreAttribute(m, _, C) {
                return ("video" === m || "audio" === m) && "autoplay" === _
            }

            function classMatchesRegex(m, _, C) {
                if (!m) return !1;
                if (m.nodeType !== m.ELEMENT_NODE) return !!C && classMatchesRegex(m.parentNode, _, C);
                for (let C = m.classList.length; C--;) {
                    let R = m.classList[C];
                    if (_.test(R)) return !0
                }
                return !!C && classMatchesRegex(m.parentNode, _, C)
            }

            function needMaskingText(m, _, C, R) {
                try {
                    let L = m.nodeType === m.ELEMENT_NODE ? m : m.parentElement;
                    if (null === L) return !1;
                    if ("string" == typeof _) {
                        if (R) {
                            if (L.closest(`.${_}`)) return !0
                        } else if (L.classList.contains(_)) return !0
                    } else if (classMatchesRegex(L, _, R)) return !0;
                    if (C) {
                        if (R) {
                            if (L.closest(C)) return !0
                        } else if (L.matches(C)) return !0
                    }
                } catch (m) {}
                return !1
            }

            function lowerIfExists(m) {
                return null == m ? "" : m.toLowerCase()
            }

            function serializeNodeWithId(m, _) {
                let C;
                let {
                    doc: B,
                    mirror: F,
                    blockClass: U,
                    blockSelector: H,
                    maskTextClass: V,
                    maskTextSelector: K,
                    skipChild: Y = !1,
                    inlineStylesheet: Q = !0,
                    maskInputOptions: et = {},
                    maskTextFn: er,
                    maskInputFn: en,
                    slimDOMOptions: ei,
                    dataURLOptions: eo = {},
                    inlineImages: ea = !1,
                    recordCanvas: es = !1,
                    onSerialize: ec,
                    onIframeLoad: el,
                    iframeLoadTimeout: eu = 5e3,
                    onStylesheetLoad: ed,
                    stylesheetLoadTimeout: ep = 5e3,
                    keepIframeSrcFn: eh = () => !1,
                    newlyAddedElement: ef = !1
                } = _, {
                    needsMask: em
                } = _, {
                    preserveWhiteSpace: eg = !0
                } = _;
                if (!em && m.childNodes) {
                    let _ = void 0 === em;
                    em = needMaskingText(m, V, K, _)
                }
                let ey = function(m, _) {
                    let {
                        doc: C,
                        mirror: B,
                        blockClass: F,
                        blockSelector: U,
                        needsMask: H,
                        inlineStylesheet: V,
                        maskInputOptions: K = {},
                        maskTextFn: Y,
                        maskInputFn: Q,
                        dataURLOptions: et = {},
                        inlineImages: er,
                        recordCanvas: en,
                        keepIframeSrcFn: ei,
                        newlyAddedElement: eo = !1
                    } = _, ea = function(m, _) {
                        if (!_.hasNode(m)) return;
                        let C = _.getId(m);
                        return 1 === C ? void 0 : C
                    }(C, B);
                    switch (m.nodeType) {
                        case m.DOCUMENT_NODE:
                            if ("CSS1Compat" !== m.compatMode) return {
                                type: eR.Document,
                                childNodes: [],
                                compatMode: m.compatMode
                            };
                            return {
                                type: eR.Document,
                                childNodes: []
                            };
                        case m.DOCUMENT_TYPE_NODE:
                            return {
                                type: eR.DocumentType,
                                name: m.name,
                                publicId: m.publicId,
                                systemId: m.systemId,
                                rootId: ea
                            };
                        case m.ELEMENT_NODE:
                            return function(m, _) {
                                let C;
                                let {
                                    doc: B,
                                    blockClass: F,
                                    blockSelector: U,
                                    inlineStylesheet: H,
                                    maskInputOptions: V = {},
                                    maskInputFn: K,
                                    dataURLOptions: Y = {},
                                    inlineImages: Q,
                                    recordCanvas: et,
                                    keepIframeSrcFn: er,
                                    newlyAddedElement: en = !1,
                                    rootId: ei
                                } = _, eo = function(m, _, C) {
                                    try {
                                        if ("string" == typeof _) {
                                            if (m.classList.contains(_)) return !0
                                        } else
                                            for (let C = m.classList.length; C--;) {
                                                let R = m.classList[C];
                                                if (_.test(R)) return !0
                                            }
                                        if (C) return m.matches(C)
                                    } catch (m) {}
                                    return !1
                                }(m, F, U), ea = function(m) {
                                    if (m instanceof HTMLFormElement) return "form";
                                    let _ = toLowerCase(m.tagName);
                                    return X.test(_) ? "div" : _
                                }(m), es = {}, ec = m.attributes.length;
                                for (let _ = 0; _ < ec; _++) {
                                    let C = m.attributes[_];
                                    ignoreAttribute(ea, C.name, C.value) || (es[C.name] = transformAttribute(B, ea, toLowerCase(C.name), C.value))
                                }
                                if ("link" === ea && H) {
                                    let _ = Array.from(B.styleSheets).find(_ => _.href === m.href),
                                        C = null;
                                    _ && (C = stringifyStylesheet(_)), C && (delete es.rel, delete es.href, es._cssText = absoluteToStylesheet(C, _.href))
                                }
                                if ("style" === ea && m.sheet && !(m.innerText || m.textContent || "").trim().length) {
                                    let _ = stringifyStylesheet(m.sheet);
                                    _ && (es._cssText = absoluteToStylesheet(_, getHref()))
                                }
                                if ("input" === ea || "textarea" === ea || "select" === ea) {
                                    let _ = m.value,
                                        C = m.checked;
                                    "radio" !== es.type && "checkbox" !== es.type && "submit" !== es.type && "button" !== es.type && _ ? es.value = maskInputValue({
                                        element: m,
                                        type: getInputType(m),
                                        tagName: ea,
                                        value: _,
                                        maskInputOptions: V,
                                        maskInputFn: K
                                    }) : C && (es.checked = C)
                                }
                                if ("option" === ea && (m.selected && !V.select ? es.selected = !0 : delete es.selected), "canvas" === ea && et) {
                                    if ("2d" === m.__context) ! function(m) {
                                        let _ = m.getContext("2d");
                                        if (!_) return !0;
                                        for (let C = 0; C < m.width; C += 50)
                                            for (let R = 0; R < m.height; R += 50) {
                                                let L = _.getImageData,
                                                    B = q in L ? L[q] : L,
                                                    F = new Uint32Array(B.call(_, C, R, Math.min(50, m.width - C), Math.min(50, m.height - R)).data.buffer);
                                                if (F.some(m => 0 !== m)) return !1
                                            }
                                        return !0
                                    }(m) && (es.rr_dataURL = m.toDataURL(Y.type, Y.quality));
                                    else if (!("__context" in m)) {
                                        let _ = m.toDataURL(Y.type, Y.quality),
                                            C = document.createElement("canvas");
                                        C.width = m.width, C.height = m.height;
                                        let R = C.toDataURL(Y.type, Y.quality);
                                        _ !== R && (es.rr_dataURL = _)
                                    }
                                }
                                if ("img" === ea && Q) {
                                    R || (L = (R = B.createElement("canvas")).getContext("2d"));
                                    let _ = m.crossOrigin;
                                    m.crossOrigin = "anonymous";
                                    let recordInlineImage = () => {
                                        m.removeEventListener("load", recordInlineImage);
                                        try {
                                            R.width = m.naturalWidth, R.height = m.naturalHeight, L.drawImage(m, 0, 0), es.rr_dataURL = R.toDataURL(Y.type, Y.quality)
                                        } catch (_) {
                                            console.warn(`Cannot inline img src=${m.currentSrc}! Error: ${_}`)
                                        }
                                        _ ? es.crossOrigin = _ : m.removeAttribute("crossorigin")
                                    };
                                    m.complete && 0 !== m.naturalWidth ? recordInlineImage() : m.addEventListener("load", recordInlineImage)
                                }
                                if ("audio" === ea || "video" === ea) {
                                    let _ = es;
                                    _.rr_mediaState = m.paused ? "paused" : "played", _.rr_mediaCurrentTime = m.currentTime, _.rr_mediaPlaybackRate = m.playbackRate, _.rr_mediaMuted = m.muted, _.rr_mediaLoop = m.loop, _.rr_mediaVolume = m.volume
                                }
                                if (!en && (m.scrollLeft && (es.rr_scrollLeft = m.scrollLeft), m.scrollTop && (es.rr_scrollTop = m.scrollTop)), eo) {
                                    let {
                                        width: _,
                                        height: C
                                    } = m.getBoundingClientRect();
                                    es = {
                                        class: es.class,
                                        rr_width: `${_}px`,
                                        rr_height: `${C}px`
                                    }
                                }
                                "iframe" !== ea || er(es.src) || (m.contentDocument || (es.rr_src = es.src), delete es.src);
                                try {
                                    customElements.get(ea) && (C = !0)
                                } catch (m) {}
                                return {
                                    type: eR.Element,
                                    tagName: ea,
                                    attributes: es,
                                    childNodes: [],
                                    isSVG: !!("svg" === m.tagName || m.ownerSVGElement) || void 0,
                                    needBlock: eo,
                                    rootId: ei,
                                    isCustom: C
                                }
                            }(m, {
                                doc: C,
                                blockClass: F,
                                blockSelector: U,
                                inlineStylesheet: V,
                                maskInputOptions: K,
                                maskInputFn: Q,
                                dataURLOptions: et,
                                inlineImages: er,
                                recordCanvas: en,
                                keepIframeSrcFn: ei,
                                newlyAddedElement: eo,
                                rootId: ea
                            });
                        case m.TEXT_NODE:
                            return function(m, _) {
                                var C;
                                let {
                                    needsMask: R,
                                    maskTextFn: L,
                                    rootId: B
                                } = _, F = m.parentNode && m.parentNode.tagName, U = m.textContent, H = "STYLE" === F || void 0, q = "SCRIPT" === F || void 0;
                                if (H && U) {
                                    try {
                                        m.nextSibling || m.previousSibling || (null === (C = m.parentNode.sheet) || void 0 === C ? void 0 : C.cssRules) && (U = stringifyStylesheet(m.parentNode.sheet))
                                    } catch (_) {
                                        console.warn(`Cannot get CSS styles from text's parentNode. Error: ${_}`, m)
                                    }
                                    U = absoluteToStylesheet(U, getHref())
                                }
                                return q && (U = "SCRIPT_PLACEHOLDER"), !H && !q && U && R && (U = L ? L(U, m.parentElement) : U.replace(/[\S]/g, "*")), {
                                    type: eR.Text,
                                    textContent: U || "",
                                    isStyle: H,
                                    rootId: B
                                }
                            }(m, {
                                needsMask: H,
                                maskTextFn: Y,
                                rootId: ea
                            });
                        case m.CDATA_SECTION_NODE:
                            return {
                                type: eR.CDATA,
                                textContent: "",
                                rootId: ea
                            };
                        case m.COMMENT_NODE:
                            return {
                                type: eR.Comment,
                                textContent: m.textContent || "",
                                rootId: ea
                            };
                        default:
                            return !1
                    }
                }(m, {
                    doc: B,
                    mirror: F,
                    blockClass: U,
                    blockSelector: H,
                    needsMask: em,
                    inlineStylesheet: Q,
                    maskInputOptions: et,
                    maskTextFn: er,
                    maskInputFn: en,
                    dataURLOptions: eo,
                    inlineImages: ea,
                    recordCanvas: es,
                    keepIframeSrcFn: eh,
                    newlyAddedElement: ef
                });
                if (!ey) return console.warn(m, "not serialized"), null;
                C = F.hasNode(m) ? F.getId(m) : ! function(m, _) {
                    if (_.comment && m.type === eR.Comment) return !0;
                    if (m.type === eR.Element) {
                        if (_.script && ("script" === m.tagName || "link" === m.tagName && ("preload" === m.attributes.rel || "modulepreload" === m.attributes.rel) && "script" === m.attributes.as || "link" === m.tagName && "prefetch" === m.attributes.rel && "string" == typeof m.attributes.href && "js" === extractFileExtension(m.attributes.href)) || _.headFavicon && ("link" === m.tagName && "shortcut icon" === m.attributes.rel || "meta" === m.tagName && (lowerIfExists(m.attributes.name).match(/^msapplication-tile(image|color)$/) || "application-name" === lowerIfExists(m.attributes.name) || "icon" === lowerIfExists(m.attributes.rel) || "apple-touch-icon" === lowerIfExists(m.attributes.rel) || "shortcut icon" === lowerIfExists(m.attributes.rel)))) return !0;
                        if ("meta" === m.tagName) {
                            if (_.headMetaDescKeywords && lowerIfExists(m.attributes.name).match(/^description|keywords$/) || _.headMetaSocial && (lowerIfExists(m.attributes.property).match(/^(og|twitter|fb):/) || lowerIfExists(m.attributes.name).match(/^(og|twitter):/) || "pinterest" === lowerIfExists(m.attributes.name))) return !0;
                            if (_.headMetaRobots && ("robots" === lowerIfExists(m.attributes.name) || "googlebot" === lowerIfExists(m.attributes.name) || "bingbot" === lowerIfExists(m.attributes.name))) return !0;
                            if (_.headMetaHttpEquiv && void 0 !== m.attributes["http-equiv"]) return !0;
                            else if (_.headMetaAuthorship && ("author" === lowerIfExists(m.attributes.name) || "generator" === lowerIfExists(m.attributes.name) || "framework" === lowerIfExists(m.attributes.name) || "publisher" === lowerIfExists(m.attributes.name) || "progid" === lowerIfExists(m.attributes.name) || lowerIfExists(m.attributes.property).match(/^article:/) || lowerIfExists(m.attributes.property).match(/^product:/))) return !0;
                            else if (_.headMetaVerification && ("google-site-verification" === lowerIfExists(m.attributes.name) || "yandex-verification" === lowerIfExists(m.attributes.name) || "csrf-token" === lowerIfExists(m.attributes.name) || "p:domain_verify" === lowerIfExists(m.attributes.name) || "verify-v1" === lowerIfExists(m.attributes.name) || "verification" === lowerIfExists(m.attributes.name) || "shopify-checkout-api-token" === lowerIfExists(m.attributes.name))) return !0
                        }
                    }
                    return !1
                }(ey, ei) && (eg || ey.type !== eR.Text || ey.isStyle || ey.textContent.replace(/^\s+|\s+$/gm, "").length) ? genId() : -2;
                let e_ = Object.assign(ey, {
                    id: C
                });
                if (F.add(m, e_), -2 === C) return null;
                ec && ec(m);
                let ev = !Y;
                if (e_.type === eR.Element) {
                    ev = ev && !e_.needBlock, delete e_.needBlock;
                    let _ = m.shadowRoot;
                    _ && isNativeShadowDom(_) && (e_.isShadowHost = !0)
                }
                if ((e_.type === eR.Document || e_.type === eR.Element) && ev) {
                    ei.headWhitespace && e_.type === eR.Element && "head" === e_.tagName && (eg = !1);
                    let _ = {
                        doc: B,
                        mirror: F,
                        blockClass: U,
                        blockSelector: H,
                        needsMask: em,
                        maskTextClass: V,
                        maskTextSelector: K,
                        skipChild: Y,
                        inlineStylesheet: Q,
                        maskInputOptions: et,
                        maskTextFn: er,
                        maskInputFn: en,
                        slimDOMOptions: ei,
                        dataURLOptions: eo,
                        inlineImages: ea,
                        recordCanvas: es,
                        preserveWhiteSpace: eg,
                        onSerialize: ec,
                        onIframeLoad: el,
                        iframeLoadTimeout: eu,
                        onStylesheetLoad: ed,
                        stylesheetLoadTimeout: ep,
                        keepIframeSrcFn: eh
                    };
                    if (e_.type === eR.Element && "textarea" === e_.tagName && void 0 !== e_.attributes.value);
                    else
                        for (let C of Array.from(m.childNodes)) {
                            let m = serializeNodeWithId(C, _);
                            m && e_.childNodes.push(m)
                        }
                    if (m.nodeType === m.ELEMENT_NODE && m.shadowRoot)
                        for (let C of Array.from(m.shadowRoot.childNodes)) {
                            let R = serializeNodeWithId(C, _);
                            R && (isNativeShadowDom(m.shadowRoot) && (R.isShadow = !0), e_.childNodes.push(R))
                        }
                }
                return m.parentNode && isShadowRoot(m.parentNode) && isNativeShadowDom(m.parentNode) && (e_.isShadow = !0), e_.type === eR.Element && "iframe" === e_.tagName && function(m, _, C) {
                    let R;
                    let L = m.contentWindow;
                    if (!L) return;
                    let B = !1;
                    try {
                        R = L.document.readyState
                    } catch (m) {
                        return
                    }
                    if ("complete" !== R) {
                        let R = setTimeout(() => {
                            B || (_(), B = !0)
                        }, C);
                        m.addEventListener("load", () => {
                            clearTimeout(R), B = !0, _()
                        });
                        return
                    }
                    let F = "about:blank";
                    if (L.location.href !== F || m.src === F || "" === m.src) return setTimeout(_, 0), m.addEventListener("load", _);
                    m.addEventListener("load", _)
                }(m, () => {
                    let _ = m.contentDocument;
                    if (_ && el) {
                        let C = serializeNodeWithId(_, {
                            doc: _,
                            mirror: F,
                            blockClass: U,
                            blockSelector: H,
                            needsMask: em,
                            maskTextClass: V,
                            maskTextSelector: K,
                            skipChild: !1,
                            inlineStylesheet: Q,
                            maskInputOptions: et,
                            maskTextFn: er,
                            maskInputFn: en,
                            slimDOMOptions: ei,
                            dataURLOptions: eo,
                            inlineImages: ea,
                            recordCanvas: es,
                            preserveWhiteSpace: eg,
                            onSerialize: ec,
                            onIframeLoad: el,
                            iframeLoadTimeout: eu,
                            onStylesheetLoad: ed,
                            stylesheetLoadTimeout: ep,
                            keepIframeSrcFn: eh
                        });
                        C && el(m, C)
                    }
                }, eu), e_.type === eR.Element && "link" === e_.tagName && "string" == typeof e_.attributes.rel && ("stylesheet" === e_.attributes.rel || "preload" === e_.attributes.rel && "string" == typeof e_.attributes.href && "css" === extractFileExtension(e_.attributes.href)) && function(m, _, C) {
                    let R, L = !1;
                    try {
                        R = m.sheet
                    } catch (m) {
                        return
                    }
                    if (R) return;
                    let B = setTimeout(() => {
                        L || (_(), L = !0)
                    }, C);
                    m.addEventListener("load", () => {
                        clearTimeout(B), L = !0, _()
                    })
                }(m, () => {
                    if (ed) {
                        let _ = serializeNodeWithId(m, {
                            doc: B,
                            mirror: F,
                            blockClass: U,
                            blockSelector: H,
                            needsMask: em,
                            maskTextClass: V,
                            maskTextSelector: K,
                            skipChild: !1,
                            inlineStylesheet: Q,
                            maskInputOptions: et,
                            maskTextFn: er,
                            maskInputFn: en,
                            slimDOMOptions: ei,
                            dataURLOptions: eo,
                            inlineImages: ea,
                            recordCanvas: es,
                            preserveWhiteSpace: eg,
                            onSerialize: ec,
                            onIframeLoad: el,
                            iframeLoadTimeout: eu,
                            onStylesheetLoad: ed,
                            stylesheetLoadTimeout: ep,
                            keepIframeSrcFn: eh
                        });
                        _ && ed(m, _)
                    }
                }, ep), e_
            }

            function on(m, _, C = document) {
                let R = {
                    capture: !0,
                    passive: !0
                };
                return C.addEventListener(m, _, R), () => C.removeEventListener(m, _, R)
            }
            let ei = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording.",
                eo = {
                    map: {},
                    getId: () => (console.error(ei), -1),
                    getNode: () => (console.error(ei), null),
                    removeNodeFromMap() {
                        console.error(ei)
                    },
                    has: () => (console.error(ei), !1),
                    reset() {
                        console.error(ei)
                    }
                };

            function throttle(m, _, C = {}) {
                let R = null,
                    L = 0;
                return function(...B) {
                    let F = Date.now();
                    L || !1 !== C.leading || (L = F);
                    let U = _ - (F - L),
                        H = this;
                    U <= 0 || U > _ ? (R && (clearTimeout(R), R = null), L = F, m.apply(H, B)) : R || !1 === C.trailing || (R = setTimeout(() => {
                        L = !1 === C.leading ? 0 : Date.now(), R = null, m.apply(H, B)
                    }, U))
                }
            }

            function hookSetter(m, _, C, R, L = window) {
                let B = L.Object.getOwnPropertyDescriptor(m, _);
                return L.Object.defineProperty(m, _, R ? C : {
                    set(m) {
                        setTimeout(() => {
                            C.set.call(this, m)
                        }, 0), B && B.set && B.set.call(this, m)
                    }
                }), () => hookSetter(m, _, B || {}, !0)
            }

            function patch(m, _, C) {
                try {
                    if (!(_ in m)) return () => {};
                    let R = m[_],
                        L = C(R);
                    return "function" == typeof L && (L.prototype = L.prototype || {}, Object.defineProperties(L, {
                        __rrweb_original__: {
                            enumerable: !1,
                            value: R
                        }
                    })), m[_] = L, () => {
                        m[_] = R
                    }
                } catch (m) {
                    return () => {}
                }
            }
            "undefined" != typeof window && window.Proxy && window.Reflect && (eo = new Proxy(eo, {
                get: (m, _, C) => ("map" === _ && console.error(ei), Reflect.get(m, _, C))
            }));
            let ea = Date.now;

            function getWindowScroll(m) {
                var _, C, R, L, B, F;
                let U = m.document;
                return {
                    left: U.scrollingElement ? U.scrollingElement.scrollLeft : void 0 !== m.pageXOffset ? m.pageXOffset : (null == U ? void 0 : U.documentElement.scrollLeft) || (null === (C = null === (_ = null == U ? void 0 : U.body) || void 0 === _ ? void 0 : _.parentElement) || void 0 === C ? void 0 : C.scrollLeft) || (null === (R = null == U ? void 0 : U.body) || void 0 === R ? void 0 : R.scrollLeft) || 0,
                    top: U.scrollingElement ? U.scrollingElement.scrollTop : void 0 !== m.pageYOffset ? m.pageYOffset : (null == U ? void 0 : U.documentElement.scrollTop) || (null === (B = null === (L = null == U ? void 0 : U.body) || void 0 === L ? void 0 : L.parentElement) || void 0 === B ? void 0 : B.scrollTop) || (null === (F = null == U ? void 0 : U.body) || void 0 === F ? void 0 : F.scrollTop) || 0
                }
            }

            function getWindowHeight() {
                return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight
            }

            function getWindowWidth() {
                return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth
            }

            function closestElementOfNode(m) {
                if (!m) return null;
                let _ = m.nodeType === m.ELEMENT_NODE ? m : m.parentElement;
                return _
            }

            function isBlocked(m, _, C, R) {
                if (!m) return !1;
                let L = closestElementOfNode(m);
                if (!L) return !1;
                try {
                    if ("string" == typeof _) {
                        if (L.classList.contains(_) || R && null !== L.closest("." + _)) return !0
                    } else if (classMatchesRegex(L, _, R)) return !0
                } catch (m) {}
                return !!(C && (L.matches(C) || R && null !== L.closest(C)))
            }

            function isIgnored(m, _) {
                return -2 === _.getId(m)
            }

            function legacy_isTouchEvent(m) {
                return !!m.changedTouches
            }

            function isSerializedIframe(m, _) {
                return !!("IFRAME" === m.nodeName && _.getMeta(m))
            }

            function isSerializedStylesheet(m, _) {
                return !!("LINK" === m.nodeName && m.nodeType === m.ELEMENT_NODE && m.getAttribute && "stylesheet" === m.getAttribute("rel") && _.getMeta(m))
            }

            function hasShadowRoot(m) {
                return !!(null == m ? void 0 : m.shadowRoot)
            }
            /[1-9][0-9]{12}/.test(Date.now().toString()) || (ea = () => new Date().getTime());
            let StyleSheetMirror = class StyleSheetMirror {
                constructor() {
                    this.id = 1, this.styleIDMap = new WeakMap, this.idStyleMap = new Map
                }
                getId(m) {
                    var _;
                    return null !== (_ = this.styleIDMap.get(m)) && void 0 !== _ ? _ : -1
                }
                has(m) {
                    return this.styleIDMap.has(m)
                }
                add(m, _) {
                    let C;
                    return this.has(m) ? this.getId(m) : (C = void 0 === _ ? this.id++ : _, this.styleIDMap.set(m, C), this.idStyleMap.set(C, m), C)
                }
                getStyle(m) {
                    return this.idStyleMap.get(m) || null
                }
                reset() {
                    this.styleIDMap = new WeakMap, this.idStyleMap = new Map, this.id = 1
                }
                generateId() {
                    return this.id++
                }
            };

            function getShadowHost(m) {
                var _, C;
                let R = null;
                return (null === (C = null === (_ = m.getRootNode) || void 0 === _ ? void 0 : _.call(m)) || void 0 === C ? void 0 : C.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && m.getRootNode().host && (R = m.getRootNode().host), R
            }

            function inDom(m) {
                let _ = m.ownerDocument;
                return !!_ && (_.contains(m) || function(m) {
                    let _ = m.ownerDocument;
                    if (!_) return !1;
                    let C = function(m) {
                        let _, C = m;
                        for (; _ = getShadowHost(C);) C = _;
                        return C
                    }(m);
                    return _.contains(C)
                }(m))
            }
            var es, ec, el, eu, ed, ep, eh, ef, em, eg, ey, e_, ev, eb, eS, ew, eE, ek, ex, eI, eO, eC, eM, eT, eA, eR, eP, eD, eL, eN = ((eA = eN || {})[eA.DomContentLoaded = 0] = "DomContentLoaded", eA[eA.Load = 1] = "Load", eA[eA.FullSnapshot = 2] = "FullSnapshot", eA[eA.IncrementalSnapshot = 3] = "IncrementalSnapshot", eA[eA.Meta = 4] = "Meta", eA[eA.Custom = 5] = "Custom", eA[eA.Plugin = 6] = "Plugin", eA),
                eB = ((es = eB || {})[es.Mutation = 0] = "Mutation", es[es.MouseMove = 1] = "MouseMove", es[es.MouseInteraction = 2] = "MouseInteraction", es[es.Scroll = 3] = "Scroll", es[es.ViewportResize = 4] = "ViewportResize", es[es.Input = 5] = "Input", es[es.TouchMove = 6] = "TouchMove", es[es.MediaInteraction = 7] = "MediaInteraction", es[es.StyleSheetRule = 8] = "StyleSheetRule", es[es.CanvasMutation = 9] = "CanvasMutation", es[es.Font = 10] = "Font", es[es.Log = 11] = "Log", es[es.Drag = 12] = "Drag", es[es.StyleDeclaration = 13] = "StyleDeclaration", es[es.Selection = 14] = "Selection", es[es.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", es[es.CustomElement = 16] = "CustomElement", es),
                ej = ((ec = ej || {})[ec.MouseUp = 0] = "MouseUp", ec[ec.MouseDown = 1] = "MouseDown", ec[ec.Click = 2] = "Click", ec[ec.ContextMenu = 3] = "ContextMenu", ec[ec.DblClick = 4] = "DblClick", ec[ec.Focus = 5] = "Focus", ec[ec.Blur = 6] = "Blur", ec[ec.TouchStart = 7] = "TouchStart", ec[ec.TouchMove_Departed = 8] = "TouchMove_Departed", ec[ec.TouchEnd = 9] = "TouchEnd", ec[ec.TouchCancel = 10] = "TouchCancel", ec),
                eF = ((el = eF || {})[el.Mouse = 0] = "Mouse", el[el.Pen = 1] = "Pen", el[el.Touch = 2] = "Touch", el),
                eU = ((eu = eU || {})[eu["2D"] = 0] = "2D", eu[eu.WebGL = 1] = "WebGL", eu[eu.WebGL2 = 2] = "WebGL2", eu);
            let DoubleLinkedList = class DoubleLinkedList {
                constructor() {
                    this.length = 0, this.head = null, this.tail = null
                }
                get(m) {
                    if (m >= this.length) throw Error("Position outside of list range");
                    let _ = this.head;
                    for (let C = 0; C < m; C++) _ = (null == _ ? void 0 : _.next) || null;
                    return _
                }
                addNode(m) {
                    let _ = {
                        value: m,
                        previous: null,
                        next: null
                    };
                    if (m.__ln = _, m.previousSibling && "__ln" in m.previousSibling) {
                        let C = m.previousSibling.__ln.next;
                        _.next = C, _.previous = m.previousSibling.__ln, m.previousSibling.__ln.next = _, C && (C.previous = _)
                    } else if (m.nextSibling && "__ln" in m.nextSibling && m.nextSibling.__ln.previous) {
                        let C = m.nextSibling.__ln.previous;
                        _.previous = C, _.next = m.nextSibling.__ln, m.nextSibling.__ln.previous = _, C && (C.next = _)
                    } else this.head && (this.head.previous = _), _.next = this.head, this.head = _;
                    null === _.next && (this.tail = _), this.length++
                }
                removeNode(m) {
                    let _ = m.__ln;
                    this.head && (_.previous ? (_.previous.next = _.next, _.next ? _.next.previous = _.previous : this.tail = _.previous) : (this.head = _.next, this.head ? this.head.previous = null : this.tail = null), m.__ln && delete m.__ln, this.length--)
                }
            };
            let moveKey = (m, _) => `${m}@${_}`;
            let MutationBuffer = class MutationBuffer {
                constructor() {
                    this.frozen = !1, this.locked = !1, this.texts = [], this.attributes = [], this.attributeMap = new WeakMap, this.removes = [], this.mapRemoves = [], this.movedMap = {}, this.addedSet = new Set, this.movedSet = new Set, this.droppedSet = new Set, this.processMutations = m => {
                        m.forEach(this.processMutation), this.emit()
                    }, this.emit = () => {
                        if (this.frozen || this.locked) return;
                        let m = [],
                            _ = new Set,
                            C = new DoubleLinkedList,
                            getNextId = m => {
                                let _ = m,
                                    C = -2;
                                for (; - 2 === C;) C = (_ = _ && _.nextSibling) && this.mirror.getId(_);
                                return C
                            },
                            pushAdd = R => {
                                if (!R.parentNode || !inDom(R) || "TEXTAREA" === R.parentNode.tagName) return;
                                let L = isShadowRoot(R.parentNode) ? this.mirror.getId(getShadowHost(R)) : this.mirror.getId(R.parentNode),
                                    B = getNextId(R);
                                if (-1 === L || -1 === B) return C.addNode(R);
                                let F = serializeNodeWithId(R, {
                                    doc: this.doc,
                                    mirror: this.mirror,
                                    blockClass: this.blockClass,
                                    blockSelector: this.blockSelector,
                                    maskTextClass: this.maskTextClass,
                                    maskTextSelector: this.maskTextSelector,
                                    skipChild: !0,
                                    newlyAddedElement: !0,
                                    inlineStylesheet: this.inlineStylesheet,
                                    maskInputOptions: this.maskInputOptions,
                                    maskTextFn: this.maskTextFn,
                                    maskInputFn: this.maskInputFn,
                                    slimDOMOptions: this.slimDOMOptions,
                                    dataURLOptions: this.dataURLOptions,
                                    recordCanvas: this.recordCanvas,
                                    inlineImages: this.inlineImages,
                                    onSerialize: m => {
                                        isSerializedIframe(m, this.mirror) && this.iframeManager.addIframe(m), isSerializedStylesheet(m, this.mirror) && this.stylesheetManager.trackLinkElement(m), hasShadowRoot(R) && this.shadowDomManager.addShadowRoot(R.shadowRoot, this.doc)
                                    },
                                    onIframeLoad: (m, _) => {
                                        this.iframeManager.attachIframe(m, _), this.shadowDomManager.observeAttachShadow(m)
                                    },
                                    onStylesheetLoad: (m, _) => {
                                        this.stylesheetManager.attachLinkElement(m, _)
                                    }
                                });
                                F && (m.push({
                                    parentId: L,
                                    nextId: B,
                                    node: F
                                }), _.add(F.id))
                            };
                        for (; this.mapRemoves.length;) this.mirror.removeNodeFromMap(this.mapRemoves.shift());
                        for (let m of this.movedSet)(!isParentRemoved(this.removes, m, this.mirror) || this.movedSet.has(m.parentNode)) && pushAdd(m);
                        for (let m of this.addedSet) isAncestorInSet(this.droppedSet, m) || isParentRemoved(this.removes, m, this.mirror) ? isAncestorInSet(this.movedSet, m) ? pushAdd(m) : this.droppedSet.add(m) : pushAdd(m);
                        let R = null;
                        for (; C.length;) {
                            let m = null;
                            if (R) {
                                let _ = this.mirror.getId(R.value.parentNode),
                                    C = getNextId(R.value); - 1 !== _ && -1 !== C && (m = R)
                            }
                            if (!m) {
                                let _ = C.tail;
                                for (; _;) {
                                    let C = _;
                                    if (_ = _.previous, C) {
                                        let _ = this.mirror.getId(C.value.parentNode),
                                            R = getNextId(C.value);
                                        if (-1 === R) continue;
                                        if (-1 !== _) {
                                            m = C;
                                            break
                                        } {
                                            let _ = C.value;
                                            if (_.parentNode && _.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                                                let R = _.parentNode.host,
                                                    L = this.mirror.getId(R);
                                                if (-1 !== L) {
                                                    m = C;
                                                    break
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (!m) {
                                for (; C.head;) C.removeNode(C.head.value);
                                break
                            }
                            R = m.previous, C.removeNode(m.value), pushAdd(m.value)
                        }
                        let L = {
                            texts: this.texts.map(m => {
                                let _ = m.node;
                                return _.parentNode && "TEXTAREA" === _.parentNode.tagName && this.genTextAreaValueMutation(_.parentNode), {
                                    id: this.mirror.getId(_),
                                    value: m.value
                                }
                            }).filter(m => !_.has(m.id)).filter(m => this.mirror.has(m.id)),
                            attributes: this.attributes.map(m => {
                                let {
                                    attributes: _
                                } = m;
                                if ("string" == typeof _.style) {
                                    let C = JSON.stringify(m.styleDiff),
                                        R = JSON.stringify(m._unchangedStyles);
                                    C.length < _.style.length && (C + R).split("var(").length === _.style.split("var(").length && (_.style = m.styleDiff)
                                }
                                return {
                                    id: this.mirror.getId(m.node),
                                    attributes: _
                                }
                            }).filter(m => !_.has(m.id)).filter(m => this.mirror.has(m.id)),
                            removes: this.removes,
                            adds: m
                        };
                        (L.texts.length || L.attributes.length || L.removes.length || L.adds.length) && (this.texts = [], this.attributes = [], this.attributeMap = new WeakMap, this.removes = [], this.addedSet = new Set, this.movedSet = new Set, this.droppedSet = new Set, this.movedMap = {}, this.mutationCb(L))
                    }, this.genTextAreaValueMutation = m => {
                        let _ = this.attributeMap.get(m);
                        _ || (_ = {
                            node: m,
                            attributes: {},
                            styleDiff: {},
                            _unchangedStyles: {}
                        }, this.attributes.push(_), this.attributeMap.set(m, _)), _.attributes.value = Array.from(m.childNodes, m => m.textContent || "").join("")
                    }, this.processMutation = m => {
                        if (!isIgnored(m.target, this.mirror)) switch (m.type) {
                            case "characterData":
                                {
                                    let _ = m.target.textContent;isBlocked(m.target, this.blockClass, this.blockSelector, !1) || _ === m.oldValue || this.texts.push({
                                        value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, !0) && _ ? this.maskTextFn ? this.maskTextFn(_, closestElementOfNode(m.target)) : _.replace(/[\S]/g, "*") : _,
                                        node: m.target
                                    });
                                    break
                                }
                            case "attributes":
                                {
                                    let _ = m.target,
                                        C = m.attributeName,
                                        R = m.target.getAttribute(C);
                                    if ("value" === C) {
                                        let m = getInputType(_);
                                        R = maskInputValue({
                                            element: _,
                                            maskInputOptions: this.maskInputOptions,
                                            tagName: _.tagName,
                                            type: m,
                                            value: R,
                                            maskInputFn: this.maskInputFn
                                        })
                                    }
                                    if (isBlocked(m.target, this.blockClass, this.blockSelector, !1) || R === m.oldValue) return;
                                    let L = this.attributeMap.get(m.target);
                                    if ("IFRAME" === _.tagName && "src" === C && !this.keepIframeSrcFn(R)) {
                                        if (_.contentDocument) return;
                                        C = "rr_src"
                                    }
                                    if (L || (L = {
                                            node: m.target,
                                            attributes: {},
                                            styleDiff: {},
                                            _unchangedStyles: {}
                                        }, this.attributes.push(L), this.attributeMap.set(m.target, L)), "type" === C && "INPUT" === _.tagName && "password" === (m.oldValue || "").toLowerCase() && _.setAttribute("data-rr-is-password", "true"), !ignoreAttribute(_.tagName, C) && (L.attributes[C] = transformAttribute(this.doc, toLowerCase(_.tagName), toLowerCase(C), R), "style" === C)) {
                                        if (!this.unattachedDoc) try {
                                            this.unattachedDoc = document.implementation.createHTMLDocument()
                                        } catch (m) {
                                            this.unattachedDoc = this.doc
                                        }
                                        let C = this.unattachedDoc.createElement("span");
                                        for (let R of (m.oldValue && C.setAttribute("style", m.oldValue), Array.from(_.style))) {
                                            let m = _.style.getPropertyValue(R),
                                                B = _.style.getPropertyPriority(R);
                                            m !== C.style.getPropertyValue(R) || B !== C.style.getPropertyPriority(R) ? "" === B ? L.styleDiff[R] = m : L.styleDiff[R] = [m, B] : L._unchangedStyles[R] = [m, B]
                                        }
                                        for (let m of Array.from(C.style)) "" === _.style.getPropertyValue(m) && (L.styleDiff[m] = !1)
                                    }
                                    break
                                }
                            case "childList":
                                if (isBlocked(m.target, this.blockClass, this.blockSelector, !0)) return;
                                if ("TEXTAREA" === m.target.tagName) {
                                    this.genTextAreaValueMutation(m.target);
                                    return
                                }
                                m.addedNodes.forEach(_ => this.genAdds(_, m.target)), m.removedNodes.forEach(_ => {
                                    let C = this.mirror.getId(_),
                                        R = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);
                                    isBlocked(m.target, this.blockClass, this.blockSelector, !1) || isIgnored(_, this.mirror) || -1 === this.mirror.getId(_) || (this.addedSet.has(_) ? (deepDelete(this.addedSet, _), this.droppedSet.add(_)) : this.addedSet.has(m.target) && -1 === C || function isAncestorRemoved(m, _) {
                                        if (isShadowRoot(m)) return !1;
                                        let C = _.getId(m);
                                        return !_.has(C) || (!m.parentNode || m.parentNode.nodeType !== m.DOCUMENT_NODE) && (!m.parentNode || isAncestorRemoved(m.parentNode, _))
                                    }(m.target, this.mirror) || (this.movedSet.has(_) && this.movedMap[moveKey(C, R)] ? deepDelete(this.movedSet, _) : this.removes.push({
                                        parentId: R,
                                        id: C,
                                        isShadow: !!(isShadowRoot(m.target) && isNativeShadowDom(m.target)) || void 0
                                    })), this.mapRemoves.push(_))
                                })
                        }
                    }, this.genAdds = (m, _) => {
                        if (!this.processedNodeManager.inOtherBuffer(m, this) && !(this.addedSet.has(m) || this.movedSet.has(m))) {
                            if (this.mirror.hasNode(m)) {
                                if (isIgnored(m, this.mirror)) return;
                                this.movedSet.add(m);
                                let C = null;
                                _ && this.mirror.hasNode(_) && (C = this.mirror.getId(_)), C && -1 !== C && (this.movedMap[moveKey(this.mirror.getId(m), C)] = !0)
                            } else this.addedSet.add(m), this.droppedSet.delete(m);
                            !isBlocked(m, this.blockClass, this.blockSelector, !1) && (m.childNodes.forEach(m => this.genAdds(m)), hasShadowRoot(m) && m.shadowRoot.childNodes.forEach(_ => {
                                this.processedNodeManager.add(_, this), this.genAdds(_, m)
                            }))
                        }
                    }
                }
                init(m) {
                    ["mutationCb", "blockClass", "blockSelector", "maskTextClass", "maskTextSelector", "inlineStylesheet", "maskInputOptions", "maskTextFn", "maskInputFn", "keepIframeSrcFn", "recordCanvas", "inlineImages", "slimDOMOptions", "dataURLOptions", "doc", "mirror", "iframeManager", "stylesheetManager", "shadowDomManager", "canvasManager", "processedNodeManager"].forEach(_ => {
                        this[_] = m[_]
                    })
                }
                freeze() {
                    this.frozen = !0, this.canvasManager.freeze()
                }
                unfreeze() {
                    this.frozen = !1, this.canvasManager.unfreeze(), this.emit()
                }
                isFrozen() {
                    return this.frozen
                }
                lock() {
                    this.locked = !0, this.canvasManager.lock()
                }
                unlock() {
                    this.locked = !1, this.canvasManager.unlock(), this.emit()
                }
                reset() {
                    this.shadowDomManager.reset(), this.canvasManager.reset()
                }
            };

            function deepDelete(m, _) {
                m.delete(_), _.childNodes.forEach(_ => deepDelete(m, _))
            }

            function isParentRemoved(m, _, C) {
                return 0 !== m.length && function _isParentRemoved(m, _, C) {
                    let {
                        parentNode: R
                    } = _;
                    if (!R) return !1;
                    let L = C.getId(R);
                    return !!m.some(m => m.id === L) || _isParentRemoved(m, R, C)
                }(m, _, C)
            }

            function isAncestorInSet(m, _) {
                return 0 !== m.size && function _isAncestorInSet(m, _) {
                    let {
                        parentNode: C
                    } = _;
                    return !!C && (!!m.has(C) || _isAncestorInSet(m, C))
                }(m, _)
            }
            let callbackWrapper = m => B ? (..._) => {
                    try {
                        return m(..._)
                    } catch (m) {
                        if (B && !0 === B(m)) return;
                        throw m
                    }
                } : m,
                eH = [];

            function getEventTarget(m) {
                try {
                    if ("composedPath" in m) {
                        let _ = m.composedPath();
                        if (_.length) return _[0]
                    } else if ("path" in m && m.path.length) return m.path[0]
                } catch (m) {}
                return m && m.target
            }

            function initMutationObserver(m, _) {
                var C, R;
                let L = new MutationBuffer;
                eH.push(L), L.init(m);
                let B = window.MutationObserver || window.__rrMutationObserver,
                    F = null === (R = null === (C = null == window ? void 0 : window.Zone) || void 0 === C ? void 0 : C.__symbol__) || void 0 === R ? void 0 : R.call(C, "MutationObserver");
                F && window[F] && (B = window[F]);
                let U = new B(callbackWrapper(L.processMutations.bind(L)));
                return U.observe(_, {
                    attributes: !0,
                    attributeOldValue: !0,
                    characterData: !0,
                    characterDataOldValue: !0,
                    childList: !0,
                    subtree: !0
                }), U
            }

            function initScrollObserver({
                scrollCb: m,
                doc: _,
                mirror: C,
                blockClass: R,
                blockSelector: L,
                sampling: B
            }) {
                let F = callbackWrapper(throttle(callbackWrapper(B => {
                    let F = getEventTarget(B);
                    if (!F || isBlocked(F, R, L, !0)) return;
                    let U = C.getId(F);
                    if (F === _ && _.defaultView) {
                        let C = getWindowScroll(_.defaultView);
                        m({
                            id: U,
                            x: C.left,
                            y: C.top
                        })
                    } else m({
                        id: U,
                        x: F.scrollLeft,
                        y: F.scrollTop
                    })
                }), B.scroll || 100));
                return on("scroll", F, _)
            }
            let eW = ["INPUT", "TEXTAREA", "SELECT"],
                e$ = new WeakMap;

            function getNestedCSSRulePositions(m) {
                return function(m, _) {
                    if (hasNestedCSSRule("CSSGroupingRule") && m.parentRule instanceof CSSGroupingRule || hasNestedCSSRule("CSSMediaRule") && m.parentRule instanceof CSSMediaRule || hasNestedCSSRule("CSSSupportsRule") && m.parentRule instanceof CSSSupportsRule || hasNestedCSSRule("CSSConditionRule") && m.parentRule instanceof CSSConditionRule) {
                        let C = Array.from(m.parentRule.cssRules),
                            R = C.indexOf(m);
                        _.unshift(R)
                    } else if (m.parentStyleSheet) {
                        let C = Array.from(m.parentStyleSheet.cssRules),
                            R = C.indexOf(m);
                        _.unshift(R)
                    }
                    return _
                }(m, [])
            }

            function getIdAndStyleId(m, _, C) {
                let R, L;
                return m ? (m.ownerNode ? R = _.getId(m.ownerNode) : L = C.getId(m), {
                    styleId: L,
                    id: R
                }) : {}
            }

            function initAdoptedStyleSheetObserver({
                mirror: m,
                stylesheetManager: _
            }, C) {
                var R, L, B;
                let F = null;
                F = "#document" === C.nodeName ? m.getId(C) : m.getId(C.host);
                let U = "#document" === C.nodeName ? null === (R = C.defaultView) || void 0 === R ? void 0 : R.Document : null === (B = null === (L = C.ownerDocument) || void 0 === L ? void 0 : L.defaultView) || void 0 === B ? void 0 : B.ShadowRoot,
                    H = (null == U ? void 0 : U.prototype) ? Object.getOwnPropertyDescriptor(null == U ? void 0 : U.prototype, "adoptedStyleSheets") : void 0;
                return null !== F && -1 !== F && U && H ? (Object.defineProperty(C, "adoptedStyleSheets", {
                    configurable: H.configurable,
                    enumerable: H.enumerable,
                    get() {
                        var m;
                        return null === (m = H.get) || void 0 === m ? void 0 : m.call(this)
                    },
                    set(m) {
                        var C;
                        let R = null === (C = H.set) || void 0 === C ? void 0 : C.call(this, m);
                        if (null !== F && -1 !== F) try {
                            _.adoptStyleSheets(m, F)
                        } catch (m) {}
                        return R
                    }
                }), callbackWrapper(() => {
                    Object.defineProperty(C, "adoptedStyleSheets", {
                        configurable: H.configurable,
                        enumerable: H.enumerable,
                        get: H.get,
                        set: H.set
                    })
                })) : () => {}
            }

            function initObservers(m, _ = {}) {
                let C;
                let R = m.doc.defaultView;
                if (!R) return () => {};
                (function(m, _) {
                    let {
                        mutationCb: C,
                        mousemoveCb: R,
                        mouseInteractionCb: L,
                        scrollCb: B,
                        viewportResizeCb: F,
                        inputCb: U,
                        mediaInteractionCb: H,
                        styleSheetRuleCb: q,
                        styleDeclarationCb: V,
                        canvasMutationCb: X,
                        fontCb: K,
                        selectionCb: Y,
                        customElementCb: Q
                    } = m;
                    m.mutationCb = (...m) => {
                        _.mutation && _.mutation(...m), C(...m)
                    }, m.mousemoveCb = (...m) => {
                        _.mousemove && _.mousemove(...m), R(...m)
                    }, m.mouseInteractionCb = (...m) => {
                        _.mouseInteraction && _.mouseInteraction(...m), L(...m)
                    }, m.scrollCb = (...m) => {
                        _.scroll && _.scroll(...m), B(...m)
                    }, m.viewportResizeCb = (...m) => {
                        _.viewportResize && _.viewportResize(...m), F(...m)
                    }, m.inputCb = (...m) => {
                        _.input && _.input(...m), U(...m)
                    }, m.mediaInteractionCb = (...m) => {
                        _.mediaInteaction && _.mediaInteaction(...m), H(...m)
                    }, m.styleSheetRuleCb = (...m) => {
                        _.styleSheetRule && _.styleSheetRule(...m), q(...m)
                    }, m.styleDeclarationCb = (...m) => {
                        _.styleDeclaration && _.styleDeclaration(...m), V(...m)
                    }, m.canvasMutationCb = (...m) => {
                        _.canvasMutation && _.canvasMutation(...m), X(...m)
                    }, m.fontCb = (...m) => {
                        _.font && _.font(...m), K(...m)
                    }, m.selectionCb = (...m) => {
                        _.selection && _.selection(...m), Y(...m)
                    }, m.customElementCb = (...m) => {
                        _.customElement && _.customElement(...m), Q(...m)
                    }
                })(m, _), m.recordDOM && (C = initMutationObserver(m, m.doc));
                let L = function({
                        mousemoveCb: m,
                        sampling: _,
                        doc: C,
                        mirror: R
                    }) {
                        let L;
                        if (!1 === _.mousemove) return () => {};
                        let B = "number" == typeof _.mousemove ? _.mousemove : 50,
                            F = "number" == typeof _.mousemoveCallback ? _.mousemoveCallback : 500,
                            U = [],
                            H = throttle(callbackWrapper(_ => {
                                let C = Date.now() - L;
                                m(U.map(m => (m.timeOffset -= C, m)), _), U = [], L = null
                            }), F),
                            q = callbackWrapper(throttle(callbackWrapper(m => {
                                let _ = getEventTarget(m),
                                    {
                                        clientX: C,
                                        clientY: B
                                    } = legacy_isTouchEvent(m) ? m.changedTouches[0] : m;
                                L || (L = ea()), U.push({
                                    x: C,
                                    y: B,
                                    id: R.getId(_),
                                    timeOffset: ea() - L
                                }), H("undefined" != typeof DragEvent && m instanceof DragEvent ? eB.Drag : m instanceof MouseEvent ? eB.MouseMove : eB.TouchMove)
                            }), B, {
                                trailing: !1
                            })),
                            V = [on("mousemove", q, C), on("touchmove", q, C), on("drag", q, C)];
                        return callbackWrapper(() => {
                            V.forEach(m => m())
                        })
                    }(m),
                    B = function({
                        mouseInteractionCb: m,
                        doc: _,
                        mirror: C,
                        blockClass: R,
                        blockSelector: L,
                        sampling: B
                    }) {
                        if (!1 === B.mouseInteraction) return () => {};
                        let F = !0 === B.mouseInteraction || void 0 === B.mouseInteraction ? {} : B.mouseInteraction,
                            U = [],
                            H = null,
                            getHandler = _ => B => {
                                let F = getEventTarget(B);
                                if (isBlocked(F, R, L, !0)) return;
                                let U = null,
                                    q = _;
                                if ("pointerType" in B) {
                                    switch (B.pointerType) {
                                        case "mouse":
                                            U = eF.Mouse;
                                            break;
                                        case "touch":
                                            U = eF.Touch;
                                            break;
                                        case "pen":
                                            U = eF.Pen
                                    }
                                    U === eF.Touch ? ej[_] === ej.MouseDown ? q = "TouchStart" : ej[_] === ej.MouseUp && (q = "TouchEnd") : eF.Pen
                                } else legacy_isTouchEvent(B) && (U = eF.Touch);
                                null !== U ? (H = U, (q.startsWith("Touch") && U === eF.Touch || q.startsWith("Mouse") && U === eF.Mouse) && (U = null)) : ej[_] === ej.Click && (U = H, H = null);
                                let V = legacy_isTouchEvent(B) ? B.changedTouches[0] : B;
                                if (!V) return;
                                let X = C.getId(F),
                                    {
                                        clientX: K,
                                        clientY: Y
                                    } = V;
                                callbackWrapper(m)(Object.assign({
                                    type: ej[q],
                                    id: X,
                                    x: K,
                                    y: Y
                                }, null !== U && {
                                    pointerType: U
                                }))
                            };
                        return Object.keys(ej).filter(m => Number.isNaN(Number(m)) && !m.endsWith("_Departed") && !1 !== F[m]).forEach(m => {
                            let C = toLowerCase(m),
                                R = getHandler(m);
                            if (window.PointerEvent) switch (ej[m]) {
                                case ej.MouseDown:
                                case ej.MouseUp:
                                    C = C.replace("mouse", "pointer");
                                    break;
                                case ej.TouchStart:
                                case ej.TouchEnd:
                                    return
                            }
                            U.push(on(C, R, _))
                        }), callbackWrapper(() => {
                            U.forEach(m => m())
                        })
                    }(m),
                    F = initScrollObserver(m),
                    U = function({
                        viewportResizeCb: m
                    }, {
                        win: _
                    }) {
                        let C = -1,
                            R = -1,
                            L = callbackWrapper(throttle(callbackWrapper(() => {
                                let _ = getWindowHeight(),
                                    L = getWindowWidth();
                                (C !== _ || R !== L) && (m({
                                    width: Number(L),
                                    height: Number(_)
                                }), C = _, R = L)
                            }), 200));
                        return on("resize", L, _)
                    }(m, {
                        win: R
                    }),
                    H = function({
                        inputCb: m,
                        doc: _,
                        mirror: C,
                        blockClass: R,
                        blockSelector: L,
                        ignoreClass: B,
                        ignoreSelector: F,
                        maskInputOptions: U,
                        maskInputFn: H,
                        sampling: q,
                        userTriggeredOnInput: V
                    }) {
                        function eventHandler(m) {
                            let C = getEventTarget(m),
                                q = m.isTrusted,
                                X = C && C.tagName;
                            if (C && "OPTION" === X && (C = C.parentElement), !C || !X || 0 > eW.indexOf(X) || isBlocked(C, R, L, !0) || C.classList.contains(B) || F && C.matches(F)) return;
                            let K = C.value,
                                Y = !1,
                                Q = getInputType(C) || "";
                            "radio" === Q || "checkbox" === Q ? Y = C.checked : (U[X.toLowerCase()] || U[Q]) && (K = maskInputValue({
                                element: C,
                                maskInputOptions: U,
                                tagName: X,
                                type: Q,
                                value: K,
                                maskInputFn: H
                            })), cbWithDedup(C, V ? {
                                text: K,
                                isChecked: Y,
                                userTriggered: q
                            } : {
                                text: K,
                                isChecked: Y
                            });
                            let et = C.name;
                            "radio" === Q && et && Y && _.querySelectorAll(`input[type="radio"][name="${et}"]`).forEach(m => {
                                if (m !== C) {
                                    let _ = m.value;
                                    cbWithDedup(m, V ? {
                                        text: _,
                                        isChecked: !Y,
                                        userTriggered: !1
                                    } : {
                                        text: _,
                                        isChecked: !Y
                                    })
                                }
                            })
                        }

                        function cbWithDedup(_, R) {
                            let L = e$.get(_);
                            if (!L || L.text !== R.text || L.isChecked !== R.isChecked) {
                                e$.set(_, R);
                                let L = C.getId(_);
                                callbackWrapper(m)(Object.assign(Object.assign({}, R), {
                                    id: L
                                }))
                            }
                        }
                        let X = "last" === q.input ? ["change"] : ["input", "change"],
                            K = X.map(m => on(m, callbackWrapper(eventHandler), _)),
                            Y = _.defaultView;
                        if (!Y) return () => {
                            K.forEach(m => m())
                        };
                        let Q = Y.Object.getOwnPropertyDescriptor(Y.HTMLInputElement.prototype, "value"),
                            et = [
                                [Y.HTMLInputElement.prototype, "value"],
                                [Y.HTMLInputElement.prototype, "checked"],
                                [Y.HTMLSelectElement.prototype, "value"],
                                [Y.HTMLTextAreaElement.prototype, "value"],
                                [Y.HTMLSelectElement.prototype, "selectedIndex"],
                                [Y.HTMLOptionElement.prototype, "selected"]
                            ];
                        return Q && Q.set && K.push(...et.map(m => hookSetter(m[0], m[1], {
                            set() {
                                callbackWrapper(eventHandler)({
                                    target: this,
                                    isTrusted: !1
                                })
                            }
                        }, !1, Y))), callbackWrapper(() => {
                            K.forEach(m => m())
                        })
                    }(m),
                    q = function({
                        mediaInteractionCb: m,
                        blockClass: _,
                        blockSelector: C,
                        mirror: R,
                        sampling: L,
                        doc: B
                    }) {
                        let F = callbackWrapper(B => throttle(callbackWrapper(L => {
                                let F = getEventTarget(L);
                                if (!F || isBlocked(F, _, C, !0)) return;
                                let {
                                    currentTime: U,
                                    volume: H,
                                    muted: q,
                                    playbackRate: V,
                                    loop: X
                                } = F;
                                m({
                                    type: B,
                                    id: R.getId(F),
                                    currentTime: U,
                                    volume: H,
                                    muted: q,
                                    playbackRate: V,
                                    loop: X
                                })
                            }), L.media || 500)),
                            U = [on("play", F(0), B), on("pause", F(1), B), on("seeked", F(2), B), on("volumechange", F(3), B), on("ratechange", F(4), B)];
                        return callbackWrapper(() => {
                            U.forEach(m => m())
                        })
                    }(m),
                    styleSheetObserver = () => {},
                    adoptedStyleSheetObserver = () => {},
                    styleDeclarationObserver = () => {},
                    fontObserver = () => {};
                m.recordDOM && (styleSheetObserver = function({
                    styleSheetRuleCb: m,
                    mirror: _,
                    stylesheetManager: C
                }, {
                    win: R
                }) {
                    let L, B;
                    if (!R.CSSStyleSheet || !R.CSSStyleSheet.prototype) return () => {};
                    let F = R.CSSStyleSheet.prototype.insertRule;
                    R.CSSStyleSheet.prototype.insertRule = new Proxy(F, {
                        apply: callbackWrapper((R, L, B) => {
                            let [F, U] = B, {
                                id: H,
                                styleId: q
                            } = getIdAndStyleId(L, _, C.styleMirror);
                            return (H && -1 !== H || q && -1 !== q) && m({
                                id: H,
                                styleId: q,
                                adds: [{
                                    rule: F,
                                    index: U
                                }]
                            }), R.apply(L, B)
                        })
                    });
                    let U = R.CSSStyleSheet.prototype.deleteRule;
                    R.CSSStyleSheet.prototype.deleteRule = new Proxy(U, {
                        apply: callbackWrapper((R, L, B) => {
                            let [F] = B, {
                                id: U,
                                styleId: H
                            } = getIdAndStyleId(L, _, C.styleMirror);
                            return (U && -1 !== U || H && -1 !== H) && m({
                                id: U,
                                styleId: H,
                                removes: [{
                                    index: F
                                }]
                            }), R.apply(L, B)
                        })
                    }), R.CSSStyleSheet.prototype.replace && (L = R.CSSStyleSheet.prototype.replace, R.CSSStyleSheet.prototype.replace = new Proxy(L, {
                        apply: callbackWrapper((R, L, B) => {
                            let [F] = B, {
                                id: U,
                                styleId: H
                            } = getIdAndStyleId(L, _, C.styleMirror);
                            return (U && -1 !== U || H && -1 !== H) && m({
                                id: U,
                                styleId: H,
                                replace: F
                            }), R.apply(L, B)
                        })
                    })), R.CSSStyleSheet.prototype.replaceSync && (B = R.CSSStyleSheet.prototype.replaceSync, R.CSSStyleSheet.prototype.replaceSync = new Proxy(B, {
                        apply: callbackWrapper((R, L, B) => {
                            let [F] = B, {
                                id: U,
                                styleId: H
                            } = getIdAndStyleId(L, _, C.styleMirror);
                            return (U && -1 !== U || H && -1 !== H) && m({
                                id: U,
                                styleId: H,
                                replaceSync: F
                            }), R.apply(L, B)
                        })
                    }));
                    let H = {};
                    canMonkeyPatchNestedCSSRule("CSSGroupingRule") ? H.CSSGroupingRule = R.CSSGroupingRule : (canMonkeyPatchNestedCSSRule("CSSMediaRule") && (H.CSSMediaRule = R.CSSMediaRule), canMonkeyPatchNestedCSSRule("CSSConditionRule") && (H.CSSConditionRule = R.CSSConditionRule), canMonkeyPatchNestedCSSRule("CSSSupportsRule") && (H.CSSSupportsRule = R.CSSSupportsRule));
                    let q = {};
                    return Object.entries(H).forEach(([R, L]) => {
                        q[R] = {
                            insertRule: L.prototype.insertRule,
                            deleteRule: L.prototype.deleteRule
                        }, L.prototype.insertRule = new Proxy(q[R].insertRule, {
                            apply: callbackWrapper((R, L, B) => {
                                let [F, U] = B, {
                                    id: H,
                                    styleId: q
                                } = getIdAndStyleId(L.parentStyleSheet, _, C.styleMirror);
                                return (H && -1 !== H || q && -1 !== q) && m({
                                    id: H,
                                    styleId: q,
                                    adds: [{
                                        rule: F,
                                        index: [...getNestedCSSRulePositions(L), U || 0]
                                    }]
                                }), R.apply(L, B)
                            })
                        }), L.prototype.deleteRule = new Proxy(q[R].deleteRule, {
                            apply: callbackWrapper((R, L, B) => {
                                let [F] = B, {
                                    id: U,
                                    styleId: H
                                } = getIdAndStyleId(L.parentStyleSheet, _, C.styleMirror);
                                return (U && -1 !== U || H && -1 !== H) && m({
                                    id: U,
                                    styleId: H,
                                    removes: [{
                                        index: [...getNestedCSSRulePositions(L), F]
                                    }]
                                }), R.apply(L, B)
                            })
                        })
                    }), callbackWrapper(() => {
                        R.CSSStyleSheet.prototype.insertRule = F, R.CSSStyleSheet.prototype.deleteRule = U, L && (R.CSSStyleSheet.prototype.replace = L), B && (R.CSSStyleSheet.prototype.replaceSync = B), Object.entries(H).forEach(([m, _]) => {
                            _.prototype.insertRule = q[m].insertRule, _.prototype.deleteRule = q[m].deleteRule
                        })
                    })
                }(m, {
                    win: R
                }), adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(m, m.doc), styleDeclarationObserver = function({
                    styleDeclarationCb: m,
                    mirror: _,
                    ignoreCSSAttributes: C,
                    stylesheetManager: R
                }, {
                    win: L
                }) {
                    let B = L.CSSStyleDeclaration.prototype.setProperty;
                    L.CSSStyleDeclaration.prototype.setProperty = new Proxy(B, {
                        apply: callbackWrapper((L, F, U) => {
                            var H;
                            let [q, V, X] = U;
                            if (C.has(q)) return B.apply(F, [q, V, X]);
                            let {
                                id: K,
                                styleId: Y
                            } = getIdAndStyleId(null === (H = F.parentRule) || void 0 === H ? void 0 : H.parentStyleSheet, _, R.styleMirror);
                            return (K && -1 !== K || Y && -1 !== Y) && m({
                                id: K,
                                styleId: Y,
                                set: {
                                    property: q,
                                    value: V,
                                    priority: X
                                },
                                index: getNestedCSSRulePositions(F.parentRule)
                            }), L.apply(F, U)
                        })
                    });
                    let F = L.CSSStyleDeclaration.prototype.removeProperty;
                    return L.CSSStyleDeclaration.prototype.removeProperty = new Proxy(F, {
                        apply: callbackWrapper((L, B, U) => {
                            var H;
                            let [q] = U;
                            if (C.has(q)) return F.apply(B, [q]);
                            let {
                                id: V,
                                styleId: X
                            } = getIdAndStyleId(null === (H = B.parentRule) || void 0 === H ? void 0 : H.parentStyleSheet, _, R.styleMirror);
                            return (V && -1 !== V || X && -1 !== X) && m({
                                id: V,
                                styleId: X,
                                remove: {
                                    property: q
                                },
                                index: getNestedCSSRulePositions(B.parentRule)
                            }), L.apply(B, U)
                        })
                    }), callbackWrapper(() => {
                        L.CSSStyleDeclaration.prototype.setProperty = B, L.CSSStyleDeclaration.prototype.removeProperty = F
                    })
                }(m, {
                    win: R
                }), m.collectFonts && (fontObserver = function({
                    fontCb: m,
                    doc: _
                }) {
                    let C = _.defaultView;
                    if (!C) return () => {};
                    let R = [],
                        L = new WeakMap,
                        B = C.FontFace;
                    C.FontFace = function(m, _, C) {
                        let R = new B(m, _, C);
                        return L.set(R, {
                            family: m,
                            buffer: "string" != typeof _,
                            descriptors: C,
                            fontSource: "string" == typeof _ ? _ : JSON.stringify(Array.from(new Uint8Array(_)))
                        }), R
                    };
                    let F = patch(_.fonts, "add", function(_) {
                        return function(C) {
                            return setTimeout(callbackWrapper(() => {
                                let _ = L.get(C);
                                _ && (m(_), L.delete(C))
                            }), 0), _.apply(this, [C])
                        }
                    });
                    return R.push(() => {
                        C.FontFace = B
                    }), R.push(F), callbackWrapper(() => {
                        R.forEach(m => m())
                    })
                }(m)));
                let V = function(m) {
                        let {
                            doc: _,
                            mirror: C,
                            blockClass: R,
                            blockSelector: L,
                            selectionCb: B
                        } = m, F = !0, U = callbackWrapper(() => {
                            let m = _.getSelection();
                            if (!m || F && (null == m ? void 0 : m.isCollapsed)) return;
                            F = m.isCollapsed || !1;
                            let U = [],
                                H = m.rangeCount || 0;
                            for (let _ = 0; _ < H; _++) {
                                let B = m.getRangeAt(_),
                                    {
                                        startContainer: F,
                                        startOffset: H,
                                        endContainer: q,
                                        endOffset: V
                                    } = B,
                                    X = isBlocked(F, R, L, !0) || isBlocked(q, R, L, !0);
                                X || U.push({
                                    start: C.getId(F),
                                    startOffset: H,
                                    end: C.getId(q),
                                    endOffset: V
                                })
                            }
                            B({
                                ranges: U
                            })
                        });
                        return U(), on("selectionchange", U)
                    }(m),
                    X = function({
                        doc: m,
                        customElementCb: _
                    }) {
                        let C = m.defaultView;
                        if (!C || !C.customElements) return () => {};
                        let R = patch(C.customElements, "define", function(m) {
                            return function(C, R, L) {
                                try {
                                    _({
                                        define: {
                                            name: C
                                        }
                                    })
                                } catch (m) {
                                    console.warn(`Custom element callback failed for ${C}`)
                                }
                                return m.apply(this, [C, R, L])
                            }
                        });
                        return R
                    }(m),
                    K = [];
                for (let _ of m.plugins) K.push(_.observer(_.callback, R, _.options));
                return callbackWrapper(() => {
                    eH.forEach(m => m.reset()), null == C || C.disconnect(), L(), B(), F(), U(), H(), q(), styleSheetObserver(), adoptedStyleSheetObserver(), styleDeclarationObserver(), fontObserver(), V(), X(), K.forEach(m => m())
                })
            }

            function hasNestedCSSRule(m) {
                return void 0 !== window[m]
            }

            function canMonkeyPatchNestedCSSRule(m) {
                return !!(void 0 !== window[m] && window[m].prototype && "insertRule" in window[m].prototype && "deleteRule" in window[m].prototype)
            }
            let CrossOriginIframeMirror = class CrossOriginIframeMirror {
                constructor(m) {
                    this.generateIdFn = m, this.iframeIdToRemoteIdMap = new WeakMap, this.iframeRemoteIdToIdMap = new WeakMap
                }
                getId(m, _, C, R) {
                    let L = C || this.getIdToRemoteIdMap(m),
                        B = R || this.getRemoteIdToIdMap(m),
                        F = L.get(_);
                    return F || (F = this.generateIdFn(), L.set(_, F), B.set(F, _)), F
                }
                getIds(m, _) {
                    let C = this.getIdToRemoteIdMap(m),
                        R = this.getRemoteIdToIdMap(m);
                    return _.map(_ => this.getId(m, _, C, R))
                }
                getRemoteId(m, _, C) {
                    let R = C || this.getRemoteIdToIdMap(m);
                    if ("number" != typeof _) return _;
                    let L = R.get(_);
                    return L || -1
                }
                getRemoteIds(m, _) {
                    let C = this.getRemoteIdToIdMap(m);
                    return _.map(_ => this.getRemoteId(m, _, C))
                }
                reset(m) {
                    if (!m) {
                        this.iframeIdToRemoteIdMap = new WeakMap, this.iframeRemoteIdToIdMap = new WeakMap;
                        return
                    }
                    this.iframeIdToRemoteIdMap.delete(m), this.iframeRemoteIdToIdMap.delete(m)
                }
                getIdToRemoteIdMap(m) {
                    let _ = this.iframeIdToRemoteIdMap.get(m);
                    return _ || (_ = new Map, this.iframeIdToRemoteIdMap.set(m, _)), _
                }
                getRemoteIdToIdMap(m) {
                    let _ = this.iframeRemoteIdToIdMap.get(m);
                    return _ || (_ = new Map, this.iframeRemoteIdToIdMap.set(m, _)), _
                }
            };
            let IframeManager = class IframeManager {
                constructor(m) {
                    this.iframes = new WeakMap, this.crossOriginIframeMap = new WeakMap, this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId), this.crossOriginIframeRootIdMap = new WeakMap, this.mutationCb = m.mutationCb, this.wrappedEmit = m.wrappedEmit, this.stylesheetManager = m.stylesheetManager, this.recordCrossOriginIframes = m.recordCrossOriginIframes, this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror)), this.mirror = m.mirror, this.recordCrossOriginIframes && window.addEventListener("message", this.handleMessage.bind(this))
                }
                addIframe(m) {
                    this.iframes.set(m, !0), m.contentWindow && this.crossOriginIframeMap.set(m.contentWindow, m)
                }
                addLoadListener(m) {
                    this.loadListener = m
                }
                attachIframe(m, _) {
                    var C;
                    this.mutationCb({
                        adds: [{
                            parentId: this.mirror.getId(m),
                            nextId: null,
                            node: _
                        }],
                        removes: [],
                        texts: [],
                        attributes: [],
                        isAttachIframe: !0
                    }), null === (C = this.loadListener) || void 0 === C || C.call(this, m), m.contentDocument && m.contentDocument.adoptedStyleSheets && m.contentDocument.adoptedStyleSheets.length > 0 && this.stylesheetManager.adoptStyleSheets(m.contentDocument.adoptedStyleSheets, this.mirror.getId(m.contentDocument))
                }
                handleMessage(m) {
                    if ("rrweb" !== m.data.type || m.origin !== m.data.origin) return;
                    let _ = m.source;
                    if (!_) return;
                    let C = this.crossOriginIframeMap.get(m.source);
                    if (!C) return;
                    let R = this.transformCrossOriginEvent(C, m.data.event);
                    R && this.wrappedEmit(R, m.data.isCheckout)
                }
                transformCrossOriginEvent(m, _) {
                    var C;
                    switch (_.type) {
                        case eN.FullSnapshot:
                            {
                                this.crossOriginIframeMirror.reset(m),
                                this.crossOriginIframeStyleMirror.reset(m),
                                this.replaceIdOnNode(_.data.node, m);
                                let C = _.data.node.id;
                                return this.crossOriginIframeRootIdMap.set(m, C),
                                this.patchRootIdOnNode(_.data.node, C),
                                {
                                    timestamp: _.timestamp,
                                    type: eN.IncrementalSnapshot,
                                    data: {
                                        source: eB.Mutation,
                                        adds: [{
                                            parentId: this.mirror.getId(m),
                                            nextId: null,
                                            node: _.data.node
                                        }],
                                        removes: [],
                                        texts: [],
                                        attributes: [],
                                        isAttachIframe: !0
                                    }
                                }
                            }
                        case eN.Meta:
                        case eN.Load:
                        case eN.DomContentLoaded:
                            break;
                        case eN.Plugin:
                            return _;
                        case eN.Custom:
                            return this.replaceIds(_.data.payload, m, ["id", "parentId", "previousId", "nextId"]), _;
                        case eN.IncrementalSnapshot:
                            switch (_.data.source) {
                                case eB.Mutation:
                                    return _.data.adds.forEach(_ => {
                                        this.replaceIds(_, m, ["parentId", "nextId", "previousId"]), this.replaceIdOnNode(_.node, m);
                                        let C = this.crossOriginIframeRootIdMap.get(m);
                                        C && this.patchRootIdOnNode(_.node, C)
                                    }), _.data.removes.forEach(_ => {
                                        this.replaceIds(_, m, ["parentId", "id"])
                                    }), _.data.attributes.forEach(_ => {
                                        this.replaceIds(_, m, ["id"])
                                    }), _.data.texts.forEach(_ => {
                                        this.replaceIds(_, m, ["id"])
                                    }), _;
                                case eB.Drag:
                                case eB.TouchMove:
                                case eB.MouseMove:
                                    return _.data.positions.forEach(_ => {
                                        this.replaceIds(_, m, ["id"])
                                    }), _;
                                case eB.ViewportResize:
                                    return !1;
                                case eB.MediaInteraction:
                                case eB.MouseInteraction:
                                case eB.Scroll:
                                case eB.CanvasMutation:
                                case eB.Input:
                                    return this.replaceIds(_.data, m, ["id"]), _;
                                case eB.StyleSheetRule:
                                case eB.StyleDeclaration:
                                    return this.replaceIds(_.data, m, ["id"]), this.replaceStyleIds(_.data, m, ["styleId"]), _;
                                case eB.Font:
                                    return _;
                                case eB.Selection:
                                    return _.data.ranges.forEach(_ => {
                                        this.replaceIds(_, m, ["start", "end"])
                                    }), _;
                                case eB.AdoptedStyleSheet:
                                    return this.replaceIds(_.data, m, ["id"]), this.replaceStyleIds(_.data, m, ["styleIds"]), null === (C = _.data.styles) || void 0 === C || C.forEach(_ => {
                                        this.replaceStyleIds(_, m, ["styleId"])
                                    }), _
                            }
                    }
                    return !1
                }
                replace(m, _, C, R) {
                    for (let L of R)(Array.isArray(_[L]) || "number" == typeof _[L]) && (Array.isArray(_[L]) ? _[L] = m.getIds(C, _[L]) : _[L] = m.getId(C, _[L]));
                    return _
                }
                replaceIds(m, _, C) {
                    return this.replace(this.crossOriginIframeMirror, m, _, C)
                }
                replaceStyleIds(m, _, C) {
                    return this.replace(this.crossOriginIframeStyleMirror, m, _, C)
                }
                replaceIdOnNode(m, _) {
                    this.replaceIds(m, _, ["id", "rootId"]), "childNodes" in m && m.childNodes.forEach(m => {
                        this.replaceIdOnNode(m, _)
                    })
                }
                patchRootIdOnNode(m, _) {
                    m.type === eR.Document || m.rootId || (m.rootId = _), "childNodes" in m && m.childNodes.forEach(m => {
                        this.patchRootIdOnNode(m, _)
                    })
                }
            };
            let ShadowDomManager = class ShadowDomManager {
                constructor(m) {
                    this.shadowDoms = new WeakSet, this.restoreHandlers = [], this.mutationCb = m.mutationCb, this.scrollCb = m.scrollCb, this.bypassOptions = m.bypassOptions, this.mirror = m.mirror, this.init()
                }
                init() {
                    this.reset(), this.patchAttachShadow(Element, document)
                }
                addShadowRoot(m, _) {
                    if (!isNativeShadowDom(m) || this.shadowDoms.has(m)) return;
                    this.shadowDoms.add(m);
                    let C = initMutationObserver(Object.assign(Object.assign({}, this.bypassOptions), {
                        doc: _,
                        mutationCb: this.mutationCb,
                        mirror: this.mirror,
                        shadowDomManager: this
                    }), m);
                    this.restoreHandlers.push(() => C.disconnect()), this.restoreHandlers.push(initScrollObserver(Object.assign(Object.assign({}, this.bypassOptions), {
                        scrollCb: this.scrollCb,
                        doc: m,
                        mirror: this.mirror
                    }))), setTimeout(() => {
                        m.adoptedStyleSheets && m.adoptedStyleSheets.length > 0 && this.bypassOptions.stylesheetManager.adoptStyleSheets(m.adoptedStyleSheets, this.mirror.getId(m.host)), this.restoreHandlers.push(initAdoptedStyleSheetObserver({
                            mirror: this.mirror,
                            stylesheetManager: this.bypassOptions.stylesheetManager
                        }, m))
                    }, 0)
                }
                observeAttachShadow(m) {
                    m.contentWindow && m.contentDocument && this.patchAttachShadow(m.contentWindow.Element, m.contentDocument)
                }
                patchAttachShadow(m, _) {
                    let C = this;
                    this.restoreHandlers.push(patch(m.prototype, "attachShadow", function(m) {
                        return function(R) {
                            let L = m.call(this, R);
                            return this.shadowRoot && inDom(this) && C.addShadowRoot(this.shadowRoot, _), L
                        }
                    }))
                }
                reset() {
                    this.restoreHandlers.forEach(m => {
                        try {
                            m()
                        } catch (m) {}
                    }), this.restoreHandlers = [], this.shadowDoms = new WeakSet
                }
            };
            for (var eq = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", eG = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256), ez = 0; ez < eq.length; ez++) eG[eq.charCodeAt(ez)] = ez;
            var encode = function(m) {
                var _, C = new Uint8Array(m),
                    R = C.length,
                    L = "";
                for (_ = 0; _ < R; _ += 3) L += eq[C[_] >> 2] + eq[(3 & C[_]) << 4 | C[_ + 1] >> 4] + eq[(15 & C[_ + 1]) << 2 | C[_ + 2] >> 6] + eq[63 & C[_ + 2]];
                return R % 3 == 2 ? L = L.substring(0, L.length - 1) + "=" : R % 3 == 1 && (L = L.substring(0, L.length - 2) + "=="), L
            };
            let eV = new Map,
                saveWebGLVar = (m, _, C) => {
                    let R;
                    if (!m || !(isInstanceOfWebGLObject(m, _) || "object" == typeof m)) return;
                    let L = m.constructor.name,
                        B = ((R = eV.get(C)) || (R = new Map, eV.set(C, R)), R.has(L) || R.set(L, []), R.get(L)),
                        F = B.indexOf(m);
                    return -1 === F && (F = B.length, B.push(m)), F
                },
                serializeArgs = (m, _, C) => m.map(m => (function serializeArg(m, _, C) {
                    if (m instanceof Array) return m.map(m => serializeArg(m, _, C));
                    if (null === m);
                    else if (m instanceof Float32Array || m instanceof Float64Array || m instanceof Int32Array || m instanceof Uint32Array || m instanceof Uint8Array || m instanceof Uint16Array || m instanceof Int16Array || m instanceof Int8Array || m instanceof Uint8ClampedArray) {
                        let _ = m.constructor.name;
                        return {
                            rr_type: _,
                            args: [Object.values(m)]
                        }
                    } else if (m instanceof ArrayBuffer) {
                        let _ = m.constructor.name,
                            C = encode(m);
                        return {
                            rr_type: _,
                            base64: C
                        }
                    } else if (m instanceof DataView) {
                        let R = m.constructor.name;
                        return {
                            rr_type: R,
                            args: [serializeArg(m.buffer, _, C), m.byteOffset, m.byteLength]
                        }
                    } else if (m instanceof HTMLImageElement) {
                        let _ = m.constructor.name,
                            {
                                src: C
                            } = m;
                        return {
                            rr_type: _,
                            src: C
                        }
                    } else if (m instanceof HTMLCanvasElement) {
                        let _ = m.toDataURL();
                        return {
                            rr_type: "HTMLImageElement",
                            src: _
                        }
                    } else if (m instanceof ImageData) {
                        let R = m.constructor.name;
                        return {
                            rr_type: R,
                            args: [serializeArg(m.data, _, C), m.width, m.height]
                        }
                    } else if (isInstanceOfWebGLObject(m, _) || "object" == typeof m) {
                        let R = m.constructor.name,
                            L = saveWebGLVar(m, _, C);
                        return {
                            rr_type: R,
                            index: L
                        }
                    }
                    return m
                })(m, _, C)),
                isInstanceOfWebGLObject = (m, _) => {
                    let C = ["WebGLActiveInfo", "WebGLBuffer", "WebGLFramebuffer", "WebGLProgram", "WebGLRenderbuffer", "WebGLShader", "WebGLShaderPrecisionFormat", "WebGLTexture", "WebGLUniformLocation", "WebGLVertexArrayObject", "WebGLVertexArrayObjectOES"].filter(m => "function" == typeof _[m]);
                    return !!C.find(C => m instanceof _[C])
                };

            function initCanvasContextObserver(m, _, C, R) {
                let L = [];
                try {
                    let B = patch(m.HTMLCanvasElement.prototype, "getContext", function(m) {
                        return function(L, ...B) {
                            if (!isBlocked(this, _, C, !0)) {
                                let m = "experimental-webgl" === L ? "webgl" : L;
                                if ("__context" in this || (this.__context = m), R && ["webgl", "webgl2"].includes(m)) {
                                    if (B[0] && "object" == typeof B[0]) {
                                        let m = B[0];
                                        m.preserveDrawingBuffer || (m.preserveDrawingBuffer = !0)
                                    } else B.splice(0, 1, {
                                        preserveDrawingBuffer: !0
                                    })
                                }
                            }
                            return m.apply(this, [L, ...B])
                        }
                    });
                    L.push(B)
                } catch (m) {
                    console.error("failed to patch HTMLCanvasElement.prototype.getContext")
                }
                return () => {
                    L.forEach(m => m())
                }
            }

            function patchGLPrototype(m, _, C, R, L, B, F) {
                let U = [],
                    H = Object.getOwnPropertyNames(m);
                for (let B of H)
                    if (!["isContextLost", "canvas", "drawingBufferWidth", "drawingBufferHeight"].includes(B)) try {
                        if ("function" != typeof m[B]) continue;
                        let H = patch(m, B, function(m) {
                            return function(...U) {
                                let H = m.apply(this, U);
                                if (saveWebGLVar(H, F, this), "tagName" in this.canvas && !isBlocked(this.canvas, R, L, !0)) {
                                    let m = serializeArgs(U, F, this),
                                        R = {
                                            type: _,
                                            property: B,
                                            args: m
                                        };
                                    C(this.canvas, R)
                                }
                                return H
                            }
                        });
                        U.push(H)
                    } catch (L) {
                        let R = hookSetter(m, B, {
                            set(m) {
                                C(this.canvas, {
                                    type: _,
                                    property: B,
                                    args: [m],
                                    setter: !0
                                })
                            }
                        });
                        U.push(R)
                    }
                return U
            }
            var eJ = (ed = function() {
                ! function() {
                    /*! *****************************************************************************
                        Copyright (c) Microsoft Corporation.

                        Permission to use, copy, modify, and/or distribute this software for any
                        purpose with or without fee is hereby granted.

                        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
                        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
                        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
                        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
                        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
                        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
                        PERFORMANCE OF THIS SOFTWARE.
                        ***************************************************************************** */
                    function __awaiter(m, _, C, R) {
                        return new(C || (C = Promise))(function(L, B) {
                            function fulfilled(m) {
                                try {
                                    step(R.next(m))
                                } catch (m) {
                                    B(m)
                                }
                            }

                            function rejected(m) {
                                try {
                                    step(R.throw(m))
                                } catch (m) {
                                    B(m)
                                }
                            }

                            function step(m) {
                                var _;
                                m.done ? L(m.value) : ((_ = m.value) instanceof C ? _ : new C(function(m) {
                                    m(_)
                                })).then(fulfilled, rejected)
                            }
                            step((R = R.apply(m, _ || [])).next())
                        })
                    }
                    for (var m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", _ = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256), C = 0; C < m.length; C++) _[m.charCodeAt(C)] = C;
                    var encode = function(_) {
                        var C, R = new Uint8Array(_),
                            L = R.length,
                            B = "";
                        for (C = 0; C < L; C += 3) B += m[R[C] >> 2] + m[(3 & R[C]) << 4 | R[C + 1] >> 4] + m[(15 & R[C + 1]) << 2 | R[C + 2] >> 6] + m[63 & R[C + 2]];
                        return L % 3 == 2 ? B = B.substring(0, B.length - 1) + "=" : L % 3 == 1 && (B = B.substring(0, B.length - 2) + "=="), B
                    };
                    let R = new Map,
                        L = new Map,
                        B = self;
                    B.onmessage = function(m) {
                        return __awaiter(this, void 0, void 0, function*() {
                            if (!("OffscreenCanvas" in globalThis)) return B.postMessage({
                                id: m.data.id
                            }); {
                                let {
                                    id: _,
                                    bitmap: C,
                                    width: F,
                                    height: U,
                                    dataURLOptions: H
                                } = m.data, q = function(m, _, C) {
                                    return __awaiter(this, void 0, void 0, function*() {
                                        let R = `${m}-${_}`;
                                        if (!("OffscreenCanvas" in globalThis)) return ""; {
                                            if (L.has(R)) return L.get(R);
                                            let B = new OffscreenCanvas(m, _);
                                            B.getContext("2d");
                                            let F = yield B.convertToBlob(C), U = yield F.arrayBuffer(), H = encode(U);
                                            return L.set(R, H), H
                                        }
                                    })
                                }(F, U, H), V = new OffscreenCanvas(F, U), X = V.getContext("2d");
                                X.drawImage(C, 0, 0), C.close();
                                let K = yield V.convertToBlob(H), Y = K.type, Q = yield K.arrayBuffer(), et = encode(Q);
                                if (!R.has(_) && (yield q) === et) return R.set(_, et), B.postMessage({
                                    id: _
                                });
                                if (R.get(_) === et) return B.postMessage({
                                    id: _
                                });
                                B.postMessage({
                                    id: _,
                                    type: Y,
                                    base64: et,
                                    width: F,
                                    height: U
                                }), R.set(_, et)
                            }
                        })
                    }
                }()
            }, function(m) {
                var _, C;
                return ep = ep || (_ = function(m, _) {
                    var C = void 0 === _ ? null : _,
                        R = m.toString().split("\n");
                    R.pop(), R.shift();
                    for (var L = R[0].search(/\S/), B = /(['"])__worker_loader_strict__(['"])/g, F = 0, U = R.length; F < U; ++F) R[F] = R[F].substring(L).replace(B, "$1use strict$2") + "\n";
                    return C && R.push("//# sourceMappingURL=" + C + "\n"), R
                }(ed, null), C = new Blob(_, {
                    type: "application/javascript"
                }), URL.createObjectURL(C)), new Worker(ep, m)
            });
            let CanvasManager = class CanvasManager {
                reset() {
                    this.pendingCanvasMutations.clear(), this.resetObservers && this.resetObservers()
                }
                freeze() {
                    this.frozen = !0
                }
                unfreeze() {
                    this.frozen = !1
                }
                lock() {
                    this.locked = !0
                }
                unlock() {
                    this.locked = !1
                }
                constructor(m) {
                    this.pendingCanvasMutations = new Map, this.rafStamps = {
                        latestId: 0,
                        invokeId: null
                    }, this.frozen = !1, this.locked = !1, this.processMutation = (m, _) => {
                        let C = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;
                        (C || !this.rafStamps.invokeId) && (this.rafStamps.invokeId = this.rafStamps.latestId), this.pendingCanvasMutations.has(m) || this.pendingCanvasMutations.set(m, []), this.pendingCanvasMutations.get(m).push(_)
                    };
                    let {
                        sampling: _ = "all",
                        win: C,
                        blockClass: R,
                        blockSelector: L,
                        recordCanvas: B,
                        dataURLOptions: F
                    } = m;
                    this.mutationCb = m.mutationCb, this.mirror = m.mirror, B && "all" === _ && this.initCanvasMutationObserver(C, R, L), B && "number" == typeof _ && this.initCanvasFPSObserver(_, C, R, L, {
                        dataURLOptions: F
                    })
                }
                initCanvasFPSObserver(m, _, C, R, L) {
                    let B;
                    let F = initCanvasContextObserver(_, C, R, !0),
                        U = new Map,
                        H = new eJ;
                    H.onmessage = m => {
                        let {
                            id: _
                        } = m.data;
                        if (U.set(_, !1), !("base64" in m.data)) return;
                        let {
                            base64: C,
                            type: R,
                            width: L,
                            height: B
                        } = m.data;
                        this.mutationCb({
                            id: _,
                            type: eU["2D"],
                            commands: [{
                                property: "clearRect",
                                args: [0, 0, L, B]
                            }, {
                                property: "drawImage",
                                args: [{
                                    rr_type: "ImageBitmap",
                                    args: [{
                                        rr_type: "Blob",
                                        data: [{
                                            rr_type: "ArrayBuffer",
                                            base64: C
                                        }],
                                        type: R
                                    }]
                                }, 0, 0]
                            }]
                        })
                    };
                    let q = 1e3 / m,
                        V = 0,
                        getCanvas = () => {
                            let m = [];
                            return _.document.querySelectorAll("canvas").forEach(_ => {
                                isBlocked(_, C, R, !0) || m.push(_)
                            }), m
                        },
                        takeCanvasSnapshots = m => {
                            if (V && m - V < q) {
                                B = requestAnimationFrame(takeCanvasSnapshots);
                                return
                            }
                            V = m, getCanvas().forEach(m => {
                                var _, C, R, B;
                                return _ = this, C = void 0, R = void 0, B = function*() {
                                    var _;
                                    let C = this.mirror.getId(m);
                                    if (U.get(C) || 0 === m.width || 0 === m.height) return;
                                    if (U.set(C, !0), ["webgl", "webgl2"].includes(m.__context)) {
                                        let C = m.getContext(m.__context);
                                        (null === (_ = null == C ? void 0 : C.getContextAttributes()) || void 0 === _ ? void 0 : _.preserveDrawingBuffer) === !1 && C.clear(C.COLOR_BUFFER_BIT)
                                    }
                                    let R = yield createImageBitmap(m);
                                    H.postMessage({
                                        id: C,
                                        bitmap: R,
                                        width: m.width,
                                        height: m.height,
                                        dataURLOptions: L.dataURLOptions
                                    }, [R])
                                }, new(R || (R = Promise))(function(m, L) {
                                    function fulfilled(m) {
                                        try {
                                            step(B.next(m))
                                        } catch (m) {
                                            L(m)
                                        }
                                    }

                                    function rejected(m) {
                                        try {
                                            step(B.throw(m))
                                        } catch (m) {
                                            L(m)
                                        }
                                    }

                                    function step(_) {
                                        var C;
                                        _.done ? m(_.value) : ((C = _.value) instanceof R ? C : new R(function(m) {
                                            m(C)
                                        })).then(fulfilled, rejected)
                                    }
                                    step((B = B.apply(_, C || [])).next())
                                })
                            }), B = requestAnimationFrame(takeCanvasSnapshots)
                        };
                    B = requestAnimationFrame(takeCanvasSnapshots), this.resetObservers = () => {
                        F(), cancelAnimationFrame(B)
                    }
                }
                initCanvasMutationObserver(m, _, C) {
                    this.startRAFTimestamping(), this.startPendingCanvasMutationFlusher();
                    let R = initCanvasContextObserver(m, _, C, !1),
                        L = function(m, _, C, R) {
                            let L = [],
                                B = Object.getOwnPropertyNames(_.CanvasRenderingContext2D.prototype);
                            for (let F of B) try {
                                if ("function" != typeof _.CanvasRenderingContext2D.prototype[F]) continue;
                                let B = patch(_.CanvasRenderingContext2D.prototype, F, function(L) {
                                    return function(...B) {
                                        return isBlocked(this.canvas, C, R, !0) || setTimeout(() => {
                                            let C = serializeArgs(B, _, this);
                                            m(this.canvas, {
                                                type: eU["2D"],
                                                property: F,
                                                args: C
                                            })
                                        }, 0), L.apply(this, B)
                                    }
                                });
                                L.push(B)
                            } catch (R) {
                                let C = hookSetter(_.CanvasRenderingContext2D.prototype, F, {
                                    set(_) {
                                        m(this.canvas, {
                                            type: eU["2D"],
                                            property: F,
                                            args: [_],
                                            setter: !0
                                        })
                                    }
                                });
                                L.push(C)
                            }
                            return () => {
                                L.forEach(m => m())
                            }
                        }(this.processMutation.bind(this), m, _, C),
                        B = function(m, _, C, R, L) {
                            let B = [];
                            return B.push(...patchGLPrototype(_.WebGLRenderingContext.prototype, eU.WebGL, m, C, R, L, _)), void 0 !== _.WebGL2RenderingContext && B.push(...patchGLPrototype(_.WebGL2RenderingContext.prototype, eU.WebGL2, m, C, R, L, _)), () => {
                                B.forEach(m => m())
                            }
                        }(this.processMutation.bind(this), m, _, C, this.mirror);
                    this.resetObservers = () => {
                        R(), L(), B()
                    }
                }
                startPendingCanvasMutationFlusher() {
                    requestAnimationFrame(() => this.flushPendingCanvasMutations())
                }
                startRAFTimestamping() {
                    let setLatestRAFTimestamp = m => {
                        this.rafStamps.latestId = m, requestAnimationFrame(setLatestRAFTimestamp)
                    };
                    requestAnimationFrame(setLatestRAFTimestamp)
                }
                flushPendingCanvasMutations() {
                    this.pendingCanvasMutations.forEach((m, _) => {
                        let C = this.mirror.getId(_);
                        this.flushPendingCanvasMutationFor(_, C)
                    }), requestAnimationFrame(() => this.flushPendingCanvasMutations())
                }
                flushPendingCanvasMutationFor(m, _) {
                    if (this.frozen || this.locked) return;
                    let C = this.pendingCanvasMutations.get(m);
                    if (!C || -1 === _) return;
                    let R = C.map(m => {
                            let _ =
                                /*! *****************************************************************************
                                Copyright (c) Microsoft Corporation.

                                Permission to use, copy, modify, and/or distribute this software for any
                                purpose with or without fee is hereby granted.

                                THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
                                REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
                                AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
                                INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
                                LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
                                OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
                                PERFORMANCE OF THIS SOFTWARE.
                                ***************************************************************************** */
                                function(m, _) {
                                    var C = {};
                                    for (var R in m) Object.prototype.hasOwnProperty.call(m, R) && 0 > _.indexOf(R) && (C[R] = m[R]);
                                    if (null != m && "function" == typeof Object.getOwnPropertySymbols)
                                        for (var L = 0, R = Object.getOwnPropertySymbols(m); L < R.length; L++) 0 > _.indexOf(R[L]) && Object.prototype.propertyIsEnumerable.call(m, R[L]) && (C[R[L]] = m[R[L]]);
                                    return C
                                }(m, ["type"]);
                            return _
                        }),
                        {
                            type: L
                        } = C[0];
                    this.mutationCb({
                        id: _,
                        type: L,
                        commands: R
                    }), this.pendingCanvasMutations.delete(m)
                }
            };
            let StylesheetManager = class StylesheetManager {
                constructor(m) {
                    this.trackedLinkElements = new WeakSet, this.styleMirror = new StyleSheetMirror, this.mutationCb = m.mutationCb, this.adoptedStyleSheetCb = m.adoptedStyleSheetCb
                }
                attachLinkElement(m, _) {
                    "_cssText" in _.attributes && this.mutationCb({
                        adds: [],
                        removes: [],
                        texts: [],
                        attributes: [{
                            id: _.id,
                            attributes: _.attributes
                        }]
                    }), this.trackLinkElement(m)
                }
                trackLinkElement(m) {
                    this.trackedLinkElements.has(m) || (this.trackedLinkElements.add(m), this.trackStylesheetInLinkElement(m))
                }
                adoptStyleSheets(m, _) {
                    if (0 === m.length) return;
                    let C = {
                            id: _,
                            styleIds: []
                        },
                        R = [];
                    for (let _ of m) {
                        let m;
                        this.styleMirror.has(_) ? m = this.styleMirror.getId(_) : (m = this.styleMirror.add(_), R.push({
                            styleId: m,
                            rules: Array.from(_.rules || CSSRule, (m, _) => ({
                                rule: stringifyRule(m),
                                index: _
                            }))
                        })), C.styleIds.push(m)
                    }
                    R.length > 0 && (C.styles = R), this.adoptedStyleSheetCb(C)
                }
                reset() {
                    this.styleMirror.reset(), this.trackedLinkElements = new WeakSet
                }
                trackStylesheetInLinkElement(m) {}
            };
            let ProcessedNodeManager = class ProcessedNodeManager {
                constructor() {
                    this.nodeMap = new WeakMap, this.loop = !0, this.periodicallyClear()
                }
                periodicallyClear() {
                    requestAnimationFrame(() => {
                        this.clear(), this.loop && this.periodicallyClear()
                    })
                }
                inOtherBuffer(m, _) {
                    let C = this.nodeMap.get(m);
                    return C && Array.from(C).some(m => m !== _)
                }
                add(m, _) {
                    this.nodeMap.set(m, (this.nodeMap.get(m) || new Set).add(_))
                }
                clear() {
                    this.nodeMap = new WeakMap
                }
                destroy() {
                    this.loop = !1
                }
            };

            function wrapEvent(m) {
                return Object.assign(Object.assign({}, m), {
                    timestamp: ea()
                })
            }
            let eX = !1,
                eK = new Mirror;

            function record(m = {}) {
                let _;
                let {
                    emit: C,
                    checkoutEveryNms: R,
                    checkoutEveryNth: L,
                    blockClass: q = "rr-block",
                    blockSelector: V = null,
                    ignoreClass: X = "rr-ignore",
                    ignoreSelector: K = null,
                    maskTextClass: Y = "rr-mask",
                    maskTextSelector: Q = null,
                    inlineStylesheet: et = !0,
                    maskAllInputs: er,
                    maskInputOptions: en,
                    slimDOMOptions: ei,
                    maskInputFn: eo,
                    maskTextFn: ea,
                    hooks: es,
                    packFn: ec,
                    sampling: el = {},
                    dataURLOptions: eu = {},
                    mousemoveWait: ed,
                    recordDOM: ep = !0,
                    recordCanvas: eh = !1,
                    recordCrossOriginIframes: ef = !1,
                    recordAfter: em = "DOMContentLoaded" === m.recordAfter ? m.recordAfter : "load",
                    userTriggeredOnInput: eg = !1,
                    collectFonts: ey = !1,
                    inlineImages: e_ = !1,
                    plugins: ev,
                    keepIframeSrcFn: eb = () => !1,
                    ignoreCSSAttributes: eS = new Set([]),
                    errorHandler: ew
                } = m;
                B = ew;
                let eE = !ef || window.parent === window,
                    ek = !1;
                if (!eE) try {
                    window.parent.document && (ek = !1)
                } catch (m) {
                    ek = !0
                }
                if (eE && !C) throw Error("emit function is required");
                void 0 !== ed && void 0 === el.mousemove && (el.mousemove = ed), eK.reset();
                let ex = !0 === er ? {
                        color: !0,
                        date: !0,
                        "datetime-local": !0,
                        email: !0,
                        month: !0,
                        number: !0,
                        range: !0,
                        search: !0,
                        tel: !0,
                        text: !0,
                        time: !0,
                        url: !0,
                        week: !0,
                        textarea: !0,
                        select: !0,
                        password: !0
                    } : void 0 !== en ? en : {
                        password: !0
                    },
                    eI = !0 === ei || "all" === ei ? {
                        script: !0,
                        comment: !0,
                        headFavicon: !0,
                        headWhitespace: !0,
                        headMetaSocial: !0,
                        headMetaRobots: !0,
                        headMetaHttpEquiv: !0,
                        headMetaVerification: !0,
                        headMetaAuthorship: "all" === ei,
                        headMetaDescKeywords: "all" === ei
                    } : ei || {};
                ! function(m = window) {
                    "NodeList" in m && !m.NodeList.prototype.forEach && (m.NodeList.prototype.forEach = Array.prototype.forEach), "DOMTokenList" in m && !m.DOMTokenList.prototype.forEach && (m.DOMTokenList.prototype.forEach = Array.prototype.forEach), Node.prototype.contains || (Node.prototype.contains = (...m) => {
                        let _ = m[0];
                        if (!(0 in m)) throw TypeError("1 argument is required");
                        do
                            if (this === _) return !0; while (_ = _ && _.parentNode);
                        return !1
                    })
                }();
                let eO = 0,
                    eventProcessor = m => {
                        for (let _ of ev || []) _.eventProcessor && (m = _.eventProcessor(m));
                        return ec && !ek && (m = ec(m)), m
                    };
                F = (m, B) => {
                    var F;
                    if ((null === (F = eH[0]) || void 0 === F ? void 0 : F.isFrozen()) && m.type !== eN.FullSnapshot && !(m.type === eN.IncrementalSnapshot && m.data.source === eB.Mutation) && eH.forEach(m => m.unfreeze()), eE) null == C || C(eventProcessor(m), B);
                    else if (ek) {
                        let _ = {
                            type: "rrweb",
                            event: eventProcessor(m),
                            origin: window.location.origin,
                            isCheckout: B
                        };
                        window.parent.postMessage(_, "*")
                    }
                    if (m.type === eN.FullSnapshot) _ = m, eO = 0;
                    else if (m.type === eN.IncrementalSnapshot) {
                        if (m.data.source === eB.Mutation && m.data.isAttachIframe) return;
                        eO++;
                        let C = L && eO >= L,
                            B = R && m.timestamp - _.timestamp > R;
                        (C || B) && U(!0)
                    }
                };
                let wrappedMutationEmit = m => {
                        F(wrapEvent({
                            type: eN.IncrementalSnapshot,
                            data: Object.assign({
                                source: eB.Mutation
                            }, m)
                        }))
                    },
                    wrappedScrollEmit = m => F(wrapEvent({
                        type: eN.IncrementalSnapshot,
                        data: Object.assign({
                            source: eB.Scroll
                        }, m)
                    })),
                    wrappedCanvasMutationEmit = m => F(wrapEvent({
                        type: eN.IncrementalSnapshot,
                        data: Object.assign({
                            source: eB.CanvasMutation
                        }, m)
                    })),
                    eC = new StylesheetManager({
                        mutationCb: wrappedMutationEmit,
                        adoptedStyleSheetCb: m => F(wrapEvent({
                            type: eN.IncrementalSnapshot,
                            data: Object.assign({
                                source: eB.AdoptedStyleSheet
                            }, m)
                        }))
                    }),
                    eM = new IframeManager({
                        mirror: eK,
                        mutationCb: wrappedMutationEmit,
                        stylesheetManager: eC,
                        recordCrossOriginIframes: ef,
                        wrappedEmit: F
                    });
                for (let m of ev || []) m.getMirror && m.getMirror({
                    nodeMirror: eK,
                    crossOriginIframeMirror: eM.crossOriginIframeMirror,
                    crossOriginIframeStyleMirror: eM.crossOriginIframeStyleMirror
                });
                let eT = new ProcessedNodeManager;
                H = new CanvasManager({
                    recordCanvas: eh,
                    mutationCb: wrappedCanvasMutationEmit,
                    win: window,
                    blockClass: q,
                    blockSelector: V,
                    mirror: eK,
                    sampling: el.canvas,
                    dataURLOptions: eu
                });
                let eA = new ShadowDomManager({
                    mutationCb: wrappedMutationEmit,
                    scrollCb: wrappedScrollEmit,
                    bypassOptions: {
                        blockClass: q,
                        blockSelector: V,
                        maskTextClass: Y,
                        maskTextSelector: Q,
                        inlineStylesheet: et,
                        maskInputOptions: ex,
                        dataURLOptions: eu,
                        maskTextFn: ea,
                        maskInputFn: eo,
                        recordCanvas: eh,
                        inlineImages: e_,
                        sampling: el,
                        slimDOMOptions: eI,
                        iframeManager: eM,
                        stylesheetManager: eC,
                        canvasManager: H,
                        keepIframeSrcFn: eb,
                        processedNodeManager: eT
                    },
                    mirror: eK
                });
                U = (m = !1) => {
                    if (!ep) return;
                    F(wrapEvent({
                        type: eN.Meta,
                        data: {
                            href: window.location.href,
                            width: getWindowWidth(),
                            height: getWindowHeight()
                        }
                    }), m), eC.reset(), eA.init(), eH.forEach(m => m.lock());
                    let _ = function(m, _) {
                        let {
                            mirror: C = new Mirror,
                            blockClass: R = "rr-block",
                            blockSelector: L = null,
                            maskTextClass: B = "rr-mask",
                            maskTextSelector: F = null,
                            inlineStylesheet: U = !0,
                            inlineImages: H = !1,
                            recordCanvas: q = !1,
                            maskAllInputs: V = !1,
                            maskTextFn: X,
                            maskInputFn: K,
                            slimDOM: Y = !1,
                            dataURLOptions: Q,
                            preserveWhiteSpace: et,
                            onSerialize: er,
                            onIframeLoad: en,
                            iframeLoadTimeout: ei,
                            onStylesheetLoad: eo,
                            stylesheetLoadTimeout: ea,
                            keepIframeSrcFn: es = () => !1
                        } = _ || {}, ec = !0 === V ? {
                            color: !0,
                            date: !0,
                            "datetime-local": !0,
                            email: !0,
                            month: !0,
                            number: !0,
                            range: !0,
                            search: !0,
                            tel: !0,
                            text: !0,
                            time: !0,
                            url: !0,
                            week: !0,
                            textarea: !0,
                            select: !0,
                            password: !0
                        } : !1 === V ? {
                            password: !0
                        } : V, el = !0 === Y || "all" === Y ? {
                            script: !0,
                            comment: !0,
                            headFavicon: !0,
                            headWhitespace: !0,
                            headMetaDescKeywords: "all" === Y,
                            headMetaSocial: !0,
                            headMetaRobots: !0,
                            headMetaHttpEquiv: !0,
                            headMetaAuthorship: !0,
                            headMetaVerification: !0
                        } : !1 === Y ? {} : Y;
                        return serializeNodeWithId(m, {
                            doc: m,
                            mirror: C,
                            blockClass: R,
                            blockSelector: L,
                            maskTextClass: B,
                            maskTextSelector: F,
                            skipChild: !1,
                            inlineStylesheet: U,
                            maskInputOptions: ec,
                            maskTextFn: X,
                            maskInputFn: K,
                            slimDOMOptions: el,
                            dataURLOptions: Q,
                            inlineImages: H,
                            recordCanvas: q,
                            preserveWhiteSpace: et,
                            onSerialize: er,
                            onIframeLoad: en,
                            iframeLoadTimeout: ei,
                            onStylesheetLoad: eo,
                            stylesheetLoadTimeout: ea,
                            keepIframeSrcFn: es,
                            newlyAddedElement: !1
                        })
                    }(document, {
                        mirror: eK,
                        blockClass: q,
                        blockSelector: V,
                        maskTextClass: Y,
                        maskTextSelector: Q,
                        inlineStylesheet: et,
                        maskAllInputs: ex,
                        maskTextFn: ea,
                        slimDOM: eI,
                        dataURLOptions: eu,
                        recordCanvas: eh,
                        inlineImages: e_,
                        onSerialize: m => {
                            isSerializedIframe(m, eK) && eM.addIframe(m), isSerializedStylesheet(m, eK) && eC.trackLinkElement(m), hasShadowRoot(m) && eA.addShadowRoot(m.shadowRoot, document)
                        },
                        onIframeLoad: (m, _) => {
                            eM.attachIframe(m, _), eA.observeAttachShadow(m)
                        },
                        onStylesheetLoad: (m, _) => {
                            eC.attachLinkElement(m, _)
                        },
                        keepIframeSrcFn: eb
                    });
                    if (!_) return console.warn("Failed to snapshot the document");
                    F(wrapEvent({
                        type: eN.FullSnapshot,
                        data: {
                            node: _,
                            initialOffset: getWindowScroll(window)
                        }
                    }), m), eH.forEach(m => m.unlock()), document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0 && eC.adoptStyleSheets(document.adoptedStyleSheets, eK.getId(document))
                };
                try {
                    let m = [],
                        observe = m => {
                            var _;
                            return callbackWrapper(initObservers)({
                                mutationCb: wrappedMutationEmit,
                                mousemoveCb: (m, _) => F(wrapEvent({
                                    type: eN.IncrementalSnapshot,
                                    data: {
                                        source: _,
                                        positions: m
                                    }
                                })),
                                mouseInteractionCb: m => F(wrapEvent({
                                    type: eN.IncrementalSnapshot,
                                    data: Object.assign({
                                        source: eB.MouseInteraction
                                    }, m)
                                })),
                                scrollCb: wrappedScrollEmit,
                                viewportResizeCb: m => F(wrapEvent({
                                    type: eN.IncrementalSnapshot,
                                    data: Object.assign({
                                        source: eB.ViewportResize
                                    }, m)
                                })),
                                inputCb: m => F(wrapEvent({
                                    type: eN.IncrementalSnapshot,
                                    data: Object.assign({
                                        source: eB.Input
                                    }, m)
                                })),
                                mediaInteractionCb: m => F(wrapEvent({
                                    type: eN.IncrementalSnapshot,
                                    data: Object.assign({
                                        source: eB.MediaInteraction
                                    }, m)
                                })),
                                styleSheetRuleCb: m => F(wrapEvent({
                                    type: eN.IncrementalSnapshot,
                                    data: Object.assign({
                                        source: eB.StyleSheetRule
                                    }, m)
                                })),
                                styleDeclarationCb: m => F(wrapEvent({
                                    type: eN.IncrementalSnapshot,
                                    data: Object.assign({
                                        source: eB.StyleDeclaration
                                    }, m)
                                })),
                                canvasMutationCb: wrappedCanvasMutationEmit,
                                fontCb: m => F(wrapEvent({
                                    type: eN.IncrementalSnapshot,
                                    data: Object.assign({
                                        source: eB.Font
                                    }, m)
                                })),
                                selectionCb: m => {
                                    F(wrapEvent({
                                        type: eN.IncrementalSnapshot,
                                        data: Object.assign({
                                            source: eB.Selection
                                        }, m)
                                    }))
                                },
                                customElementCb: m => {
                                    F(wrapEvent({
                                        type: eN.IncrementalSnapshot,
                                        data: Object.assign({
                                            source: eB.CustomElement
                                        }, m)
                                    }))
                                },
                                blockClass: q,
                                ignoreClass: X,
                                ignoreSelector: K,
                                maskTextClass: Y,
                                maskTextSelector: Q,
                                maskInputOptions: ex,
                                inlineStylesheet: et,
                                sampling: el,
                                recordDOM: ep,
                                recordCanvas: eh,
                                inlineImages: e_,
                                userTriggeredOnInput: eg,
                                collectFonts: ey,
                                doc: m,
                                maskInputFn: eo,
                                maskTextFn: ea,
                                keepIframeSrcFn: eb,
                                blockSelector: V,
                                slimDOMOptions: eI,
                                dataURLOptions: eu,
                                mirror: eK,
                                iframeManager: eM,
                                stylesheetManager: eC,
                                shadowDomManager: eA,
                                processedNodeManager: eT,
                                canvasManager: H,
                                ignoreCSSAttributes: eS,
                                plugins: (null === (_ = null == ev ? void 0 : ev.filter(m => m.observer)) || void 0 === _ ? void 0 : _.map(m => ({
                                    observer: m.observer,
                                    options: m.options,
                                    callback: _ => F(wrapEvent({
                                        type: eN.Plugin,
                                        data: {
                                            plugin: m.name,
                                            payload: _
                                        }
                                    }))
                                }))) || []
                            }, es)
                        };
                    eM.addLoadListener(_ => {
                        try {
                            m.push(observe(_.contentDocument))
                        } catch (m) {
                            console.warn(m)
                        }
                    });
                    let init = () => {
                        U(), m.push(observe(document)), eX = !0
                    };
                    return "interactive" === document.readyState || "complete" === document.readyState ? init() : (m.push(on("DOMContentLoaded", () => {
                        F(wrapEvent({
                            type: eN.DomContentLoaded,
                            data: {}
                        })), "DOMContentLoaded" === em && init()
                    })), m.push(on("load", () => {
                        F(wrapEvent({
                            type: eN.Load,
                            data: {}
                        })), "load" === em && init()
                    }, window))), () => {
                        m.forEach(m => m()), eT.destroy(), eX = !1, B = void 0
                    }
                } catch (m) {
                    console.warn(m)
                }
            }
            record.addCustomEvent = (m, _) => {
                if (!eX) throw Error("please add custom event after start recording");
                F(wrapEvent({
                    type: eN.Custom,
                    data: {
                        tag: m,
                        payload: _
                    }
                }))
            }, record.freezePage = () => {
                eH.forEach(m => m.freeze())
            }, record.takeFullSnapshot = m => {
                if (!eX) throw Error("please take full snapshot after start recording");
                U(m)
            }, record.mirror = eK;
            var eZ = ((eh = eZ || {})[eh.DomContentLoaded = 0] = "DomContentLoaded", eh[eh.Load = 1] = "Load", eh[eh.FullSnapshot = 2] = "FullSnapshot", eh[eh.IncrementalSnapshot = 3] = "IncrementalSnapshot", eh[eh.Meta = 4] = "Meta", eh[eh.Custom = 5] = "Custom", eh[eh.Plugin = 6] = "Plugin", eh),
                eY = ((ef = eY || {})[ef.Mutation = 0] = "Mutation", ef[ef.MouseMove = 1] = "MouseMove", ef[ef.MouseInteraction = 2] = "MouseInteraction", ef[ef.Scroll = 3] = "Scroll", ef[ef.ViewportResize = 4] = "ViewportResize", ef[ef.Input = 5] = "Input", ef[ef.TouchMove = 6] = "TouchMove", ef[ef.MediaInteraction = 7] = "MediaInteraction", ef[ef.StyleSheetRule = 8] = "StyleSheetRule", ef[ef.CanvasMutation = 9] = "CanvasMutation", ef[ef.Font = 10] = "Font", ef[ef.Log = 11] = "Log", ef[ef.Drag = 12] = "Drag", ef[ef.StyleDeclaration = 13] = "StyleDeclaration", ef[ef.Selection = 14] = "Selection", ef[ef.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", ef[ef.CustomElement = 16] = "CustomElement", ef),
                eQ = {
                    DEBUG: !1,
                    LIB_VERSION: "2.55.1"
                };
            if ("undefined" == typeof window) {
                var e0 = {
                    hostname: ""
                };
                eP = {
                    navigator: {
                        userAgent: "",
                        onLine: !0
                    },
                    document: {
                        location: e0,
                        referrer: ""
                    },
                    screen: {
                        width: 0,
                        height: 0
                    },
                    location: e0
                }
            } else eP = window;
            var e1 = Array.prototype,
                e2 = Function.prototype,
                e3 = Object.prototype,
                e5 = e1.slice,
                e6 = e3.toString,
                e4 = e3.hasOwnProperty,
                e8 = eP.console,
                e9 = eP.navigator,
                e7 = eP.document,
                te = eP.opera,
                tt = eP.screen,
                tr = e9.userAgent,
                tn = e2.bind,
                ti = e1.forEach,
                to = e1.indexOf,
                ta = e1.map,
                ts = Array.isArray,
                tc = {},
                tl = {
                    trim: function(m) {
                        return m.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
                    }
                },
                tu = {
                    log: function() {
                        if (eQ.DEBUG && !tl.isUndefined(e8) && e8) try {
                            e8.log.apply(e8, arguments)
                        } catch (m) {
                            tl.each(arguments, function(m) {
                                e8.log(m)
                            })
                        }
                    },
                    warn: function() {
                        if (eQ.DEBUG && !tl.isUndefined(e8) && e8) {
                            var m = ["Mixpanel warning:"].concat(tl.toArray(arguments));
                            try {
                                e8.warn.apply(e8, m)
                            } catch (_) {
                                tl.each(m, function(m) {
                                    e8.warn(m)
                                })
                            }
                        }
                    },
                    error: function() {
                        if (eQ.DEBUG && !tl.isUndefined(e8) && e8) {
                            var m = ["Mixpanel error:"].concat(tl.toArray(arguments));
                            try {
                                e8.error.apply(e8, m)
                            } catch (_) {
                                tl.each(m, function(m) {
                                    e8.error(m)
                                })
                            }
                        }
                    },
                    critical: function() {
                        if (!tl.isUndefined(e8) && e8) {
                            var m = ["Mixpanel error:"].concat(tl.toArray(arguments));
                            try {
                                e8.error.apply(e8, m)
                            } catch (_) {
                                tl.each(m, function(m) {
                                    e8.error(m)
                                })
                            }
                        }
                    }
                },
                log_func_with_prefix = function(m, _) {
                    return function() {
                        return arguments[0] = "[" + _ + "] " + arguments[0], m.apply(tu, arguments)
                    }
                },
                console_with_prefix = function(m) {
                    return {
                        log: log_func_with_prefix(tu.log, m),
                        error: log_func_with_prefix(tu.error, m),
                        critical: log_func_with_prefix(tu.critical, m)
                    }
                };
            tl.bind = function(m, _) {
                var C, R;
                if (tn && m.bind === tn) return tn.apply(m, e5.call(arguments, 1));
                if (!tl.isFunction(m)) throw TypeError();
                return C = e5.call(arguments, 2), R = function() {
                    if (!(this instanceof R)) return m.apply(_, C.concat(e5.call(arguments)));
                    var L = {};
                    L.prototype = m.prototype;
                    var B = new L;
                    L.prototype = null;
                    var F = m.apply(B, C.concat(e5.call(arguments)));
                    return Object(F) === F ? F : B
                }
            }, tl.each = function(m, _, C) {
                if (null != m) {
                    if (ti && m.forEach === ti) m.forEach(_, C);
                    else if (m.length === +m.length) {
                        for (var R = 0, L = m.length; R < L; R++)
                            if (R in m && _.call(C, m[R], R, m) === tc) return
                    } else
                        for (var B in m)
                            if (e4.call(m, B) && _.call(C, m[B], B, m) === tc) return
                }
            }, tl.extend = function(m) {
                return tl.each(e5.call(arguments, 1), function(_) {
                    for (var C in _) void 0 !== _[C] && (m[C] = _[C])
                }), m
            }, tl.isArray = ts || function(m) {
                return "[object Array]" === e6.call(m)
            }, tl.isFunction = function(m) {
                try {
                    return /^\s*\bfunction\b/.test(m)
                } catch (m) {
                    return !1
                }
            }, tl.isArguments = function(m) {
                return !!(m && e4.call(m, "callee"))
            }, tl.toArray = function(m) {
                return m ? m.toArray ? m.toArray() : tl.isArray(m) || tl.isArguments(m) ? e5.call(m) : tl.values(m) : []
            }, tl.map = function(m, _, C) {
                if (ta && m.map === ta) return m.map(_, C);
                var R = [];
                return tl.each(m, function(m) {
                    R.push(_.call(C, m))
                }), R
            }, tl.keys = function(m) {
                var _ = [];
                return null === m || tl.each(m, function(m, C) {
                    _[_.length] = C
                }), _
            }, tl.values = function(m) {
                var _ = [];
                return null === m || tl.each(m, function(m) {
                    _[_.length] = m
                }), _
            }, tl.include = function(m, _) {
                var C = !1;
                return null === m ? C : to && m.indexOf === to ? -1 != m.indexOf(_) : (tl.each(m, function(m) {
                    if (C || (C = m === _)) return tc
                }), C)
            }, tl.includes = function(m, _) {
                return -1 !== m.indexOf(_)
            }, tl.inherit = function(m, _) {
                return m.prototype = new _, m.prototype.constructor = m, m.superclass = _.prototype, m
            }, tl.isObject = function(m) {
                return m === Object(m) && !tl.isArray(m)
            }, tl.isEmptyObject = function(m) {
                if (tl.isObject(m)) {
                    for (var _ in m)
                        if (e4.call(m, _)) return !1;
                    return !0
                }
                return !1
            }, tl.isUndefined = function(m) {
                return void 0 === m
            }, tl.isString = function(m) {
                return "[object String]" == e6.call(m)
            }, tl.isDate = function(m) {
                return "[object Date]" == e6.call(m)
            }, tl.isNumber = function(m) {
                return "[object Number]" == e6.call(m)
            }, tl.isElement = function(m) {
                return !!(m && 1 === m.nodeType)
            }, tl.encodeDates = function(m) {
                return tl.each(m, function(_, C) {
                    tl.isDate(_) ? m[C] = tl.formatDate(_) : tl.isObject(_) && (m[C] = tl.encodeDates(_))
                }), m
            }, tl.timestamp = function() {
                return Date.now = Date.now || function() {
                    return +new Date
                }, Date.now()
            }, tl.formatDate = function(m) {
                function pad(m) {
                    return m < 10 ? "0" + m : m
                }
                return m.getUTCFullYear() + "-" + pad(m.getUTCMonth() + 1) + "-" + pad(m.getUTCDate()) + "T" + pad(m.getUTCHours()) + ":" + pad(m.getUTCMinutes()) + ":" + pad(m.getUTCSeconds())
            }, tl.strip_empty_properties = function(m) {
                var _ = {};
                return tl.each(m, function(m, C) {
                    tl.isString(m) && m.length > 0 && (_[C] = m)
                }), _
            }, tl.truncate = function(m, _) {
                var C;
                return "string" == typeof m ? C = m.slice(0, _) : tl.isArray(m) ? (C = [], tl.each(m, function(m) {
                    C.push(tl.truncate(m, _))
                })) : tl.isObject(m) ? (C = {}, tl.each(m, function(m, R) {
                    C[R] = tl.truncate(m, _)
                })) : C = m, C
            }, tl.JSONEncode = function(m) {
                var quote = function(m) {
                        var _ = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                            C = {
                                "\b": "\\b",
                                "	": "\\t",
                                "\n": "\\n",
                                "\f": "\\f",
                                "\r": "\\r",
                                '"': '\\"',
                                "\\": "\\\\"
                            };
                        return _.lastIndex = 0, _.test(m) ? '"' + m.replace(_, function(m) {
                            var _ = C[m];
                            return "string" == typeof _ ? _ : "\\u" + ("0000" + m.charCodeAt(0).toString(16)).slice(-4)
                        }) + '"' : '"' + m + '"'
                    },
                    str = function(m, _) {
                        var C = "",
                            R = 0,
                            L = "",
                            B = "",
                            F = 0,
                            U = C,
                            H = [],
                            q = _[m];
                        switch (q && "object" == typeof q && "function" == typeof q.toJSON && (q = q.toJSON(m)), typeof q) {
                            case "string":
                                return quote(q);
                            case "number":
                                return isFinite(q) ? String(q) : "null";
                            case "boolean":
                            case "null":
                                return String(q);
                            case "object":
                                if (!q) return "null";
                                if (C += "    ", H = [], "[object Array]" === e6.apply(q)) {
                                    for (R = 0, F = q.length; R < F; R += 1) H[R] = str(R, q) || "null";
                                    return B = 0 === H.length ? "[]" : C ? "[\n" + C + H.join(",\n" + C) + "\n" + U + "]" : "[" + H.join(",") + "]", C = U, B
                                }
                                for (L in q) e4.call(q, L) && (B = str(L, q)) && H.push(quote(L) + (C ? ": " : ":") + B);
                                return B = 0 === H.length ? "{}" : C ? "{" + H.join(",") + U + "}" : "{" + H.join(",") + "}", C = U, B
                        }
                    };
                return str("", {
                    "": m
                })
            }, tl.JSONDecode = (ev = {
                '"': '"',
                "\\": "\\",
                "/": "/",
                b: "\b",
                f: "\f",
                n: "\n",
                r: "\r",
                t: "	"
            }, eb = function(m) {
                var _ = SyntaxError(m);
                throw _.at = em, _.text = ey, _
            }, eS = function(m) {
                return m && m !== eg && eb("Expected '" + m + "' instead of '" + eg + "'"), eg = ey.charAt(em), em += 1, eg
            }, ew = function() {
                var m, _ = "";
                for ("-" === eg && (_ = "-", eS("-")); eg >= "0" && eg <= "9";) _ += eg, eS();
                if ("." === eg)
                    for (_ += "."; eS() && eg >= "0" && eg <= "9";) _ += eg;
                if ("e" === eg || "E" === eg)
                    for (_ += eg, eS(), ("-" === eg || "+" === eg) && (_ += eg, eS()); eg >= "0" && eg <= "9";) _ += eg, eS();
                if (isFinite(m = +_)) return m;
                eb("Bad number")
            }, eE = function() {
                var m, _, C, R = "";
                if ('"' === eg)
                    for (; eS();) {
                        if ('"' === eg) return eS(), R;
                        if ("\\" === eg) {
                            if (eS(), "u" === eg) {
                                for (_ = 0, C = 0; _ < 4 && isFinite(m = parseInt(eS(), 16)); _ += 1) C = 16 * C + m;
                                R += String.fromCharCode(C)
                            } else if ("string" == typeof ev[eg]) R += ev[eg];
                            else break
                        } else R += eg
                    }
                eb("Bad string")
            }, ek = function() {
                for (; eg && eg <= " ";) eS()
            }, ex = function() {
                switch (eg) {
                    case "t":
                        return eS("t"), eS("r"), eS("u"), eS("e"), !0;
                    case "f":
                        return eS("f"), eS("a"), eS("l"), eS("s"), eS("e"), !1;
                    case "n":
                        return eS("n"), eS("u"), eS("l"), eS("l"), null
                }
                eb('Unexpected "' + eg + '"')
            }, eI = function() {
                var m = [];
                if ("[" === eg) {
                    if (eS("["), ek(), "]" === eg) return eS("]"), m;
                    for (; eg;) {
                        if (m.push(e_()), ek(), "]" === eg) return eS("]"), m;
                        eS(","), ek()
                    }
                }
                eb("Bad array")
            }, eO = function() {
                var m, _ = {};
                if ("{" === eg) {
                    if (eS("{"), ek(), "}" === eg) return eS("}"), _;
                    for (; eg;) {
                        if (m = eE(), ek(), eS(":"), Object.hasOwnProperty.call(_, m) && eb('Duplicate key "' + m + '"'), _[m] = e_(), ek(), "}" === eg) return eS("}"), _;
                        eS(","), ek()
                    }
                }
                eb("Bad object")
            }, e_ = function() {
                switch (ek(), eg) {
                    case "{":
                        return eO();
                    case "[":
                        return eI();
                    case '"':
                        return eE();
                    case "-":
                        return ew();
                    default:
                        return eg >= "0" && eg <= "9" ? ew() : ex()
                }
            }, function(m) {
                var _;
                return ey = m, em = 0, eg = " ", _ = e_(), ek(), eg && eb("Syntax error"), _
            }), tl.base64Encode = function(m) {
                var _, C, R, L, B, F = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    U = 0,
                    H = 0,
                    q = "",
                    V = [];
                if (!m) return m;
                m = tl.utf8Encode(m);
                do _ = (B = m.charCodeAt(U++) << 16 | m.charCodeAt(U++) << 8 | m.charCodeAt(U++)) >> 18 & 63, C = B >> 12 & 63, R = B >> 6 & 63, L = 63 & B, V[H++] = F.charAt(_) + F.charAt(C) + F.charAt(R) + F.charAt(L); while (U < m.length);
                switch (q = V.join(""), m.length % 3) {
                    case 1:
                        q = q.slice(0, -2) + "==";
                        break;
                    case 2:
                        q = q.slice(0, -1) + "="
                }
                return q
            }, tl.utf8Encode = function(m) {
                m = (m + "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                var _, C, R, L = "",
                    B = 0;
                for (R = 0, _ = C = 0, B = m.length; R < B; R++) {
                    var F = m.charCodeAt(R),
                        U = null;
                    F < 128 ? C++ : U = F > 127 && F < 2048 ? String.fromCharCode(F >> 6 | 192, 63 & F | 128) : String.fromCharCode(F >> 12 | 224, F >> 6 & 63 | 128, 63 & F | 128), null !== U && (C > _ && (L += m.substring(_, C)), L += U, _ = C = R + 1)
                }
                return C > _ && (L += m.substring(_, m.length)), L
            }, tl.UUID = (eC = function() {
                var m, _ = 1 * new Date;
                if (eP.performance && eP.performance.now) m = eP.performance.now();
                else
                    for (m = 0; _ == 1 * new Date;) m++;
                return _.toString(16) + Math.floor(m).toString(16)
            }, eM = function() {
                var m, _, C = [],
                    R = 0;

                function xor(m, _) {
                    var R, L = 0;
                    for (R = 0; R < _.length; R++) L |= C[R] << 8 * R;
                    return m ^ L
                }
                for (m = 0; m < tr.length; m++) _ = tr.charCodeAt(m), C.unshift(255 & _), C.length >= 4 && (R = xor(R, C), C = []);
                return C.length > 0 && (R = xor(R, C)), R.toString(16)
            }, function() {
                var m = (tt.height * tt.width).toString(16);
                return eC() + "-" + Math.random().toString(16).replace(".", "") + "-" + eM() + "-" + m + "-" + eC()
            });
            var td = ["ahrefsbot", "ahrefssiteaudit", "baiduspider", "bingbot", "bingpreview", "chrome-lighthouse", "facebookexternal", "petalbot", "pinterest", "screaming frog", "yahoo! slurp", "yandexbot", "adsbot-google", "apis-google", "duplexweb-google", "feedfetcher-google", "google favicon", "google web preview", "google-read-aloud", "googlebot", "googleweblight", "mediapartners-google", "storebot-google"];
            tl.isBlockedUA = function(m) {
                var _;
                for (_ = 0, m = m.toLowerCase(); _ < td.length; _++)
                    if (-1 !== m.indexOf(td[_])) return !0;
                return !1
            }, tl.HTTPBuildQuery = function(m, _) {
                var C, R, L = [];
                return tl.isUndefined(_) && (_ = "&"), tl.each(m, function(m, _) {
                    C = encodeURIComponent(m.toString()), R = encodeURIComponent(_), L[L.length] = R + "=" + C
                }), L.join(_)
            }, tl.getQueryParam = function(m, _) {
                var C = "[\\?&]" + (_ = _.replace(/[[]/g, "\\[").replace(/[\]]/g, "\\]")) + "=([^&#]*)",
                    R = new RegExp(C).exec(m);
                if (null === R || R && "string" != typeof R[1] && R[1].length) return "";
                var L = R[1];
                try {
                    L = decodeURIComponent(L)
                } catch (m) {
                    tu.error("Skipping decoding for malformed query param: " + L)
                }
                return L.replace(/\+/g, " ")
            }, tl.cookie = {
                get: function(m) {
                    for (var _ = m + "=", C = e7.cookie.split(";"), R = 0; R < C.length; R++) {
                        for (var L = C[R];
                            " " == L.charAt(0);) L = L.substring(1, L.length);
                        if (0 === L.indexOf(_)) return decodeURIComponent(L.substring(_.length, L.length))
                    }
                    return null
                },
                parse: function(m) {
                    var _;
                    try {
                        _ = tl.JSONDecode(tl.cookie.get(m)) || {}
                    } catch (m) {}
                    return _
                },
                set_seconds: function(m, _, C, R, L, B, F) {
                    var U = "",
                        H = "",
                        q = "";
                    if (F) U = "; domain=" + F;
                    else if (R) {
                        var V = extract_domain(e7.location.hostname);
                        U = V ? "; domain=." + V : ""
                    }
                    if (C) {
                        var X = new Date;
                        X.setTime(X.getTime() + 1e3 * C), H = "; expires=" + X.toGMTString()
                    }
                    B && (L = !0, q = "; SameSite=None"), L && (q += "; secure"), e7.cookie = m + "=" + encodeURIComponent(_) + H + "; path=/" + U + q
                },
                set: function(m, _, C, R, L, B, F) {
                    var U = "",
                        H = "",
                        q = "";
                    if (F) U = "; domain=" + F;
                    else if (R) {
                        var V = extract_domain(e7.location.hostname);
                        U = V ? "; domain=." + V : ""
                    }
                    if (C) {
                        var X = new Date;
                        X.setTime(X.getTime() + 864e5 * C), H = "; expires=" + X.toGMTString()
                    }
                    B && (L = !0, q = "; SameSite=None"), L && (q += "; secure");
                    var K = m + "=" + encodeURIComponent(_) + H + "; path=/" + U + q;
                    return e7.cookie = K, K
                },
                remove: function(m, _, C) {
                    tl.cookie.set(m, "", -1, _, !1, !1, C)
                }
            };
            var tp = null,
                localStorageSupported = function(m, _) {
                    if (null !== tp && !_) return tp;
                    var C = !0;
                    try {
                        m = m || window.localStorage;
                        var R = "__mplss_" + cheap_guid(8);
                        m.setItem(R, "xyz"), "xyz" !== m.getItem(R) && (C = !1), m.removeItem(R)
                    } catch (m) {
                        C = !1
                    }
                    return tp = C, C
                };
            tl.localStorage = {
                is_supported: function(m) {
                    var _ = localStorageSupported(null, m);
                    return _ || tu.error("localStorage unsupported; falling back to cookie store"), _
                },
                error: function(m) {
                    tu.error("localStorage error: " + m)
                },
                get: function(m) {
                    try {
                        return window.localStorage.getItem(m)
                    } catch (m) {
                        tl.localStorage.error(m)
                    }
                    return null
                },
                parse: function(m) {
                    try {
                        return tl.JSONDecode(tl.localStorage.get(m)) || {}
                    } catch (m) {}
                    return null
                },
                set: function(m, _) {
                    try {
                        window.localStorage.setItem(m, _)
                    } catch (m) {
                        tl.localStorage.error(m)
                    }
                },
                remove: function(m) {
                    try {
                        window.localStorage.removeItem(m)
                    } catch (m) {
                        tl.localStorage.error(m)
                    }
                }
            }, tl.register_event = function() {
                function fixEvent(m) {
                    return m && (m.preventDefault = fixEvent.preventDefault, m.stopPropagation = fixEvent.stopPropagation), m
                }
                return fixEvent.preventDefault = function() {
                        this.returnValue = !1
                    }, fixEvent.stopPropagation = function() {
                        this.cancelBubble = !0
                    },
                    function(m, _, C, R, L) {
                        if (!m) {
                            tu.error("No valid element provided to register_event");
                            return
                        }
                        if (m.addEventListener && !R) m.addEventListener(_, C, !!L);
                        else {
                            var B = "on" + _,
                                F = m[B];
                            m[B] = function(_) {
                                if (_ = _ || fixEvent(window.event)) {
                                    var R, L, B = !0;
                                    return tl.isFunction(F) && (R = F(_)), L = C.call(m, _), (!1 === R || !1 === L) && (B = !1), B
                                }
                            }
                        }
                    }
            }();
            var th = RegExp('^(\\w*)\\[(\\w+)([=~\\|\\^\\$\\*]?)=?"?([^\\]"]*)"?\\]$');
            tl.dom_query = function() {
                function getAllChildren(m) {
                    return m.all ? m.all : m.getElementsByTagName("*")
                }
                var m = /[\t\r\n]/g;

                function getElementsBySelector(_) {
                    if (!e7.getElementsByTagName) return [];
                    var C = _.split(" "),
                        R = [e7];
                    for (Y = 0; Y < C.length; Y++) {
                        if ((H = C[Y].replace(/^\s+/, "").replace(/\s+$/, "")).indexOf("#") > -1) {
                            V = (q = H.split("#"))[0];
                            var L = q[1],
                                B = e7.getElementById(L);
                            if (!B || V && B.nodeName.toLowerCase() != V) return [];
                            R = [B];
                            continue
                        }
                        if (H.indexOf(".") > -1) {
                            V = (q = H.split("."))[0];
                            var F = q[1];
                            for (V || (V = "*"), X = [], K = 0, Q = 0; Q < R.length; Q++)
                                for (et = 0, er = "*" == V ? getAllChildren(R[Q]) : R[Q].getElementsByTagName(V); et < er.length; et++) X[K++] = er[et];
                            for (Q = 0, R = [], en = 0; Q < X.length; Q++) X[Q].className && tl.isString(X[Q].className) && (" " + X[Q].className + " ").replace(m, " ").indexOf(" " + F + " ") >= 0 && (R[en++] = X[Q]);
                            continue
                        }
                        var U = H.match(th);
                        if (U) {
                            V = U[1];
                            var H, q, V, X, K, Y, Q, et, er, en, ei, eo = U[2],
                                ea = U[3],
                                es = U[4];
                            for (V || (V = "*"), X = [], K = 0, Q = 0; Q < R.length; Q++)
                                for (et = 0, er = "*" == V ? getAllChildren(R[Q]) : R[Q].getElementsByTagName(V); et < er.length; et++) X[K++] = er[et];
                            switch (R = [], en = 0, ea) {
                                case "=":
                                    ei = function(m) {
                                        return m.getAttribute(eo) == es
                                    };
                                    break;
                                case "~":
                                    ei = function(m) {
                                        return m.getAttribute(eo).match(RegExp("\\b" + es + "\\b"))
                                    };
                                    break;
                                case "|":
                                    ei = function(m) {
                                        return m.getAttribute(eo).match(RegExp("^" + es + "-?"))
                                    };
                                    break;
                                case "^":
                                    ei = function(m) {
                                        return 0 === m.getAttribute(eo).indexOf(es)
                                    };
                                    break;
                                case "$":
                                    ei = function(m) {
                                        return m.getAttribute(eo).lastIndexOf(es) == m.getAttribute(eo).length - es.length
                                    };
                                    break;
                                case "*":
                                    ei = function(m) {
                                        return m.getAttribute(eo).indexOf(es) > -1
                                    };
                                    break;
                                default:
                                    ei = function(m) {
                                        return m.getAttribute(eo)
                                    }
                            }
                            for (Q = 0, R = [], en = 0; Q < X.length; Q++) ei(X[Q]) && (R[en++] = X[Q]);
                            continue
                        }
                        for (Q = 0, V = H, X = [], K = 0; Q < R.length; Q++)
                            for (et = 0, er = R[Q].getElementsByTagName(V); et < er.length; et++) X[K++] = er[et];
                        R = X
                    }
                    return R
                }
                return function(m) {
                    return tl.isElement(m) ? [m] : tl.isObject(m) && !tl.isUndefined(m.length) ? m : getElementsBySelector.call(this, m)
                }
            }();
            var tf = ["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term", "utm_id", "utm_source_platform", "utm_campaign_id", "utm_creative_format", "utm_marketing_tactic"],
                tm = ["dclid", "fbclid", "gclid", "ko_click_id", "li_fat_id", "msclkid", "sccid", "ttclid", "twclid", "wbraid"];
            tl.info = {
                campaignParams: function(m) {
                    var _ = "",
                        C = {};
                    return tl.each(tf, function(R) {
                        (_ = tl.getQueryParam(e7.URL, R)).length ? C[R] = _ : void 0 !== m && (C[R] = m)
                    }), C
                },
                clickParams: function() {
                    var m = "",
                        _ = {};
                    return tl.each(tm, function(C) {
                        (m = tl.getQueryParam(e7.URL, C)).length && (_[C] = m)
                    }), _
                },
                marketingParams: function() {
                    return tl.extend(tl.info.campaignParams(), tl.info.clickParams())
                },
                searchEngine: function(m) {
                    return 0 === m.search("https?://(.*)google.([^/?]*)") ? "google" : 0 === m.search("https?://(.*)bing.com") ? "bing" : 0 === m.search("https?://(.*)yahoo.com") ? "yahoo" : 0 === m.search("https?://(.*)duckduckgo.com") ? "duckduckgo" : null
                },
                searchInfo: function(m) {
                    var _ = tl.info.searchEngine(m),
                        C = {};
                    if (null !== _) {
                        C.$search_engine = _;
                        var R = tl.getQueryParam(m, "yahoo" != _ ? "q" : "p");
                        R.length && (C.mp_keyword = R)
                    }
                    return C
                },
                browser: function(m, _, C) {
                    if (_ = _ || "", C || tl.includes(m, " OPR/")) return tl.includes(m, "Mini") ? "Opera Mini" : "Opera";
                    if (/(BlackBerry|PlayBook|BB10)/i.test(m)) return "BlackBerry";
                    if (tl.includes(m, "IEMobile") || tl.includes(m, "WPDesktop")) return "Internet Explorer Mobile";
                    if (tl.includes(m, "SamsungBrowser/")) return "Samsung Internet";
                    if (tl.includes(m, "Edge") || tl.includes(m, "Edg/")) return "Microsoft Edge";
                    if (tl.includes(m, "FBIOS")) return "Facebook Mobile";
                    if (tl.includes(m, "Chrome")) return "Chrome";
                    else if (tl.includes(m, "CriOS")) return "Chrome iOS";
                    else if (tl.includes(m, "UCWEB") || tl.includes(m, "UCBrowser")) return "UC Browser";
                    else if (tl.includes(m, "FxiOS")) return "Firefox iOS";
                    else if (tl.includes(_, "Apple")) return tl.includes(m, "Mobile") ? "Mobile Safari" : "Safari";
                    else if (tl.includes(m, "Android")) return "Android Mobile";
                    else if (tl.includes(m, "Konqueror")) return "Konqueror";
                    else if (tl.includes(m, "Firefox")) return "Firefox";
                    else if (tl.includes(m, "MSIE") || tl.includes(m, "Trident/")) return "Internet Explorer";
                    else if (tl.includes(m, "Gecko")) return "Mozilla";
                    else return ""
                },
                browserVersion: function(m, _, C) {
                    var R = {
                        "Internet Explorer Mobile": /rv:(\d+(\.\d+)?)/,
                        "Microsoft Edge": /Edge?\/(\d+(\.\d+)?)/,
                        Chrome: /Chrome\/(\d+(\.\d+)?)/,
                        "Chrome iOS": /CriOS\/(\d+(\.\d+)?)/,
                        "UC Browser": /(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/,
                        Safari: /Version\/(\d+(\.\d+)?)/,
                        "Mobile Safari": /Version\/(\d+(\.\d+)?)/,
                        Opera: /(Opera|OPR)\/(\d+(\.\d+)?)/,
                        Firefox: /Firefox\/(\d+(\.\d+)?)/,
                        "Firefox iOS": /FxiOS\/(\d+(\.\d+)?)/,
                        Konqueror: /Konqueror:(\d+(\.\d+)?)/,
                        BlackBerry: /BlackBerry (\d+(\.\d+)?)/,
                        "Android Mobile": /android\s(\d+(\.\d+)?)/,
                        "Samsung Internet": /SamsungBrowser\/(\d+(\.\d+)?)/,
                        "Internet Explorer": /(rv:|MSIE )(\d+(\.\d+)?)/,
                        Mozilla: /rv:(\d+(\.\d+)?)/
                    }[tl.info.browser(m, _, C)];
                    if (void 0 === R) return null;
                    var L = m.match(R);
                    return L ? parseFloat(L[L.length - 2]) : null
                },
                os: function() {
                    if (/Windows/i.test(tr)) return /Phone/.test(tr) || /WPDesktop/.test(tr) ? "Windows Phone" : "Windows";
                    if (/(iPhone|iPad|iPod)/.test(tr)) return "iOS";
                    if (/Android/.test(tr)) return "Android";
                    if (/(BlackBerry|PlayBook|BB10)/i.test(tr)) return "BlackBerry";
                    if (/Mac/i.test(tr)) return "Mac OS X";
                    if (/Linux/.test(tr)) return "Linux";
                    if (/CrOS/.test(tr)) return "Chrome OS";
                    else return ""
                },
                device: function(m) {
                    return /Windows Phone/i.test(m) || /WPDesktop/.test(m) ? "Windows Phone" : /iPad/.test(m) ? "iPad" : /iPod/.test(m) ? "iPod Touch" : /iPhone/.test(m) ? "iPhone" : /(BlackBerry|PlayBook|BB10)/i.test(m) ? "BlackBerry" : /Android/.test(m) ? "Android" : ""
                },
                referringDomain: function(m) {
                    var _ = m.split("/");
                    return _.length >= 3 ? _[2] : ""
                },
                currentUrl: function() {
                    return eP.location.href
                },
                properties: function(m) {
                    return "object" != typeof m && (m = {}), tl.extend(tl.strip_empty_properties({
                        $os: tl.info.os(),
                        $browser: tl.info.browser(tr, e9.vendor, te),
                        $referrer: e7.referrer,
                        $referring_domain: tl.info.referringDomain(e7.referrer),
                        $device: tl.info.device(tr)
                    }), {
                        $current_url: tl.info.currentUrl(),
                        $browser_version: tl.info.browserVersion(tr, e9.vendor, te),
                        $screen_height: tt.height,
                        $screen_width: tt.width,
                        mp_lib: "web",
                        $lib_version: eQ.LIB_VERSION,
                        $insert_id: cheap_guid(),
                        time: tl.timestamp() / 1e3
                    }, tl.strip_empty_properties(m))
                },
                people_properties: function() {
                    return tl.extend(tl.strip_empty_properties({
                        $os: tl.info.os(),
                        $browser: tl.info.browser(tr, e9.vendor, te)
                    }), {
                        $browser_version: tl.info.browserVersion(tr, e9.vendor, te)
                    })
                },
                mpPageViewProperties: function() {
                    return tl.strip_empty_properties({
                        current_page_title: e7.title,
                        current_domain: eP.location.hostname,
                        current_url_path: eP.location.pathname,
                        current_url_protocol: eP.location.protocol,
                        current_url_search: eP.location.search
                    })
                }
            };
            var cheap_guid = function(m) {
                    var _ = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);
                    return m ? _.substring(0, m) : _
                },
                tg = /[a-z0-9][a-z0-9-]*\.[a-z]+$/i,
                ty = /[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i,
                extract_domain = function(m) {
                    var _ = ty,
                        C = m.split("."),
                        R = C[C.length - 1];
                    (R.length > 4 || "com" === R || "org" === R) && (_ = tg);
                    var L = m.match(_);
                    return L ? L[0] : ""
                },
                isOnline = function() {
                    var m = eP.navigator.onLine;
                    return tl.isUndefined(m) || m
                },
                t_ = null,
                tv = null;

            function optIn(m, _) {
                _optInOut(!0, m, _)
            }

            function optOut(m, _) {
                _optInOut(!1, m, _)
            }

            function hasOptedIn(m, _) {
                return "1" === _getStorageValue(m, _)
            }

            function hasOptedOut(m, _) {
                if (function(m) {
                        if (m && m.ignoreDnt) return !1;
                        var _ = m && m.window || eP,
                            C = _.navigator || {},
                            R = !1;
                        return tl.each([C.doNotTrack, C.msDoNotTrack, _.doNotTrack], function(m) {
                            tl.includes([!0, 1, "1", "yes"], m) && (R = !0)
                        }), R
                    }(_)) return tu.warn('This browser has "Do Not Track" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the "Do Not Track" browser setting, initialize the Mixpanel instance with the config "ignore_dnt: true"'), !0;
                var C = "0" === _getStorageValue(m, _);
                return C && tu.warn("You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data."), C
            }

            function addOptOutCheckMixpanelLib(m) {
                return _addOptOutCheck(m, function(m) {
                    return this.get_config(m)
                })
            }

            function addOptOutCheckMixpanelPeople(m) {
                return _addOptOutCheck(m, function(m) {
                    return this._get_config(m)
                })
            }

            function addOptOutCheckMixpanelGroup(m) {
                return _addOptOutCheck(m, function(m) {
                    return this._get_config(m)
                })
            }

            function clearOptInOut(m, _) {
                _getStorage(_ = _ || {}).remove(_getStorageKey(m, _), !!_.crossSubdomainCookie, _.cookieDomain)
            }

            function _getStorage(m) {
                return "localStorage" === (m = m || {}).persistenceType ? tl.localStorage : tl.cookie
            }

            function _getStorageKey(m, _) {
                return ((_ = _ || {}).persistencePrefix || "__mp_opt_in_out_") + m
            }

            function _getStorageValue(m, _) {
                return _getStorage(_).get(_getStorageKey(m, _))
            }

            function _optInOut(m, _, C) {
                if (!tl.isString(_) || !_.length) {
                    tu.error("gdpr." + (m ? "optIn" : "optOut") + " called with an invalid token");
                    return
                }
                _getStorage(C = C || {}).set(_getStorageKey(_, C), m ? 1 : 0, tl.isNumber(C.cookieExpiration) ? C.cookieExpiration : null, !!C.crossSubdomainCookie, !!C.secureCookie, !!C.crossSiteCookie, C.cookieDomain), C.track && m && C.track(C.trackEventName || "$opt_in", C.trackProperties, {
                    send_immediately: !0
                })
            }

            function _addOptOutCheck(m, _) {
                return function() {
                    var C = !1;
                    try {
                        var R = _.call(this, "token"),
                            L = _.call(this, "ignore_dnt"),
                            B = _.call(this, "opt_out_tracking_persistence_type"),
                            F = _.call(this, "opt_out_tracking_cookie_prefix"),
                            U = _.call(this, "window");
                        R && (C = hasOptedOut(R, {
                            ignoreDnt: L,
                            persistenceType: B,
                            persistencePrefix: F,
                            window: U
                        }))
                    } catch (m) {
                        tu.error("Unexpected error when checking tracking opt-out status: " + m)
                    }
                    if (!C) return m.apply(this, arguments);
                    var H = arguments[arguments.length - 1];
                    "function" == typeof H && H(0)
                }
            }
            "undefined" != typeof JSON && (t_ = JSON.stringify, tv = JSON.parse), t_ = t_ || tl.JSONEncode, tv = tv || tl.JSONDecode, tl.toArray = tl.toArray, tl.isObject = tl.isObject, tl.JSONEncode = tl.JSONEncode, tl.JSONDecode = tl.JSONDecode, tl.isBlockedUA = tl.isBlockedUA, tl.isEmptyObject = tl.isEmptyObject, tl.info = tl.info, tl.info.device = tl.info.device, tl.info.browser = tl.info.browser, tl.info.browserVersion = tl.info.browserVersion, tl.info.properties = tl.info.properties;
            var tb = console_with_prefix("lock"),
                SharedLock = function(m, _) {
                    _ = _ || {}, this.storageKey = m, this.storage = _.storage || window.localStorage, this.pollIntervalMS = _.pollIntervalMS || 100, this.timeoutMS = _.timeoutMS || 2e3
                };
            SharedLock.prototype.withLock = function(m, _, C) {
                C || "function" == typeof _ || (C = _, _ = null);
                var R = C || new Date().getTime() + "|" + Math.random(),
                    L = new Date().getTime(),
                    B = this.storageKey,
                    F = this.pollIntervalMS,
                    U = this.timeoutMS,
                    H = this.storage,
                    q = B + ":X",
                    V = B + ":Y",
                    X = B + ":Z",
                    reportError = function(m) {
                        _ && _(m)
                    },
                    delay = function(m) {
                        if (new Date().getTime() - L > U) {
                            tb.error("Timeout waiting for mutex on " + B + "; clearing lock. [" + R + "]"), H.removeItem(X), H.removeItem(V), loop();
                            return
                        }
                        setTimeout(function() {
                            try {
                                m()
                            } catch (m) {
                                reportError(m)
                            }
                        }, F * (Math.random() + .1))
                    },
                    waitFor = function(m, _) {
                        m() ? _() : delay(function() {
                            waitFor(m, _)
                        })
                    },
                    getSetY = function() {
                        var m = H.getItem(V);
                        if (m && m !== R) return !1;
                        if (H.setItem(V, R), H.getItem(V) === R) return !0;
                        if (!localStorageSupported(H, !0)) throw Error("localStorage support dropped while acquiring lock");
                        return !1
                    },
                    loop = function() {
                        H.setItem(q, R), waitFor(getSetY, function() {
                            if (H.getItem(q) === R) {
                                criticalSection();
                                return
                            }
                            delay(function() {
                                if (H.getItem(V) !== R) {
                                    loop();
                                    return
                                }
                                waitFor(function() {
                                    return !H.getItem(X)
                                }, criticalSection)
                            })
                        })
                    },
                    criticalSection = function() {
                        H.setItem(X, "1");
                        try {
                            m()
                        } finally {
                            H.removeItem(X), H.getItem(V) === R && H.removeItem(V), H.getItem(q) === R && H.removeItem(q)
                        }
                    };
                try {
                    if (localStorageSupported(H, !0)) loop();
                    else throw Error("localStorage support check failed")
                } catch (m) {
                    reportError(m)
                }
            };
            var tS = console_with_prefix("batch"),
                RequestQueue = function(m, _) {
                    _ = _ || {}, this.storageKey = m, this.storage = _.storage || window.localStorage, this.reportError = _.errorReporter || tl.bind(tS.error, tS), this.lock = new SharedLock(m, {
                        storage: this.storage
                    }), this.usePersistence = _.usePersistence, this.pid = _.pid || null, this.memQueue = []
                };
            RequestQueue.prototype.enqueue = function(m, _, C) {
                var R = {
                    id: cheap_guid(),
                    flushAfter: new Date().getTime() + 2 * _,
                    payload: m
                };
                this.usePersistence ? this.lock.withLock(tl.bind(function() {
                    var _;
                    try {
                        var L = this.readFromStorage();
                        L.push(R), (_ = this.saveToStorage(L)) && this.memQueue.push(R)
                    } catch (C) {
                        this.reportError("Error enqueueing item", m), _ = !1
                    }
                    C && C(_)
                }, this), tl.bind(function(m) {
                    this.reportError("Error acquiring storage lock", m), C && C(!1)
                }, this), this.pid) : (this.memQueue.push(R), C && C(!0))
            }, RequestQueue.prototype.fillBatch = function(m) {
                var _ = this.memQueue.slice(0, m);
                if (this.usePersistence && _.length < m) {
                    var C = this.readFromStorage();
                    if (C.length) {
                        var R = {};
                        tl.each(_, function(m) {
                            R[m.id] = !0
                        });
                        for (var L = 0; L < C.length; L++) {
                            var B = C[L];
                            if (new Date().getTime() > B.flushAfter && !R[B.id] && (B.orphaned = !0, _.push(B), _.length >= m)) break
                        }
                    }
                }
                return _
            };
            var filterOutIDsAndInvalid = function(m, _) {
                var C = [];
                return tl.each(m, function(m) {
                    m.id && !_[m.id] && C.push(m)
                }), C
            };
            RequestQueue.prototype.removeItemsByID = function(m, _) {
                var C = {};
                if (tl.each(m, function(m) {
                        C[m] = !0
                    }), this.memQueue = filterOutIDsAndInvalid(this.memQueue, C), this.usePersistence) {
                    var R = tl.bind(function() {
                        var _;
                        try {
                            var R = this.readFromStorage();
                            if (R = filterOutIDsAndInvalid(R, C), _ = this.saveToStorage(R)) {
                                R = this.readFromStorage();
                                for (var L = 0; L < R.length; L++) {
                                    var B = R[L];
                                    if (B.id && C[B.id]) return this.reportError("Item not removed from storage"), !1
                                }
                            }
                        } catch (C) {
                            this.reportError("Error removing items", m), _ = !1
                        }
                        return _
                    }, this);
                    this.lock.withLock(function() {
                        var m = R();
                        _ && _(m)
                    }, tl.bind(function(m) {
                        var C = !1;
                        if (this.reportError("Error acquiring storage lock", m), !localStorageSupported(this.storage, !0) && !(C = R())) try {
                            this.storage.removeItem(this.storageKey)
                        } catch (m) {
                            this.reportError("Error clearing queue", m)
                        }
                        _ && _(C)
                    }, this), this.pid)
                } else _ && _(!0)
            };
            var updatePayloads = function(m, _) {
                var C = [];
                return tl.each(m, function(m) {
                    var R = m.id;
                    if (R in _) {
                        var L = _[R];
                        null !== L && (m.payload = L, C.push(m))
                    } else C.push(m)
                }), C
            };
            RequestQueue.prototype.updatePayloads = function(m, _) {
                this.memQueue = updatePayloads(this.memQueue, m), this.usePersistence ? this.lock.withLock(tl.bind(function() {
                    var C;
                    try {
                        var R = this.readFromStorage();
                        R = updatePayloads(R, m), C = this.saveToStorage(R)
                    } catch (_) {
                        this.reportError("Error updating items", m), C = !1
                    }
                    _ && _(C)
                }, this), tl.bind(function(m) {
                    this.reportError("Error acquiring storage lock", m), _ && _(!1)
                }, this), this.pid) : _ && _(!0)
            }, RequestQueue.prototype.readFromStorage = function() {
                var m;
                try {
                    (m = this.storage.getItem(this.storageKey)) && (m = tv(m), tl.isArray(m) || (this.reportError("Invalid storage entry:", m), m = null))
                } catch (_) {
                    this.reportError("Error retrieving queue", _), m = null
                }
                return m || []
            }, RequestQueue.prototype.saveToStorage = function(m) {
                try {
                    return this.storage.setItem(this.storageKey, t_(m)), !0
                } catch (m) {
                    return this.reportError("Error saving queue", m), !1
                }
            }, RequestQueue.prototype.clear = function() {
                this.memQueue = [], this.usePersistence && this.storage.removeItem(this.storageKey)
            };
            var tw = console_with_prefix("batch"),
                RequestBatcher = function(m, _) {
                    this.errorReporter = _.errorReporter, this.queue = new RequestQueue(m, {
                        errorReporter: tl.bind(this.reportError, this),
                        storage: _.storage,
                        usePersistence: _.usePersistence
                    }), this.libConfig = _.libConfig, this.sendRequest = _.sendRequestFunc, this.beforeSendHook = _.beforeSendHook, this.stopAllBatching = _.stopAllBatchingFunc, this.batchSize = this.libConfig.batch_size, this.flushInterval = this.libConfig.batch_flush_interval_ms, this.stopped = !this.libConfig.batch_autostart, this.consecutiveRemovalFailures = 0, this.itemIdsSentSuccessfully = {}, this.flushOnlyOnInterval = _.flushOnlyOnInterval || !1
                };
            RequestBatcher.prototype.enqueue = function(m, _) {
                this.queue.enqueue(m, this.flushInterval, _)
            }, RequestBatcher.prototype.start = function() {
                this.stopped = !1, this.consecutiveRemovalFailures = 0, this.flush()
            }, RequestBatcher.prototype.stop = function() {
                this.stopped = !0, this.timeoutID && (clearTimeout(this.timeoutID), this.timeoutID = null)
            }, RequestBatcher.prototype.clear = function() {
                this.queue.clear()
            }, RequestBatcher.prototype.resetBatchSize = function() {
                this.batchSize = this.libConfig.batch_size
            }, RequestBatcher.prototype.resetFlush = function() {
                this.scheduleFlush(this.libConfig.batch_flush_interval_ms)
            }, RequestBatcher.prototype.scheduleFlush = function(m) {
                this.flushInterval = m, this.stopped || (this.timeoutID = setTimeout(tl.bind(function() {
                    this.stopped || this.flush()
                }, this), this.flushInterval))
            }, RequestBatcher.prototype.flush = function(m) {
                try {
                    if (this.requestInProgress) {
                        tw.log("Flush: Request already in progress");
                        return
                    }
                    m = m || {};
                    var _ = this.libConfig.batch_request_timeout_ms,
                        C = new Date().getTime(),
                        R = this.batchSize,
                        L = this.queue.fillBatch(R),
                        B = L.length === R,
                        F = [],
                        U = {};
                    if (tl.each(L, function(m) {
                            var _ = m.payload;
                            if (this.beforeSendHook && !m.orphaned && (_ = this.beforeSendHook(_)), _) {
                                _.event && _.properties && (_.properties = tl.extend({}, _.properties, {
                                    mp_sent_by_lib_version: eQ.LIB_VERSION
                                }));
                                var C = !0,
                                    R = m.id;
                                R ? (this.itemIdsSentSuccessfully[R] || 0) > 5 && (this.reportError("[dupe] item ID sent too many times, not sending", {
                                    item: m,
                                    batchSize: L.length,
                                    timesSent: this.itemIdsSentSuccessfully[R]
                                }), C = !1) : this.reportError("[dupe] found item with no ID", {
                                    item: m
                                }), C && F.push(_)
                            }
                            U[m.id] = _
                        }, this), F.length < 1) {
                        this.resetFlush();
                        return
                    }
                    this.requestInProgress = !0;
                    var H = tl.bind(function(F) {
                            this.requestInProgress = !1;
                            try {
                                var H = !1;
                                if (m.unloading) this.queue.updatePayloads(U);
                                else if (tl.isObject(F) && "timeout" === F.error && new Date().getTime() - C >= _) this.reportError("Network timeout; retrying"), this.flush();
                                else if (tl.isObject(F) && (F.httpStatusCode >= 500 || 429 === F.httpStatusCode || F.httpStatusCode <= 0 && !isOnline() || "timeout" === F.error)) {
                                    var q = 2 * this.flushInterval;
                                    F.retryAfter && (q = 1e3 * parseInt(F.retryAfter, 10) || q), q = Math.min(6e5, q), this.reportError("Error; retry in " + q + " ms"), this.scheduleFlush(q)
                                } else if (tl.isObject(F) && 413 === F.httpStatusCode) {
                                    if (L.length > 1) {
                                        var V = Math.max(1, Math.floor(R / 2));
                                        this.batchSize = Math.min(this.batchSize, V, L.length - 1), this.reportError("413 response; reducing batch size to " + this.batchSize), this.resetFlush()
                                    } else this.reportError("Single-event request too large; dropping", L), this.resetBatchSize(), H = !0
                                } else H = !0;
                                H && (this.queue.removeItemsByID(tl.map(L, function(m) {
                                    return m.id
                                }), tl.bind(function(m) {
                                    m ? (this.consecutiveRemovalFailures = 0, this.flushOnlyOnInterval && !B ? this.resetFlush() : this.flush()) : (this.reportError("Failed to remove items from queue"), ++this.consecutiveRemovalFailures > 5 ? (this.reportError("Too many queue failures; disabling batching system."), this.stopAllBatching()) : this.resetFlush())
                                }, this)), tl.each(L, tl.bind(function(m) {
                                    var _ = m.id;
                                    _ ? (this.itemIdsSentSuccessfully[_] = this.itemIdsSentSuccessfully[_] || 0, this.itemIdsSentSuccessfully[_]++, this.itemIdsSentSuccessfully[_] > 5 && this.reportError("[dupe] item ID sent too many times", {
                                        item: m,
                                        batchSize: L.length,
                                        timesSent: this.itemIdsSentSuccessfully[_]
                                    })) : this.reportError("[dupe] found item with no ID while removing", {
                                        item: m
                                    })
                                }, this)))
                            } catch (m) {
                                this.reportError("Error handling API response", m), this.resetFlush()
                            }
                        }, this),
                        q = {
                            method: "POST",
                            verbose: !0,
                            ignore_json_errors: !0,
                            timeout_ms: _
                        };
                    m.unloading && (q.transport = "sendBeacon"), tw.log("MIXPANEL REQUEST:", F), this.sendRequest(F, q, H)
                } catch (m) {
                    this.reportError("Error flushing request queue", m), this.resetFlush()
                }
            }, RequestBatcher.prototype.reportError = function(m, _) {
                if (tw.error.apply(tw.error, arguments), this.errorReporter) try {
                    _ instanceof Error || (_ = Error(m)), this.errorReporter(m, _)
                } catch (m) {
                    tw.error(m)
                }
            };
            var tE = console_with_prefix("recorder"),
                tk = eP.CompressionStream,
                tx = {
                    batch_size: 1e3,
                    batch_flush_interval_ms: 1e4,
                    batch_request_timeout_ms: 9e4,
                    batch_autostart: !0
                },
                tI = new Set([eY.MouseMove, eY.MouseInteraction, eY.Scroll, eY.ViewportResize, eY.Input, eY.TouchMove, eY.MediaInteraction, eY.Drag, eY.Selection]),
                MixpanelRecorder = function(m) {
                    this._mixpanel = m, this._stopRecording = null, this.recEvents = [], this.seqNo = 0, this.replayId = null, this.replayStartTime = null, this.sendBatchId = null, this.idleTimeoutId = null, this.maxTimeoutId = null, this.recordMaxMs = 864e5, this.recordMinMs = 0, this._initBatcher()
                };
            MixpanelRecorder.prototype._initBatcher = function() {
                this.batcher = new RequestBatcher("__mprec", {
                    libConfig: tx,
                    sendRequestFunc: tl.bind(this.flushEventsWithOptOut, this),
                    errorReporter: tl.bind(this.reportError, this),
                    flushOnlyOnInterval: !0,
                    usePersistence: !1
                })
            }, MixpanelRecorder.prototype.get_config = function(m) {
                return this._mixpanel.get_config(m)
            }, MixpanelRecorder.prototype.startRecording = function(m) {
                if (null !== this._stopRecording) {
                    tE.log("Recording already in progress, skipping startRecording.");
                    return
                }
                this.recordMaxMs = this.get_config("record_max_ms"), this.recordMaxMs > 864e5 && (this.recordMaxMs = 864e5, tE.critical("record_max_ms cannot be greater than 86400000ms. Capping value.")), this.recordMinMs = this.get_config("record_min_ms"), this.recordMinMs > 8e3 && (this.recordMinMs = 8e3, tE.critical("record_min_ms cannot be greater than 8000ms. Capping value.")), this.recEvents = [], this.seqNo = 0, this.replayStartTime = new Date().getTime(), this.replayId = tl.UUID(), m || this.recordMinMs > 0 ? this.batcher.stop() : this.batcher.start();
                var _ = tl.bind(function() {
                        clearTimeout(this.idleTimeoutId), this.idleTimeoutId = setTimeout(tl.bind(function() {
                            tE.log("Idle timeout reached, restarting recording."), this.resetRecording()
                        }, this), this.get_config("record_idle_timeout_ms"))
                    }, this),
                    C = this.get_config("record_block_selector");
                ("" === C || null === C) && (C = void 0), this._stopRecording = record({
                    emit: tl.bind(function(m) {
                        this.batcher.enqueue(m), m.type === eZ.IncrementalSnapshot && tI.has(m.data.source) && (this.batcher.stopped && new Date().getTime() - this.replayStartTime >= this.recordMinMs && this.batcher.start(), _())
                    }, this),
                    blockClass: this.get_config("record_block_class"),
                    blockSelector: C,
                    collectFonts: this.get_config("record_collect_fonts"),
                    inlineImages: this.get_config("record_inline_images"),
                    maskAllInputs: !0,
                    maskTextClass: this.get_config("record_mask_text_class"),
                    maskTextSelector: this.get_config("record_mask_text_selector")
                }), _(), this.maxTimeoutId = setTimeout(tl.bind(this.resetRecording, this), this.recordMaxMs)
            }, MixpanelRecorder.prototype.resetRecording = function() {
                this.stopRecording(), this.startRecording(!0)
            }, MixpanelRecorder.prototype.stopRecording = function() {
                null !== this._stopRecording && (this._stopRecording(), this._stopRecording = null), this.batcher.stopped ? this.batcher.clear() : (this.batcher.flush(), this.batcher.stop()), this.replayId = null, clearTimeout(this.idleTimeoutId), clearTimeout(this.maxTimeoutId)
            }, MixpanelRecorder.prototype.flushEventsWithOptOut = function(m, _, C) {
                this._flushEvents(m, _, C, tl.bind(this._onOptOut, this))
            }, MixpanelRecorder.prototype._onOptOut = function(m) {
                0 === m && (this.recEvents = [], this.stopRecording())
            }, MixpanelRecorder.prototype._sendRequest = function(m, _, C, R) {
                var L = tl.bind(function(_, C) {
                    200 === _.status && this.replayId === m && this.seqNo++, R({
                        status: 0,
                        httpStatusCode: _.status,
                        responseBody: C,
                        retryAfter: _.headers.get("Retry-After")
                    })
                }, this);
                eP.fetch(this.get_config("api_host") + "/" + this.get_config("api_routes").record + "?" + new URLSearchParams(_), {
                    method: "POST",
                    headers: {
                        Authorization: "Basic " + btoa(this.get_config("token") + ":"),
                        "Content-Type": "application/octet-stream"
                    },
                    body: C
                }).then(function(m) {
                    m.json().then(function(_) {
                        L(m, _)
                    }).catch(function(m) {
                        R({
                            error: m
                        })
                    })
                }).catch(function(m) {
                    R({
                        error: m,
                        httpStatusCode: 0
                    })
                })
            }, MixpanelRecorder.prototype._flushEvents = addOptOutCheckMixpanelLib(function(m, _, C) {
                let R = m.length;
                if (R > 0) {
                    var L = this.replayId,
                        B = m[0].timestamp;
                    0 !== this.seqNo && this.replayStartTime || (0 !== this.seqNo && this.reportError("Replay start time not set but seqNo is not 0. Using current batch start time as a fallback."), this.replayStartTime = B);
                    var F = m[R - 1].timestamp - this.replayStartTime,
                        U = {
                            distinct_id: String(this._mixpanel.get_distinct_id()),
                            seq: this.seqNo,
                            batch_start_time: B / 1e3,
                            replay_id: L,
                            replay_length_ms: F,
                            replay_start_time: this.replayStartTime / 1e3
                        },
                        H = tl.JSONEncode(m),
                        q = this._mixpanel.get_property("$device_id");
                    q && (U.$device_id = q);
                    var V = this._mixpanel.get_property("$user_id");
                    if (V && (U.$user_id = V), tk) {
                        var X = new Blob([H], {
                            type: "application/json"
                        }).stream().pipeThrough(new tk("gzip"));
                        new Response(X).blob().then(tl.bind(function(m) {
                            U.format = "gzip", this._sendRequest(L, U, m, C)
                        }, this))
                    } else U.format = "body", this._sendRequest(L, U, H, C)
                }
            }), MixpanelRecorder.prototype.reportError = function(m, _) {
                tE.error.apply(tE.error, arguments);
                try {
                    _ || m instanceof Error || (m = Error(m)), this.get_config("error_reporter")(m, _)
                } catch (m) {
                    tE.error(m)
                }
            }, eP.__mp_recorder = MixpanelRecorder;
            var DomTracker = function() {};
            DomTracker.prototype.create_properties = function() {}, DomTracker.prototype.event_handler = function() {}, DomTracker.prototype.after_track_handler = function() {}, DomTracker.prototype.init = function(m) {
                return this.mp = m, this
            }, DomTracker.prototype.track = function(m, _, C, R) {
                var L = this,
                    B = tl.dom_query(m);
                if (0 === B.length) {
                    tu.error("The DOM query (" + m + ") returned 0 elements");
                    return
                }
                return tl.each(B, function(m) {
                    tl.register_event(m, this.override_event, function(m) {
                        var B = {},
                            F = L.create_properties(C, this),
                            U = L.mp.get_config("track_links_timeout");
                        L.event_handler(m, this, B), window.setTimeout(L.track_callback(R, F, B, !0), U), L.mp.track(_, F, L.track_callback(R, F, B))
                    })
                }, this), !0
            }, DomTracker.prototype.track_callback = function(m, _, C, R) {
                R = R || !1;
                var L = this;
                return function() {
                    !C.callback_fired && (C.callback_fired = !0, m && !1 === m(R, _) || L.after_track_handler(_, C, R))
                }
            }, DomTracker.prototype.create_properties = function(m, _) {
                return "function" == typeof m ? m(_) : tl.extend({}, m)
            };
            var LinkTracker = function() {
                this.override_event = "click"
            };
            tl.inherit(LinkTracker, DomTracker), LinkTracker.prototype.create_properties = function(m, _) {
                var C = LinkTracker.superclass.create_properties.apply(this, arguments);
                return _.href && (C.url = _.href), C
            }, LinkTracker.prototype.event_handler = function(m, _, C) {
                C.new_tab = 2 === m.which || m.metaKey || m.ctrlKey || "_blank" === _.target, C.href = _.href, C.new_tab || m.preventDefault()
            }, LinkTracker.prototype.after_track_handler = function(m, _) {
                _.new_tab || setTimeout(function() {
                    window.location = _.href
                }, 0)
            };
            var FormTracker = function() {
                this.override_event = "submit"
            };
            tl.inherit(FormTracker, DomTracker), FormTracker.prototype.event_handler = function(m, _, C) {
                C.element = _, m.preventDefault()
            }, FormTracker.prototype.after_track_handler = function(m, _) {
                setTimeout(function() {
                    _.element.submit()
                }, 0)
            };
            var tO = "$set",
                tC = "$set_once",
                tM = "$unset",
                tT = "$add",
                tA = "$append",
                tR = "$union",
                tP = "$remove",
                tD = {
                    set_action: function(m, _) {
                        var C = {},
                            R = {};
                        return tl.isObject(m) ? tl.each(m, function(m, _) {
                            this._is_reserved_property(_) || (R[_] = m)
                        }, this) : R[m] = _, C[tO] = R, C
                    },
                    unset_action: function(m) {
                        var _ = {},
                            C = [];
                        return tl.isArray(m) || (m = [m]), tl.each(m, function(m) {
                            this._is_reserved_property(m) || C.push(m)
                        }, this), _[tM] = C, _
                    },
                    set_once_action: function(m, _) {
                        var C = {},
                            R = {};
                        return tl.isObject(m) ? tl.each(m, function(m, _) {
                            this._is_reserved_property(_) || (R[_] = m)
                        }, this) : R[m] = _, C[tC] = R, C
                    },
                    union_action: function(m, _) {
                        var C = {},
                            R = {};
                        return tl.isObject(m) ? tl.each(m, function(m, _) {
                            this._is_reserved_property(_) || (R[_] = tl.isArray(m) ? m : [m])
                        }, this) : R[m] = tl.isArray(_) ? _ : [_], C[tR] = R, C
                    },
                    append_action: function(m, _) {
                        var C = {},
                            R = {};
                        return tl.isObject(m) ? tl.each(m, function(m, _) {
                            this._is_reserved_property(_) || (R[_] = m)
                        }, this) : R[m] = _, C[tA] = R, C
                    },
                    remove_action: function(m, _) {
                        var C = {},
                            R = {};
                        return tl.isObject(m) ? tl.each(m, function(m, _) {
                            this._is_reserved_property(_) || (R[_] = m)
                        }, this) : R[m] = _, C[tP] = R, C
                    },
                    delete_action: function() {
                        var m = {};
                        return m.$delete = "", m
                    }
                },
                MixpanelGroup = function() {};
            tl.extend(MixpanelGroup.prototype, tD), MixpanelGroup.prototype._init = function(m, _, C) {
                this._mixpanel = m, this._group_key = _, this._group_id = C
            }, MixpanelGroup.prototype.set = addOptOutCheckMixpanelGroup(function(m, _, C) {
                var R = this.set_action(m, _);
                return tl.isObject(m) && (C = _), this._send_request(R, C)
            }), MixpanelGroup.prototype.set_once = addOptOutCheckMixpanelGroup(function(m, _, C) {
                var R = this.set_once_action(m, _);
                return tl.isObject(m) && (C = _), this._send_request(R, C)
            }), MixpanelGroup.prototype.unset = addOptOutCheckMixpanelGroup(function(m, _) {
                var C = this.unset_action(m);
                return this._send_request(C, _)
            }), MixpanelGroup.prototype.union = addOptOutCheckMixpanelGroup(function(m, _, C) {
                tl.isObject(m) && (C = _);
                var R = this.union_action(m, _);
                return this._send_request(R, C)
            }), MixpanelGroup.prototype.delete = addOptOutCheckMixpanelGroup(function(m) {
                var _ = this.delete_action();
                return this._send_request(_, m)
            }), MixpanelGroup.prototype.remove = addOptOutCheckMixpanelGroup(function(m, _, C) {
                var R = this.remove_action(m, _);
                return this._send_request(R, C)
            }), MixpanelGroup.prototype._send_request = function(m, _) {
                m.$group_key = this._group_key, m.$group_id = this._group_id, m.$token = this._get_config("token");
                var C = tl.encodeDates(m);
                return this._mixpanel._track_or_batch({
                    type: "groups",
                    data: C,
                    endpoint: this._get_config("api_host") + "/" + this._get_config("api_routes").groups,
                    batcher: this._mixpanel.request_batchers.groups
                }, _)
            }, MixpanelGroup.prototype._is_reserved_property = function(m) {
                return "$group_key" === m || "$group_id" === m
            }, MixpanelGroup.prototype._get_config = function(m) {
                return this._mixpanel.get_config(m)
            }, MixpanelGroup.prototype.toString = function() {
                return this._mixpanel.toString() + ".group." + this._group_key + "." + this._group_id
            }, MixpanelGroup.prototype.remove = MixpanelGroup.prototype.remove, MixpanelGroup.prototype.set = MixpanelGroup.prototype.set, MixpanelGroup.prototype.set_once = MixpanelGroup.prototype.set_once, MixpanelGroup.prototype.union = MixpanelGroup.prototype.union, MixpanelGroup.prototype.unset = MixpanelGroup.prototype.unset, MixpanelGroup.prototype.toString = MixpanelGroup.prototype.toString;
            var MixpanelPeople = function() {};
            tl.extend(MixpanelPeople.prototype, tD), MixpanelPeople.prototype._init = function(m) {
                this._mixpanel = m
            }, MixpanelPeople.prototype.set = addOptOutCheckMixpanelPeople(function(m, _, C) {
                var R = this.set_action(m, _);
                return tl.isObject(m) && (C = _), this._get_config("save_referrer") && this._mixpanel.persistence.update_referrer_info(document.referrer), R[tO] = tl.extend({}, tl.info.people_properties(), R[tO]), this._send_request(R, C)
            }), MixpanelPeople.prototype.set_once = addOptOutCheckMixpanelPeople(function(m, _, C) {
                var R = this.set_once_action(m, _);
                return tl.isObject(m) && (C = _), this._send_request(R, C)
            }), MixpanelPeople.prototype.unset = addOptOutCheckMixpanelPeople(function(m, _) {
                var C = this.unset_action(m);
                return this._send_request(C, _)
            }), MixpanelPeople.prototype.increment = addOptOutCheckMixpanelPeople(function(m, _, C) {
                var R = {},
                    L = {};
                return tl.isObject(m) ? (tl.each(m, function(m, _) {
                    if (!this._is_reserved_property(_)) {
                        if (isNaN(parseFloat(m))) {
                            tu.error("Invalid increment value passed to mixpanel.people.increment - must be a number");
                            return
                        }
                        L[_] = m
                    }
                }, this), C = _) : (tl.isUndefined(_) && (_ = 1), L[m] = _), R[tT] = L, this._send_request(R, C)
            }), MixpanelPeople.prototype.append = addOptOutCheckMixpanelPeople(function(m, _, C) {
                tl.isObject(m) && (C = _);
                var R = this.append_action(m, _);
                return this._send_request(R, C)
            }), MixpanelPeople.prototype.remove = addOptOutCheckMixpanelPeople(function(m, _, C) {
                tl.isObject(m) && (C = _);
                var R = this.remove_action(m, _);
                return this._send_request(R, C)
            }), MixpanelPeople.prototype.union = addOptOutCheckMixpanelPeople(function(m, _, C) {
                tl.isObject(m) && (C = _);
                var R = this.union_action(m, _);
                return this._send_request(R, C)
            }), MixpanelPeople.prototype.track_charge = addOptOutCheckMixpanelPeople(function(m, _, C) {
                if (!tl.isNumber(m) && isNaN(m = parseFloat(m))) {
                    tu.error("Invalid value passed to mixpanel.people.track_charge - must be a number");
                    return
                }
                return this.append("$transactions", tl.extend({
                    $amount: m
                }, _), C)
            }), MixpanelPeople.prototype.clear_charges = function(m) {
                return this.set("$transactions", [], m)
            }, MixpanelPeople.prototype.delete_user = function() {
                if (!this._identify_called()) {
                    tu.error("mixpanel.people.delete_user() requires you to call identify() first");
                    return
                }
                var m = {
                    $delete: this._mixpanel.get_distinct_id()
                };
                return this._send_request(m)
            }, MixpanelPeople.prototype.toString = function() {
                return this._mixpanel.toString() + ".people"
            }, MixpanelPeople.prototype._send_request = function(m, _) {
                m.$token = this._get_config("token"), m.$distinct_id = this._mixpanel.get_distinct_id();
                var C = this._mixpanel.get_property("$device_id"),
                    R = this._mixpanel.get_property("$user_id"),
                    L = this._mixpanel.get_property("$had_persisted_distinct_id");
                C && (m.$device_id = C), R && (m.$user_id = R), L && (m.$had_persisted_distinct_id = L);
                var B = tl.encodeDates(m);
                return this._identify_called() ? this._mixpanel._track_or_batch({
                    type: "people",
                    data: B,
                    endpoint: this._get_config("api_host") + "/" + this._get_config("api_routes").engage,
                    batcher: this._mixpanel.request_batchers.people
                }, _) : (this._enqueue(m), tl.isUndefined(_) || _(this._get_config("verbose") ? {
                    status: -1,
                    error: null
                } : -1), tl.truncate(B, 255))
            }, MixpanelPeople.prototype._get_config = function(m) {
                return this._mixpanel.get_config(m)
            }, MixpanelPeople.prototype._identify_called = function() {
                return !0 === this._mixpanel._flags.identify_called
            }, MixpanelPeople.prototype._enqueue = function(m) {
                tO in m ? this._mixpanel.persistence._add_to_people_queue(tO, m) : tC in m ? this._mixpanel.persistence._add_to_people_queue(tC, m) : tM in m ? this._mixpanel.persistence._add_to_people_queue(tM, m) : tT in m ? this._mixpanel.persistence._add_to_people_queue(tT, m) : tA in m ? this._mixpanel.persistence._add_to_people_queue(tA, m) : tP in m ? this._mixpanel.persistence._add_to_people_queue(tP, m) : tR in m ? this._mixpanel.persistence._add_to_people_queue(tR, m) : tu.error("Invalid call to _enqueue():", m)
            }, MixpanelPeople.prototype._flush_one_queue = function(m, _, C, R) {
                var L = this,
                    B = tl.extend({}, this._mixpanel.persistence.load_queue(m)),
                    F = B;
                !tl.isUndefined(B) && tl.isObject(B) && !tl.isEmptyObject(B) && (L._mixpanel.persistence._pop_from_people_queue(m, B), L._mixpanel.persistence.save(), R && (F = R(B)), _.call(L, F, function(_, R) {
                    0 === _ && L._mixpanel.persistence._add_to_people_queue(m, B), tl.isUndefined(C) || C(_, R)
                }))
            }, MixpanelPeople.prototype._flush = function(m, _, C, R, L, B, F) {
                var U = this;
                this._flush_one_queue(tO, this.set, m), this._flush_one_queue(tC, this.set_once, R), this._flush_one_queue(tM, this.unset, B, function(m) {
                    return tl.keys(m)
                }), this._flush_one_queue(tT, this.increment, _), this._flush_one_queue(tR, this.union, L);
                var H = this._mixpanel.persistence.load_queue(tA);
                if (!tl.isUndefined(H) && tl.isArray(H) && H.length)
                    for (var q, append_callback = function(m, _) {
                            0 === m && U._mixpanel.persistence._add_to_people_queue(tA, q), tl.isUndefined(C) || C(m, _)
                        }, V = H.length - 1; V >= 0; V--) q = (H = this._mixpanel.persistence.load_queue(tA)).pop(), U._mixpanel.persistence.save(), tl.isEmptyObject(q) || U.append(q, append_callback);
                var X = this._mixpanel.persistence.load_queue(tP);
                if (!tl.isUndefined(X) && tl.isArray(X) && X.length)
                    for (var K, remove_callback = function(m, _) {
                            0 === m && U._mixpanel.persistence._add_to_people_queue(tP, K), tl.isUndefined(F) || F(m, _)
                        }, Y = X.length - 1; Y >= 0; Y--) K = (X = this._mixpanel.persistence.load_queue(tP)).pop(), U._mixpanel.persistence.save(), tl.isEmptyObject(K) || U.remove(K, remove_callback)
            }, MixpanelPeople.prototype._is_reserved_property = function(m) {
                return "$distinct_id" === m || "$token" === m || "$device_id" === m || "$user_id" === m || "$had_persisted_distinct_id" === m
            }, MixpanelPeople.prototype.set = MixpanelPeople.prototype.set, MixpanelPeople.prototype.set_once = MixpanelPeople.prototype.set_once, MixpanelPeople.prototype.unset = MixpanelPeople.prototype.unset, MixpanelPeople.prototype.increment = MixpanelPeople.prototype.increment, MixpanelPeople.prototype.append = MixpanelPeople.prototype.append, MixpanelPeople.prototype.remove = MixpanelPeople.prototype.remove, MixpanelPeople.prototype.union = MixpanelPeople.prototype.union, MixpanelPeople.prototype.track_charge = MixpanelPeople.prototype.track_charge, MixpanelPeople.prototype.clear_charges = MixpanelPeople.prototype.clear_charges, MixpanelPeople.prototype.delete_user = MixpanelPeople.prototype.delete_user, MixpanelPeople.prototype.toString = MixpanelPeople.prototype.toString;
            var tL = "__mps",
                tN = "__mpso",
                tB = "__mpus",
                tj = "__mpa",
                tF = "__mpap",
                tU = "__mpr",
                tH = "__mpu",
                tW = "$people_distinct_id",
                t$ = "__alias",
                tq = "__timers",
                tG = [tL, tN, tB, tj, tF, tU, tH, tW, t$, tq],
                MixpanelPersistence = function(m) {
                    this.props = {}, this.campaign_params_saved = !1, m.persistence_name ? this.name = "mp_" + m.persistence_name : this.name = "mp_" + m.token + "_mixpanel";
                    var _ = m.persistence;
                    "cookie" !== _ && "localStorage" !== _ && (tu.critical("Unknown persistence type " + _ + "; falling back to cookie"), _ = m.persistence = "cookie"), "localStorage" === _ && tl.localStorage.is_supported() ? this.storage = tl.localStorage : this.storage = tl.cookie, this.load(), this.update_config(m), this.upgrade(), this.save()
                };
            MixpanelPersistence.prototype.properties = function() {
                var m = {};
                return this.load(), tl.each(this.props, function(_, C) {
                    tl.include(tG, C) || (m[C] = _)
                }), m
            }, MixpanelPersistence.prototype.load = function() {
                if (!this.disabled) {
                    var m = this.storage.parse(this.name);
                    m && (this.props = tl.extend({}, m))
                }
            }, MixpanelPersistence.prototype.upgrade = function() {
                var m, _;
                this.storage === tl.localStorage ? (m = tl.cookie.parse(this.name), tl.cookie.remove(this.name), tl.cookie.remove(this.name, !0), m && this.register_once(m)) : this.storage === tl.cookie && (_ = tl.localStorage.parse(this.name), tl.localStorage.remove(this.name), _ && this.register_once(_))
            }, MixpanelPersistence.prototype.save = function() {
                this.disabled || this.storage.set(this.name, tl.JSONEncode(this.props), this.expire_days, this.cross_subdomain, this.secure, this.cross_site, this.cookie_domain)
            }, MixpanelPersistence.prototype.load_prop = function(m) {
                return this.load(), this.props[m]
            }, MixpanelPersistence.prototype.remove = function() {
                this.storage.remove(this.name, !1, this.cookie_domain), this.storage.remove(this.name, !0, this.cookie_domain)
            }, MixpanelPersistence.prototype.clear = function() {
                this.remove(), this.props = {}
            }, MixpanelPersistence.prototype.register_once = function(m, _, C) {
                return !!tl.isObject(m) && (void 0 === _ && (_ = "None"), this.expire_days = void 0 === C ? this.default_expiry : C, this.load(), tl.each(m, function(m, C) {
                    this.props.hasOwnProperty(C) && this.props[C] !== _ || (this.props[C] = m)
                }, this), this.save(), !0)
            }, MixpanelPersistence.prototype.register = function(m, _) {
                return !!tl.isObject(m) && (this.expire_days = void 0 === _ ? this.default_expiry : _, this.load(), tl.extend(this.props, m), this.save(), !0)
            }, MixpanelPersistence.prototype.unregister = function(m) {
                this.load(), m in this.props && (delete this.props[m], this.save())
            }, MixpanelPersistence.prototype.update_search_keyword = function(m) {
                this.register(tl.info.searchInfo(m))
            }, MixpanelPersistence.prototype.update_referrer_info = function(m) {
                this.register_once({
                    $initial_referrer: m || "$direct",
                    $initial_referring_domain: tl.info.referringDomain(m) || "$direct"
                }, "")
            }, MixpanelPersistence.prototype.get_referrer_info = function() {
                return tl.strip_empty_properties({
                    $initial_referrer: this.props.$initial_referrer,
                    $initial_referring_domain: this.props.$initial_referring_domain
                })
            }, MixpanelPersistence.prototype.update_config = function(m) {
                this.default_expiry = this.expire_days = m.cookie_expiration, this.set_disabled(m.disable_persistence), this.set_cookie_domain(m.cookie_domain), this.set_cross_site(m.cross_site_cookie), this.set_cross_subdomain(m.cross_subdomain_cookie), this.set_secure(m.secure_cookie)
            }, MixpanelPersistence.prototype.set_disabled = function(m) {
                this.disabled = m, this.disabled ? this.remove() : this.save()
            }, MixpanelPersistence.prototype.set_cookie_domain = function(m) {
                m !== this.cookie_domain && (this.remove(), this.cookie_domain = m, this.save())
            }, MixpanelPersistence.prototype.set_cross_site = function(m) {
                m !== this.cross_site && (this.cross_site = m, this.remove(), this.save())
            }, MixpanelPersistence.prototype.set_cross_subdomain = function(m) {
                m !== this.cross_subdomain && (this.cross_subdomain = m, this.remove(), this.save())
            }, MixpanelPersistence.prototype.get_cross_subdomain = function() {
                return this.cross_subdomain
            }, MixpanelPersistence.prototype.set_secure = function(m) {
                m !== this.secure && (this.secure = !!m, this.remove(), this.save())
            }, MixpanelPersistence.prototype._add_to_people_queue = function(m, _) {
                var C = this._get_queue_key(m),
                    R = _[m],
                    L = this._get_or_create_queue(tO),
                    B = this._get_or_create_queue(tC),
                    F = this._get_or_create_queue(tM),
                    U = this._get_or_create_queue(tT),
                    H = this._get_or_create_queue(tR),
                    q = this._get_or_create_queue(tP, []),
                    V = this._get_or_create_queue(tA, []);
                C === tL ? (tl.extend(L, R), this._pop_from_people_queue(tT, R), this._pop_from_people_queue(tR, R), this._pop_from_people_queue(tM, R)) : C === tN ? (tl.each(R, function(m, _) {
                    _ in B || (B[_] = m)
                }), this._pop_from_people_queue(tM, R)) : C === tB ? tl.each(R, function(m) {
                    tl.each([L, B, U, H], function(_) {
                        m in _ && delete _[m]
                    }), tl.each(V, function(_) {
                        m in _ && delete _[m]
                    }), F[m] = !0
                }) : C === tj ? (tl.each(R, function(m, _) {
                    _ in L ? L[_] += m : (_ in U || (U[_] = 0), U[_] += m)
                }, this), this._pop_from_people_queue(tM, R)) : C === tH ? (tl.each(R, function(m, _) {
                    tl.isArray(m) && (_ in H || (H[_] = []), H[_] = H[_].concat(m))
                }), this._pop_from_people_queue(tM, R)) : C === tU ? (q.push(R), this._pop_from_people_queue(tA, R)) : C === tF && (V.push(R), this._pop_from_people_queue(tM, R)), tu.log("MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):"), tu.log(_), this.save()
            }, MixpanelPersistence.prototype._pop_from_people_queue = function(m, _) {
                var C = this.props[this._get_queue_key(m)];
                tl.isUndefined(C) || tl.each(_, function(_, R) {
                    m === tA || m === tP ? tl.each(C, function(m) {
                        m[R] === _ && delete m[R]
                    }) : delete C[R]
                }, this)
            }, MixpanelPersistence.prototype.load_queue = function(m) {
                return this.load_prop(this._get_queue_key(m))
            }, MixpanelPersistence.prototype._get_queue_key = function(m) {
                return m === tO ? tL : m === tC ? tN : m === tM ? tB : m === tT ? tj : m === tA ? tF : m === tP ? tU : m === tR ? tH : void tu.error("Invalid queue:", m)
            }, MixpanelPersistence.prototype._get_or_create_queue = function(m, _) {
                var C = this._get_queue_key(m);
                return _ = tl.isUndefined(_) ? {} : _, this.props[C] || (this.props[C] = _)
            }, MixpanelPersistence.prototype.set_event_timer = function(m, _) {
                var C = this.load_prop(tq) || {};
                C[m] = _, this.props[tq] = C, this.save()
            }, MixpanelPersistence.prototype.remove_event_timer = function(m) {
                var _ = (this.load_prop(tq) || {})[m];
                return tl.isUndefined(_) || (delete this.props[tq][m], this.save()), _
            };
            var load_extra_bundle = function(m, _) {
                    throw Error(m + " not available in this build.")
                },
                IDENTITY_FUNC = function(m) {
                    return m
                },
                NOOP_FUNC = function() {},
                tz = "mixpanel",
                tV = "base64",
                tJ = "$device:",
                tX = eP.XMLHttpRequest && "withCredentials" in new XMLHttpRequest,
                tK = !tX && -1 === tr.indexOf("MSIE") && -1 === tr.indexOf("Mozilla"),
                tZ = null;
            e9.sendBeacon && (tZ = function() {
                return e9.sendBeacon.apply(e9, arguments)
            });
            var tY = {
                    track: "track/",
                    engage: "engage/",
                    groups: "groups/",
                    record: "record/"
                },
                tQ = {
                    api_host: "https://api-js.mixpanel.com",
                    api_routes: tY,
                    api_method: "POST",
                    api_transport: "XHR",
                    api_payload_format: tV,
                    app_host: "https://mixpanel.com",
                    cdn: "https://cdn.mxpnl.com",
                    cross_site_cookie: !1,
                    cross_subdomain_cookie: !0,
                    error_reporter: NOOP_FUNC,
                    persistence: "cookie",
                    persistence_name: "",
                    cookie_domain: "",
                    cookie_name: "",
                    loaded: NOOP_FUNC,
                    mp_loader: null,
                    track_marketing: !0,
                    track_pageview: !1,
                    skip_first_touch_marketing: !1,
                    store_google: !0,
                    stop_utm_persistence: !1,
                    save_referrer: !0,
                    test: !1,
                    verbose: !1,
                    img: !1,
                    debug: !1,
                    track_links_timeout: 300,
                    cookie_expiration: 365,
                    upgrade: !1,
                    disable_persistence: !1,
                    disable_cookie: !1,
                    secure_cookie: !1,
                    ip: !0,
                    opt_out_tracking_by_default: !1,
                    opt_out_persistence_by_default: !1,
                    opt_out_tracking_persistence_type: "localStorage",
                    opt_out_tracking_cookie_prefix: null,
                    property_blacklist: [],
                    xhr_headers: {},
                    ignore_dnt: !1,
                    batch_requests: !0,
                    batch_size: 50,
                    batch_flush_interval_ms: 5e3,
                    batch_request_timeout_ms: 9e4,
                    batch_autostart: !0,
                    hooks: {},
                    record_block_class: RegExp("^(mp-block|fs-exclude|amp-block|rr-block|ph-no-capture)$"),
                    record_block_selector: "img, video",
                    record_collect_fonts: !1,
                    record_idle_timeout_ms: 18e5,
                    record_inline_images: !1,
                    record_mask_text_class: RegExp("^(mp-mask|fs-mask|amp-mask|rr-mask|ph-mask)$"),
                    record_mask_text_selector: "*",
                    record_max_ms: 864e5,
                    record_min_ms: 0,
                    record_sessions_percent: 0,
                    recorder_src: "https://cdn.mxpnl.com/libs/mixpanel-recorder.min.js"
                },
                t0 = !1,
                MixpanelLib = function() {},
                create_mplib = function(m, _, C) {
                    var R, L = C === tz ? eL : eL[C];
                    if (L && 0 === eD) R = L;
                    else {
                        if (L && !tl.isArray(L)) {
                            tu.error("You have already initialized " + C);
                            return
                        }
                        R = new MixpanelLib
                    }
                    if (R._cached_groups = {}, R._init(m, _, C), R.people = new MixpanelPeople, R.people._init(R), !R.get_config("skip_first_touch_marketing")) {
                        var B = tl.info.campaignParams(null),
                            F = {},
                            U = !1;
                        tl.each(B, function(m, _) {
                            F["initial_" + _] = m, m && (U = !0)
                        }), U && R.people.set_once(F)
                    }
                    return eQ.DEBUG = eQ.DEBUG || R.get_config("debug"), !tl.isUndefined(L) && tl.isArray(L) && (R._execute_array.call(R.people, L.people), R._execute_array(L)), R
                };
            MixpanelLib.prototype.init = function(m, _, C) {
                if (tl.isUndefined(C)) {
                    this.report_error("You must name your new library: init(token, config, name)");
                    return
                }
                if (C === tz) {
                    this.report_error("You must initialize the main mixpanel object right after you include the Mixpanel js snippet");
                    return
                }
                var R = create_mplib(m, _, C);
                return eL[C] = R, R._loaded(), R
            }, MixpanelLib.prototype._init = function(m, _, C) {
                _ = _ || {}, this.__loaded = !0, this.config = {};
                var R = {};
                if (!("api_payload_format" in _) && (_.api_host || tQ.api_host).match(/\.mixpanel\.com/) && (R.api_payload_format = "json"), this.set_config(tl.extend({}, tQ, R, _, {
                        name: C,
                        token: m,
                        callback_fn: (C === tz ? C : tz + "." + C) + "._jsc"
                    })), this._jsc = NOOP_FUNC, this.__dom_loaded_queue = [], this.__request_queue = [], this.__disabled_events = [], this._flags = {
                        disable_all_events: !1,
                        identify_called: !1
                    }, this.request_batchers = {}, this._batch_requests = this.get_config("batch_requests"), this._batch_requests) {
                    if (tl.localStorage.is_supported(!0) && tX) {
                        if (this.init_batchers(), tZ && eP.addEventListener) {
                            var L = tl.bind(function() {
                                this.request_batchers.events.stopped || this.request_batchers.events.flush({
                                    unloading: !0
                                })
                            }, this);
                            eP.addEventListener("pagehide", function(m) {
                                m.persisted && L()
                            }), eP.addEventListener("visibilitychange", function() {
                                "hidden" === e7.visibilityState && L()
                            })
                        }
                    } else this._batch_requests = !1, tu.log("Turning off Mixpanel request-queueing; needs XHR and localStorage support"), tl.each(this.get_batcher_configs(), function(m) {
                        tu.log("Clearing batch queue " + m.queue_key), tl.localStorage.remove(m.queue_key)
                    })
                }
                this.persistence = this.cookie = new MixpanelPersistence(this.config), this.unpersisted_superprops = {}, this._gdpr_init();
                var B = tl.UUID();
                this.get_distinct_id() || this.register_once({
                    distinct_id: tJ + B,
                    $device_id: B
                }, "");
                var F = this.get_config("track_pageview");
                F && this._init_url_change_tracking(F), this.get_config("record_sessions_percent") > 0 && 100 * Math.random() <= this.get_config("record_sessions_percent") && this.start_session_recording()
            }, MixpanelLib.prototype.start_session_recording = addOptOutCheckMixpanelLib(function() {
                if (!eP.MutationObserver) {
                    tu.critical("Browser does not support MutationObserver; skipping session recording");
                    return
                }
                var m = tl.bind(function() {
                    this._recorder = this._recorder || new eP.__mp_recorder(this), this._recorder.startRecording()
                }, this);
                tl.isUndefined(eP.__mp_recorder) ? load_extra_bundle(this.get_config("recorder_src"), m) : m()
            }), MixpanelLib.prototype.stop_session_recording = function() {
                this._recorder ? this._recorder.stopRecording() : tu.critical("Session recorder module not loaded")
            }, MixpanelLib.prototype.get_session_recording_properties = function() {
                var m = {};
                if (this._recorder) {
                    var _ = this._recorder.replayId;
                    _ && (m.$mp_replay_id = _)
                }
                return m
            }, MixpanelLib.prototype._loaded = function() {
                if (this.get_config("loaded")(this), this._set_default_superprops(), this.people.set_once(this.persistence.get_referrer_info()), this.get_config("store_google") && this.get_config("stop_utm_persistence")) {
                    var m = tl.info.campaignParams(null);
                    tl.each(m, (function(m, _) {
                        this.unregister(_)
                    }).bind(this))
                }
            }, MixpanelLib.prototype._set_default_superprops = function() {
                this.persistence.update_search_keyword(e7.referrer), this.get_config("store_google") && !this.get_config("stop_utm_persistence") && this.register(tl.info.campaignParams()), this.get_config("save_referrer") && this.persistence.update_referrer_info(e7.referrer)
            }, MixpanelLib.prototype._dom_loaded = function() {
                tl.each(this.__dom_loaded_queue, function(m) {
                    this._track_dom.apply(this, m)
                }, this), this.has_opted_out_tracking() || tl.each(this.__request_queue, function(m) {
                    this._send_request.apply(this, m)
                }, this), delete this.__dom_loaded_queue, delete this.__request_queue
            }, MixpanelLib.prototype._track_dom = function(m, _) {
                if (this.get_config("img")) return this.report_error("You can't use DOM tracking functions with img = true."), !1;
                if (!t0) return this.__dom_loaded_queue.push([m, _]), !1;
                var C = new m().init(this);
                return C.track.apply(C, _)
            }, MixpanelLib.prototype._init_url_change_tracking = function(m) {
                var _ = "";
                if (this.track_pageview() && (_ = tl.info.currentUrl()), tl.include(["full-url", "url-with-path-and-query-string", "url-with-path"], m)) {
                    eP.addEventListener("popstate", function() {
                        eP.dispatchEvent(new Event("mp_locationchange"))
                    }), eP.addEventListener("hashchange", function() {
                        eP.dispatchEvent(new Event("mp_locationchange"))
                    });
                    var C = eP.history.pushState;
                    "function" == typeof C && (eP.history.pushState = function(m, _, R) {
                        C.call(eP.history, m, _, R), eP.dispatchEvent(new Event("mp_locationchange"))
                    });
                    var R = eP.history.replaceState;
                    "function" == typeof R && (eP.history.replaceState = function(m, _, C) {
                        R.call(eP.history, m, _, C), eP.dispatchEvent(new Event("mp_locationchange"))
                    }), eP.addEventListener("mp_locationchange", (function() {
                        var C = tl.info.currentUrl(),
                            R = !1;
                        "full-url" === m ? R = C !== _ : "url-with-path-and-query-string" === m ? R = C.split("#")[0] !== _.split("#")[0] : "url-with-path" === m && (R = C.split("#")[0].split("?")[0] !== _.split("#")[0].split("?")[0]), R && this.track_pageview() && (_ = C)
                    }).bind(this))
                }
            }, MixpanelLib.prototype._prepare_callback = function(m, _) {
                if (tl.isUndefined(m)) return null;
                if (tX) return function(C) {
                    m(C, _)
                };
                var C = this._jsc,
                    R = "" + Math.floor(1e8 * Math.random()),
                    L = this.get_config("callback_fn") + "[" + R + "]";
                return C[R] = function(L) {
                    delete C[R], m(L, _)
                }, L
            }, MixpanelLib.prototype._send_request = function(m, _, C, R) {
                var L = !0;
                if (tK) return this.__request_queue.push(arguments), L;
                var B = {
                        method: this.get_config("api_method"),
                        transport: this.get_config("api_transport"),
                        verbose: this.get_config("verbose")
                    },
                    F = null;
                !R && (tl.isFunction(C) || "string" == typeof C) && (R = C, C = null), C = tl.extend(B, C || {}), tX || (C.method = "GET");
                var U = "POST" === C.method,
                    H = tZ && U && "sendbeacon" === C.transport.toLowerCase(),
                    q = C.verbose;
                _.verbose && (q = !0), this.get_config("test") && (_.test = 1), q && (_.verbose = 1), this.get_config("img") && (_.img = 1), !tX && (R ? _.callback = R : (q || this.get_config("test")) && (_.callback = "(function(){})")), _.ip = this.get_config("ip") ? 1 : 0, _._ = new Date().getTime().toString(), U && (F = "data=" + encodeURIComponent(_.data), delete _.data), m += "?" + tl.HTTPBuildQuery(_);
                var V = this;
                if ("img" in _) {
                    var X = e7.createElement("img");
                    X.src = m, e7.body.appendChild(X)
                } else if (H) {
                    try {
                        L = tZ(m, F)
                    } catch (m) {
                        V.report_error(m), L = !1
                    }
                    try {
                        R && R(L ? 1 : 0)
                    } catch (m) {
                        V.report_error(m)
                    }
                } else if (tX) try {
                    var K = new XMLHttpRequest;
                    K.open(C.method, m, !0);
                    var Y = this.get_config("xhr_headers");
                    if (U && (Y["Content-Type"] = "application/x-www-form-urlencoded"), tl.each(Y, function(m, _) {
                            K.setRequestHeader(_, m)
                        }), C.timeout_ms && void 0 !== K.timeout) {
                        K.timeout = C.timeout_ms;
                        var Q = new Date().getTime()
                    }
                    K.withCredentials = !0, K.onreadystatechange = function() {
                        if (4 === K.readyState) {
                            if (200 === K.status) {
                                if (R) {
                                    if (q) {
                                        try {
                                            m = tl.JSONDecode(K.responseText)
                                        } catch (_) {
                                            if (V.report_error(_), !C.ignore_json_errors) return;
                                            m = K.responseText
                                        }
                                        R(m)
                                    } else R(Number(K.responseText))
                                }
                            } else if (_ = K.timeout && !K.status && new Date().getTime() - Q >= K.timeout ? "timeout" : "Bad HTTP status: " + K.status + " " + K.statusText, V.report_error(_), R) {
                                if (q) {
                                    var m, _, L = K.responseHeaders || {};
                                    R({
                                        status: 0,
                                        httpStatusCode: K.status,
                                        error: _,
                                        retryAfter: L["Retry-After"]
                                    })
                                } else R(0)
                            }
                        }
                    }, K.send(F)
                } catch (m) {
                    V.report_error(m), L = !1
                } else {
                    var et = e7.createElement("script");
                    et.type = "text/javascript", et.async = !0, et.defer = !0, et.src = m;
                    var er = e7.getElementsByTagName("script")[0];
                    er.parentNode.insertBefore(et, er)
                }
                return L
            }, MixpanelLib.prototype._execute_array = function(m) {
                var _, C = [],
                    R = [],
                    L = [];
                tl.each(m, function(m) {
                    m && (_ = m[0], tl.isArray(_) ? L.push(m) : "function" == typeof m ? m.call(this) : tl.isArray(m) && "alias" === _ ? C.push(m) : tl.isArray(m) && -1 !== _.indexOf("track") && "function" == typeof this[_] ? L.push(m) : R.push(m))
                }, this);
                var execute = function(m, _) {
                    tl.each(m, function(m) {
                        if (tl.isArray(m[0])) {
                            var C = _;
                            tl.each(m, function(m) {
                                C = C[m[0]].apply(C, m.slice(1))
                            })
                        } else this[m[0]].apply(this, m.slice(1))
                    }, _)
                };
                execute(C, this), execute(R, this), execute(L, this)
            }, MixpanelLib.prototype.are_batchers_initialized = function() {
                return !!this.request_batchers.events
            }, MixpanelLib.prototype.get_batcher_configs = function() {
                var m = "__mpq_" + this.get_config("token"),
                    _ = this.get_config("api_routes");
                return this._batcher_configs = this._batcher_configs || {
                    events: {
                        type: "events",
                        endpoint: "/" + _.track,
                        queue_key: m + "_ev"
                    },
                    people: {
                        type: "people",
                        endpoint: "/" + _.engage,
                        queue_key: m + "_pp"
                    },
                    groups: {
                        type: "groups",
                        endpoint: "/" + _.groups,
                        queue_key: m + "_gr"
                    }
                }, this._batcher_configs
            }, MixpanelLib.prototype.init_batchers = function() {
                if (!this.are_batchers_initialized()) {
                    var m = tl.bind(function(m) {
                            return new RequestBatcher(m.queue_key, {
                                libConfig: this.config,
                                errorReporter: this.get_config("error_reporter"),
                                sendRequestFunc: tl.bind(function(_, C, R) {
                                    this._send_request(this.get_config("api_host") + m.endpoint, this._encode_data_for_request(_), C, this._prepare_callback(R, _))
                                }, this),
                                beforeSendHook: tl.bind(function(_) {
                                    return this._run_hook("before_send_" + m.type, _)
                                }, this),
                                stopAllBatchingFunc: tl.bind(this.stop_batch_senders, this),
                                usePersistence: !0
                            })
                        }, this),
                        _ = this.get_batcher_configs();
                    this.request_batchers = {
                        events: m(_.events),
                        people: m(_.people),
                        groups: m(_.groups)
                    }
                }
                this.get_config("batch_autostart") && this.start_batch_senders()
            }, MixpanelLib.prototype.start_batch_senders = function() {
                this._batchers_were_started = !0, this.are_batchers_initialized() && (this._batch_requests = !0, tl.each(this.request_batchers, function(m) {
                    m.start()
                }))
            }, MixpanelLib.prototype.stop_batch_senders = function() {
                this._batch_requests = !1, tl.each(this.request_batchers, function(m) {
                    m.stop(), m.clear()
                })
            }, MixpanelLib.prototype.push = function(m) {
                this._execute_array([m])
            }, MixpanelLib.prototype.disable = function(m) {
                void 0 === m ? this._flags.disable_all_events = !0 : this.__disabled_events = this.__disabled_events.concat(m)
            }, MixpanelLib.prototype._encode_data_for_request = function(m) {
                var _ = tl.JSONEncode(m);
                return this.get_config("api_payload_format") === tV && (_ = tl.base64Encode(_)), {
                    data: _
                }
            }, MixpanelLib.prototype._track_or_batch = function(m, _) {
                var C = tl.truncate(m.data, 255),
                    R = m.endpoint,
                    L = m.batcher,
                    B = m.should_send_immediately,
                    F = m.send_request_options || {};
                _ = _ || NOOP_FUNC;
                var U = !0,
                    H = tl.bind(function() {
                        return (F.skip_hooks || (C = this._run_hook("before_send_" + m.type, C)), C) ? (tu.log("MIXPANEL REQUEST:"), tu.log(C), this._send_request(R, this._encode_data_for_request(C), F, this._prepare_callback(_, C))) : null
                    }, this);
                return this._batch_requests && !B ? L.enqueue(C, function(m) {
                    m ? _(1, C) : H()
                }) : U = H(), U && C
            }, MixpanelLib.prototype.track = addOptOutCheckMixpanelLib(function(m, _, C, R) {
                R || "function" != typeof C || (R = C, C = null);
                var L = (C = C || {}).transport;
                L && (C.transport = L);
                var B = C.send_immediately;
                if ("function" != typeof R && (R = NOOP_FUNC), tl.isUndefined(m)) {
                    this.report_error("No event name provided to mixpanel.track");
                    return
                }
                if (this._event_is_disabled(m)) {
                    R(0);
                    return
                }(_ = tl.extend({}, _)).token = this.get_config("token");
                var F = this.persistence.remove_event_timer(m);
                if (!tl.isUndefined(F)) {
                    var U = new Date().getTime() - F;
                    _.$duration = parseFloat((U / 1e3).toFixed(3))
                }
                this._set_default_superprops();
                var H = this.get_config("track_marketing") ? tl.info.marketingParams() : {};
                _ = tl.extend({}, tl.info.properties({
                    mp_loader: this.get_config("mp_loader")
                }), H, this.persistence.properties(), this.unpersisted_superprops, this.get_session_recording_properties(), _);
                var q = this.get_config("property_blacklist");
                tl.isArray(q) ? tl.each(q, function(m) {
                    delete _[m]
                }) : this.report_error("Invalid value for property_blacklist config: " + q);
                var V = {
                    event: m,
                    properties: _
                };
                return this._track_or_batch({
                    type: "events",
                    data: V,
                    endpoint: this.get_config("api_host") + "/" + this.get_config("api_routes").track,
                    batcher: this.request_batchers.events,
                    should_send_immediately: B,
                    send_request_options: C
                }, R)
            }), MixpanelLib.prototype.set_group = addOptOutCheckMixpanelLib(function(m, _, C) {
                tl.isArray(_) || (_ = [_]);
                var R = {};
                return R[m] = _, this.register(R), this.people.set(m, _, C)
            }), MixpanelLib.prototype.add_group = addOptOutCheckMixpanelLib(function(m, _, C) {
                var R = this.get_property(m),
                    L = {};
                return void 0 === R ? (L[m] = [_], this.register(L)) : -1 === R.indexOf(_) && (R.push(_), L[m] = R, this.register(L)), this.people.union(m, _, C)
            }), MixpanelLib.prototype.remove_group = addOptOutCheckMixpanelLib(function(m, _, C) {
                var R = this.get_property(m);
                if (void 0 !== R) {
                    var L = R.indexOf(_);
                    L > -1 && (R.splice(L, 1), this.register({
                        group_key: R
                    })), 0 === R.length && this.unregister(m)
                }
                return this.people.remove(m, _, C)
            }), MixpanelLib.prototype.track_with_groups = addOptOutCheckMixpanelLib(function(m, _, C, R) {
                var L = tl.extend({}, _ || {});
                return tl.each(C, function(m, _) {
                    null != m && (L[_] = m)
                }), this.track(m, L, R)
            }), MixpanelLib.prototype._create_map_key = function(m, _) {
                return m + "_" + JSON.stringify(_)
            }, MixpanelLib.prototype._remove_group_from_cache = function(m, _) {
                delete this._cached_groups[this._create_map_key(m, _)]
            }, MixpanelLib.prototype.get_group = function(m, _) {
                var C = this._create_map_key(m, _),
                    R = this._cached_groups[C];
                return (void 0 === R || R._group_key !== m || R._group_id !== _) && ((R = new MixpanelGroup)._init(this, m, _), this._cached_groups[C] = R), R
            }, MixpanelLib.prototype.track_pageview = addOptOutCheckMixpanelLib(function(m, _) {
                "object" != typeof m && (m = {});
                var C = (_ = _ || {}).event_name || "$mp_web_page_view",
                    R = tl.extend(tl.info.mpPageViewProperties(), tl.info.campaignParams(), tl.info.clickParams()),
                    L = tl.extend({}, R, m);
                return this.track(C, L)
            }), MixpanelLib.prototype.track_links = function() {
                return this._track_dom.call(this, LinkTracker, arguments)
            }, MixpanelLib.prototype.track_forms = function() {
                return this._track_dom.call(this, FormTracker, arguments)
            }, MixpanelLib.prototype.time_event = function(m) {
                if (tl.isUndefined(m)) {
                    this.report_error("No event name provided to mixpanel.time_event");
                    return
                }
                this._event_is_disabled(m) || this.persistence.set_event_timer(m, new Date().getTime())
            };
            var t1 = {
                    persistent: !0
                },
                options_for_register = function(m) {
                    var _;
                    return _ = tl.isObject(m) ? m : tl.isUndefined(m) ? {} : {
                        days: m
                    }, tl.extend({}, t1, _)
                };
            MixpanelLib.prototype.register = function(m, _) {
                var C = options_for_register(_);
                C.persistent ? this.persistence.register(m, C.days) : tl.extend(this.unpersisted_superprops, m)
            }, MixpanelLib.prototype.register_once = function(m, _, C) {
                var R = options_for_register(C);
                R.persistent ? this.persistence.register_once(m, _, R.days) : (void 0 === _ && (_ = "None"), tl.each(m, function(m, C) {
                    this.unpersisted_superprops.hasOwnProperty(C) && this.unpersisted_superprops[C] !== _ || (this.unpersisted_superprops[C] = m)
                }, this))
            }, MixpanelLib.prototype.unregister = function(m, _) {
                (_ = options_for_register(_)).persistent ? this.persistence.unregister(m) : delete this.unpersisted_superprops[m]
            }, MixpanelLib.prototype._register_single = function(m, _) {
                var C = {};
                C[m] = _, this.register(C)
            }, MixpanelLib.prototype.identify = function(m, _, C, R, L, B, F, U) {
                var H = this.get_distinct_id();
                if (m && H !== m) {
                    if ("string" == typeof m && 0 === m.indexOf(tJ)) return this.report_error("distinct_id cannot have $device: prefix"), -1;
                    this.register({
                        $user_id: m
                    })
                }
                this.get_property("$device_id") || this.register_once({
                    $had_persisted_distinct_id: !0,
                    $device_id: H
                }, ""), m !== H && m !== this.get_property(t$) && (this.unregister(t$), this.register({
                    distinct_id: m
                })), this._flags.identify_called = !0, this.people._flush(_, C, R, L, B, F, U), m !== H && this.track("$identify", {
                    distinct_id: m,
                    $anon_distinct_id: H
                }, {
                    skip_hooks: !0
                })
            }, MixpanelLib.prototype.reset = function() {
                this.persistence.clear(), this._flags.identify_called = !1;
                var m = tl.UUID();
                this.register_once({
                    distinct_id: tJ + m,
                    $device_id: m
                }, "")
            }, MixpanelLib.prototype.get_distinct_id = function() {
                return this.get_property("distinct_id")
            }, MixpanelLib.prototype.alias = function(m, _) {
                if (m === this.get_property(tW)) return this.report_error("Attempting to create alias for existing People user - aborting."), -2;
                var C = this;
                return (tl.isUndefined(_) && (_ = this.get_distinct_id()), m !== _) ? (this._register_single(t$, m), this.track("$create_alias", {
                    alias: m,
                    distinct_id: _
                }, {
                    skip_hooks: !0
                }, function() {
                    C.identify(m)
                })) : (this.report_error("alias matches current distinct_id - skipping api call."), this.identify(m), -1)
            }, MixpanelLib.prototype.name_tag = function(m) {
                this._register_single("mp_name_tag", m)
            }, MixpanelLib.prototype.set_config = function(m) {
                tl.isObject(m) && (tl.extend(this.config, m), m.batch_size && tl.each(this.request_batchers, function(m) {
                    m.resetBatchSize()
                }), this.get_config("persistence_name") || (this.config.persistence_name = this.config.cookie_name), this.get_config("disable_persistence") || (this.config.disable_persistence = this.config.disable_cookie), this.persistence && this.persistence.update_config(this.config), eQ.DEBUG = eQ.DEBUG || this.get_config("debug"))
            }, MixpanelLib.prototype.get_config = function(m) {
                return this.config[m]
            }, MixpanelLib.prototype._run_hook = function(m) {
                var _ = (this.config.hooks[m] || IDENTITY_FUNC).apply(this, e5.call(arguments, 1));
                return void 0 === _ && (this.report_error(m + " hook did not return a value"), _ = null), _
            }, MixpanelLib.prototype.get_property = function(m) {
                return this.persistence.load_prop([m])
            }, MixpanelLib.prototype.toString = function() {
                var m = this.get_config("name");
                return m !== tz && (m = tz + "." + m), m
            }, MixpanelLib.prototype._event_is_disabled = function(m) {
                return tl.isBlockedUA(tr) || this._flags.disable_all_events || tl.include(this.__disabled_events, m)
            }, MixpanelLib.prototype._gdpr_init = function() {
                "localStorage" === this.get_config("opt_out_tracking_persistence_type") && tl.localStorage.is_supported() && (!this.has_opted_in_tracking() && this.has_opted_in_tracking({
                    persistence_type: "cookie"
                }) && this.opt_in_tracking({
                    enable_persistence: !1
                }), !this.has_opted_out_tracking() && this.has_opted_out_tracking({
                    persistence_type: "cookie"
                }) && this.opt_out_tracking({
                    clear_persistence: !1
                }), this.clear_opt_in_out_tracking({
                    persistence_type: "cookie",
                    enable_persistence: !1
                })), this.has_opted_out_tracking() ? this._gdpr_update_persistence({
                    clear_persistence: !0
                }) : !this.has_opted_in_tracking() && (this.get_config("opt_out_tracking_by_default") || tl.cookie.get("mp_optout")) && (tl.cookie.remove("mp_optout"), this.opt_out_tracking({
                    clear_persistence: this.get_config("opt_out_persistence_by_default")
                }))
            }, MixpanelLib.prototype._gdpr_update_persistence = function(m) {
                var _;
                if (m && m.clear_persistence) _ = !0;
                else {
                    if (!m || !m.enable_persistence) return;
                    _ = !1
                }
                this.get_config("disable_persistence") || this.persistence.disabled === _ || this.persistence.set_disabled(_), _ ? this.stop_batch_senders() : this._batchers_were_started && this.start_batch_senders()
            }, MixpanelLib.prototype._gdpr_call_func = function(m, _) {
                return _ = tl.extend({
                    track: tl.bind(this.track, this),
                    persistence_type: this.get_config("opt_out_tracking_persistence_type"),
                    cookie_prefix: this.get_config("opt_out_tracking_cookie_prefix"),
                    cookie_expiration: this.get_config("cookie_expiration"),
                    cross_site_cookie: this.get_config("cross_site_cookie"),
                    cross_subdomain_cookie: this.get_config("cross_subdomain_cookie"),
                    cookie_domain: this.get_config("cookie_domain"),
                    secure_cookie: this.get_config("secure_cookie"),
                    ignore_dnt: this.get_config("ignore_dnt")
                }, _), tl.localStorage.is_supported() || (_.persistence_type = "cookie"), m(this.get_config("token"), {
                    track: _.track,
                    trackEventName: _.track_event_name,
                    trackProperties: _.track_properties,
                    persistenceType: _.persistence_type,
                    persistencePrefix: _.cookie_prefix,
                    cookieDomain: _.cookie_domain,
                    cookieExpiration: _.cookie_expiration,
                    crossSiteCookie: _.cross_site_cookie,
                    crossSubdomainCookie: _.cross_subdomain_cookie,
                    secureCookie: _.secure_cookie,
                    ignoreDnt: _.ignore_dnt
                })
            }, MixpanelLib.prototype.opt_in_tracking = function(m) {
                m = tl.extend({
                    enable_persistence: !0
                }, m), this._gdpr_call_func(optIn, m), this._gdpr_update_persistence(m)
            }, MixpanelLib.prototype.opt_out_tracking = function(m) {
                (m = tl.extend({
                    clear_persistence: !0,
                    delete_user: !0
                }, m)).delete_user && this.people && this.people._identify_called() && (this.people.delete_user(), this.people.clear_charges()), this._gdpr_call_func(optOut, m), this._gdpr_update_persistence(m)
            }, MixpanelLib.prototype.has_opted_in_tracking = function(m) {
                return this._gdpr_call_func(hasOptedIn, m)
            }, MixpanelLib.prototype.has_opted_out_tracking = function(m) {
                return this._gdpr_call_func(hasOptedOut, m)
            }, MixpanelLib.prototype.clear_opt_in_out_tracking = function(m) {
                m = tl.extend({
                    enable_persistence: !0
                }, m), this._gdpr_call_func(clearOptInOut, m), this._gdpr_update_persistence(m)
            }, MixpanelLib.prototype.report_error = function(m, _) {
                tu.error.apply(tu.error, arguments);
                try {
                    _ || m instanceof Error || (m = Error(m)), this.get_config("error_reporter")(m, _)
                } catch (m) {
                    tu.error(m)
                }
            }, MixpanelLib.prototype.init = MixpanelLib.prototype.init, MixpanelLib.prototype.reset = MixpanelLib.prototype.reset, MixpanelLib.prototype.disable = MixpanelLib.prototype.disable, MixpanelLib.prototype.time_event = MixpanelLib.prototype.time_event, MixpanelLib.prototype.track = MixpanelLib.prototype.track, MixpanelLib.prototype.track_links = MixpanelLib.prototype.track_links, MixpanelLib.prototype.track_forms = MixpanelLib.prototype.track_forms, MixpanelLib.prototype.track_pageview = MixpanelLib.prototype.track_pageview, MixpanelLib.prototype.register = MixpanelLib.prototype.register, MixpanelLib.prototype.register_once = MixpanelLib.prototype.register_once, MixpanelLib.prototype.unregister = MixpanelLib.prototype.unregister, MixpanelLib.prototype.identify = MixpanelLib.prototype.identify, MixpanelLib.prototype.alias = MixpanelLib.prototype.alias, MixpanelLib.prototype.name_tag = MixpanelLib.prototype.name_tag, MixpanelLib.prototype.set_config = MixpanelLib.prototype.set_config, MixpanelLib.prototype.get_config = MixpanelLib.prototype.get_config, MixpanelLib.prototype.get_property = MixpanelLib.prototype.get_property, MixpanelLib.prototype.get_distinct_id = MixpanelLib.prototype.get_distinct_id, MixpanelLib.prototype.toString = MixpanelLib.prototype.toString, MixpanelLib.prototype.opt_out_tracking = MixpanelLib.prototype.opt_out_tracking, MixpanelLib.prototype.opt_in_tracking = MixpanelLib.prototype.opt_in_tracking, MixpanelLib.prototype.has_opted_out_tracking = MixpanelLib.prototype.has_opted_out_tracking, MixpanelLib.prototype.has_opted_in_tracking = MixpanelLib.prototype.has_opted_in_tracking, MixpanelLib.prototype.clear_opt_in_out_tracking = MixpanelLib.prototype.clear_opt_in_out_tracking, MixpanelLib.prototype.get_group = MixpanelLib.prototype.get_group, MixpanelLib.prototype.set_group = MixpanelLib.prototype.set_group, MixpanelLib.prototype.add_group = MixpanelLib.prototype.add_group, MixpanelLib.prototype.remove_group = MixpanelLib.prototype.remove_group, MixpanelLib.prototype.track_with_groups = MixpanelLib.prototype.track_with_groups, MixpanelLib.prototype.start_batch_senders = MixpanelLib.prototype.start_batch_senders, MixpanelLib.prototype.stop_batch_senders = MixpanelLib.prototype.stop_batch_senders, MixpanelLib.prototype.start_session_recording = MixpanelLib.prototype.start_session_recording, MixpanelLib.prototype.stop_session_recording = MixpanelLib.prototype.stop_session_recording, MixpanelLib.prototype.get_session_recording_properties = MixpanelLib.prototype.get_session_recording_properties, MixpanelLib.prototype.DEFAULT_API_ROUTES = tY, MixpanelPersistence.prototype.properties = MixpanelPersistence.prototype.properties, MixpanelPersistence.prototype.update_search_keyword = MixpanelPersistence.prototype.update_search_keyword, MixpanelPersistence.prototype.update_referrer_info = MixpanelPersistence.prototype.update_referrer_info, MixpanelPersistence.prototype.get_cross_subdomain = MixpanelPersistence.prototype.get_cross_subdomain, MixpanelPersistence.prototype.clear = MixpanelPersistence.prototype.clear;
            var t2 = {},
                extend_mp = function() {
                    tl.each(t2, function(m, _) {
                        _ !== tz && (eL[_] = m)
                    }), eL._ = tl
                },
                t3 = (load_extra_bundle = function(m, _) {
                    _()
                }, eD = 0, (eL = new MixpanelLib).init = function(m, _, C) {
                    if (C) return eL[C] || (eL[C] = t2[C] = create_mplib(m, _, C), eL[C]._loaded()), eL[C];
                    var R = eL;
                    t2[tz] ? R = t2[tz] : m && ((R = create_mplib(m, _, tz))._loaded(), t2[tz] = R), eL = R, 1 === eD && (eP[tz] = eL), extend_mp()
                }, eL.init(), function() {
                    function dom_loaded_handler() {
                        dom_loaded_handler.done || (dom_loaded_handler.done = !0, t0 = !0, tK = !1, tl.each(t2, function(m) {
                            m._dom_loaded()
                        }))
                    }
                    if (e7.addEventListener) "complete" === e7.readyState ? dom_loaded_handler() : e7.addEventListener("DOMContentLoaded", dom_loaded_handler, !1);
                    else if (e7.attachEvent) {
                        e7.attachEvent("onreadystatechange", dom_loaded_handler);
                        var m = !1;
                        try {
                            m = null === eP.frameElement
                        } catch (m) {}
                        e7.documentElement.doScroll && m && function do_scroll_check() {
                            try {
                                e7.documentElement.doScroll("left")
                            } catch (m) {
                                setTimeout(do_scroll_check, 1);
                                return
                            }
                            dom_loaded_handler()
                        }()
                    }
                    tl.register_event(eP, "load", dom_loaded_handler, !0)
                }(), eL)
        },
        6840: function(m, _, C) {
            (window.__NEXT_P = window.__NEXT_P || []).push(["/_app", function() {
                return C(30931)
            }])
        },
        62961: function(m, _, C) {
            "use strict";
            C.d(_, {
                $H: function() {
                    return eg
                },
                $w: function() {
                    return K
                },
                AF: function() {
                    return e1
                },
                BG: function() {
                    return eq
                },
                BU: function() {
                    return tr
                },
                Bb: function() {
                    return e_
                },
                By: function() {
                    return eM
                },
                CP: function() {
                    return tl
                },
                C_: function() {
                    return X
                },
                Cy: function() {
                    return R
                },
                DQ: function() {
                    return tn
                },
                Dz: function() {
                    return ev
                },
                ER: function() {
                    return ex
                },
                FW: function() {
                    return tc
                },
                Fv: function() {
                    return eD
                },
                G: function() {
                    return eX
                },
                GJ: function() {
                    return eV
                },
                Gu: function() {
                    return ti
                },
                IP: function() {
                    return th
                },
                KV: function() {
                    return F
                },
                Kv: function() {
                    return eh
                },
                LE: function() {
                    return eL
                },
                LT: function() {
                    return eE
                },
                Lp: function() {
                    return eI
                },
                Lw: function() {
                    return e2
                },
                Mc: function() {
                    return et
                },
                Mr: function() {
                    return ef
                },
                NS: function() {
                    return U
                },
                NW: function() {
                    return eU
                },
                NZ: function() {
                    return td
                },
                Nf: function() {
                    return tt
                },
                Nq: function() {
                    return ej
                },
                Nv: function() {
                    return ec
                },
                Ny: function() {
                    return eo
                },
                OS: function() {
                    return e4
                },
                OT: function() {
                    return ek
                },
                PB: function() {
                    return to
                },
                PT: function() {
                    return ep
                },
                Ph: function() {
                    return eP
                },
                Q$: function() {
                    return ey
                },
                QU: function() {
                    return ed
                },
                Qj: function() {
                    return es
                },
                RP: function() {
                    return e5
                },
                R_: function() {
                    return eR
                },
                Rj: function() {
                    return eH
                },
                SM: function() {
                    return ts
                },
                Sh: function() {
                    return en
                },
                Tk: function() {
                    return eC
                },
                U6: function() {
                    return eb
                },
                Uk: function() {
                    return B
                },
                XA: function() {
                    return eQ
                },
                XP: function() {
                    return ea
                },
                Yk: function() {
                    return Y
                },
                Z8: function() {
                    return eT
                },
                Zm: function() {
                    return tf
                },
                _x: function() {
                    return e3
                },
                _z: function() {
                    return eN
                },
                bN: function() {
                    return eY
                },
                bO: function() {
                    return Q
                },
                bY: function() {
                    return eK
                },
                c9: function() {
                    return V
                },
                cp: function() {
                    return e8
                },
                eB: function() {
                    return eF
                },
                eH: function() {
                    return H
                },
                eg: function() {
                    return e9
                },
                fd: function() {
                    return er
                },
                gQ: function() {
                    return ei
                },
                gr: function() {
                    return el
                },
                hH: function() {
                    return ew
                },
                hj: function() {
                    return e0
                },
                i8: function() {
                    return eG
                },
                jQ: function() {
                    return te
                },
                jT: function() {
                    return eB
                },
                jf: function() {
                    return q
                },
                jg: function() {
                    return eA
                },
                lC: function() {
                    return eu
                },
                lp: function() {
                    return e7
                },
                mI: function() {
                    return e$
                },
                mT: function() {
                    return tp
                },
                n4: function() {
                    return eJ
                },
                n9: function() {
                    return t_
                },
                nX: function() {
                    return eO
                },
                ow: function() {
                    return ta
                },
                qq: function() {
                    return tg
                },
                t_: function() {
                    return tu
                },
                vB: function() {
                    return eS
                },
                vH: function() {
                    return tm
                },
                vO: function() {
                    return e6
                },
                vx: function() {
                    return eW
                },
                we: function() {
                    return eZ
                },
                wl: function() {
                    return ty
                },
                xe: function() {
                    return L
                },
                xf: function() {
                    return em
                },
                xm: function() {
                    return ez
                }
            });
            let R = "USER_LOADED",
                L = "RELOADING_USER",
                B = "WALLET_CHANGE",
                F = "SET_AFFILIATE",
                U = "SET_AUTO_BET_PLINKO",
                H = "SET_AUTO_BET_TOWER",
                q = "SET_AUTO_BET_MINE",
                V = "SET_BLACKJACK_TABLE",
                X = "SET_BLACKJACK_TABLES",
                K = "SET_BLACKJACK_DLS",
                Y = "SET_CURRENT_CASE_BATTLE",
                Q = "SET_FIRST_LOADED",
                et = "SET_WHERE_CAME_FROM",
                er = "SET_ANALYTICSID2",
                en = "SET_DISCOUNTS_STATE",
                ei = "UPDATE_PRIVACTE_MODE",
                eo = "AUTH_ERROR",
                ea = "LOGIN_SUCCESS",
                es = "LOGIN_FAIL",
                ec = "LOGOUT",
                el = "SHOW_MODAL",
                eu = "HIDE_MODAL",
                ed = "SET_IP_ADDRESS",
                ep = "HIDE_TWOFACTOR_MODAL",
                eh = "HIDE_PROVABLYCONFIG_MODAL",
                ef = "SHOW_DEPOSIT",
                em = "HIDE_DEPOSIT",
                eg = "SHOW_CRYPTO_DEPOSIT",
                ey = "SHOW_ROBUX_DEPOSIT",
                e_ = "SHOW_LAND_DEPOSIT",
                ev = "SHOW_TWOFACTOR_MODAL",
                eb = "SHOW_PROVABLYCONFIG_MODAL",
                eS = "SHOW_ITEMS_DEPOSIT",
                ew = "SHOW_DEPSOIT_ITEMS_SEMI",
                eE = "SHOW_GIFTCARD_DEPOSIT",
                ek = "SHOW_MARKETPLACE_MODAL",
                ex = "SHOW_CARDS_DEPOSIT",
                eI = "SHOW_SELLIX_DEPOSIT",
                eO = "HIDE_CRYPTO_DEPOSIT",
                eC = "HIDE_ROBUX_DEPOSIT",
                eM = "HIDE_LAND_DEPOSIT",
                eT = "HIDE_ITEMS_DEPOSIT",
                eA = "HIDE_GIFTCARD_DEPOSIT",
                eR = "HIDE_DEPSOIT_ITEMS_SEMI",
                eP = "HIDE_MARKETPLACE_MODAL",
                eD = "HIDE_CARDS_DEPOSIT",
                eL = "SHOW_PROVABLY",
                eN = "HIDE_PROVABLY",
                eB = "SHOW_PROMO_DEPOSIT",
                ej = "HIDE_PROMO_DEPOSIT",
                eF = "SESSION_REFRESH",
                eU = "SHOW_SOCIAL_MEDIA_DEPOSIT",
                eH = "HIDE_SOCIAL_MEDIA_DEPOSIT",
                eW = "HIDE_PROFILE",
                e$ = "SHOW_ROBUX_WITHDRAW",
                eq = "HIDE_ROBUX_WITHDRAW",
                eG = "SHOW_WITHDRAW",
                ez = "HIDE_WITHDRAW",
                eV = "HIDE_SELLIX_DEPOSIT",
                eJ = "SHOW_CHAT_RULES",
                eX = "HIDE_CHAT_RULES",
                eK = "SHOW_FAQ",
                eZ = "HIDE_FAQ",
                eY = "SHOW_HISTORY_MODAL",
                eQ = "HIDE_HISTORY_MODAL",
                e0 = "SHOW_INFO_MODAL",
                e1 = "HIDE_INFO_MODAL",
                e2 = "SHOW_CONFIRM_LGOUT",
                e3 = "HIDE_CONFIRM_LOGOUT",
                e5 = "SHOW_PAYGARDEN_DEPOSIT",
                e6 = "HIDE_PAYGARDEN_DEPOSIT",
                e4 = "SHOW_SWAPPED_DEPOSIT",
                e8 = "HIDE_SWAPPED_DEPOSIT",
                e9 = "HIDE_FREE_CASE_MODAL",
                e7 = "SHOW_FREE_CASE_MODAL",
                te = "SHOW_HOW_U_FOUND_US",
                tt = "SHOW_HOW_U_FOUND_US",
                tr = "SET_FFLAGS",
                tn = "SHOW_RETENTION_MODAL",
                ti = "SHOW_AGE_VERIFY_MODAL",
                to = "FORCE_AGE_VERIFY_MODAL",
                ta = "SHOW_MUTE_MODAL",
                ts = "HIDE_MUTE_MODAL",
                tc = "SHOW_DELETE_MODAL",
                tl = "HIDE_DELETE_MODAL",
                tu = "SHOW_TIP_MODAL",
                td = "HIDE_TIP_MODAL",
                tp = "HIDE_AGE_VERIFY_MODAL",
                th = "SHOW_GIVEAWAY_MODAL",
                tf = "HIDE_RETENTION_MODAL",
                tm = "HIDE_GIVEAWAY_MODAL",
                tg = "ENABLE_GEOBLOCK",
                ty = "HIDE_TWOFACTORTRADE_MODAL",
                t_ = "SET_GAME_IDS"
        },
        54847: function(m, _, C) {
            "use strict";

            function n(m) {
                for (var _ = arguments.length, C = Array(_ > 1 ? _ - 1 : 0), R = 1; R < _; R++) C[R - 1] = arguments[R];
                throw Error("[Immer] minified error nr: " + m + (C.length ? " " + C.map(function(m) {
                    return "'" + m + "'"
                }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf")
            }

            function r(m) {
                return !!m && !!m[K]
            }

            function t(m) {
                var _;
                return !!m && (function(m) {
                    if (!m || "object" != typeof m) return !1;
                    var _ = Object.getPrototypeOf(m);
                    if (null === _) return !0;
                    var C = Object.hasOwnProperty.call(_, "constructor") && _.constructor;
                    return C === Object || "function" == typeof C && Function.toString.call(C) === Y
                }(m) || Array.isArray(m) || !!m[X] || !!(null === (_ = m.constructor) || void 0 === _ ? void 0 : _[X]) || s(m) || v(m))
            }

            function i(m, _, C) {
                void 0 === C && (C = !1), 0 === o(m) ? (C ? Object.keys : Q)(m).forEach(function(R) {
                    C && "symbol" == typeof R || _(R, m[R], m)
                }) : m.forEach(function(C, R) {
                    return _(R, C, m)
                })
            }

            function o(m) {
                var _ = m[K];
                return _ ? _.i > 3 ? _.i - 4 : _.i : Array.isArray(m) ? 1 : s(m) ? 2 : v(m) ? 3 : 0
            }

            function u(m, _) {
                return 2 === o(m) ? m.has(_) : Object.prototype.hasOwnProperty.call(m, _)
            }

            function f(m, _, C) {
                var R = o(m);
                2 === R ? m.set(_, C) : 3 === R ? m.add(C) : m[_] = C
            }

            function c(m, _) {
                return m === _ ? 0 !== m || 1 / m == 1 / _ : m != m && _ != _
            }

            function s(m) {
                return U && m instanceof Map
            }

            function v(m) {
                return H && m instanceof Set
            }

            function p(m) {
                return m.o || m.t
            }

            function l(m) {
                if (Array.isArray(m)) return Array.prototype.slice.call(m);
                var _ = et(m);
                delete _[K];
                for (var C = Q(_), R = 0; R < C.length; R++) {
                    var L = C[R],
                        B = _[L];
                    !1 === B.writable && (B.writable = !0, B.configurable = !0), (B.get || B.set) && (_[L] = {
                        configurable: !0,
                        writable: !0,
                        enumerable: B.enumerable,
                        value: m[L]
                    })
                }
                return Object.create(Object.getPrototypeOf(m), _)
            }

            function d(m, _) {
                return void 0 === _ && (_ = !1), y(m) || r(m) || !t(m) || (o(m) > 1 && (m.set = m.add = m.clear = m.delete = h), Object.freeze(m), _ && i(m, function(m, _) {
                    return d(_, !0)
                }, !0)), m
            }

            function h() {
                n(2)
            }

            function y(m) {
                return null == m || "object" != typeof m || Object.isFrozen(m)
            }

            function b(m) {
                var _ = er[m];
                return _ || n(18, m), _
            }

            function j(m, _) {
                _ && (b("Patches"), m.u = [], m.s = [], m.v = _)
            }

            function g(m) {
                O(m), m.p.forEach(S), m.p = null
            }

            function O(m) {
                m === B && (B = m.l)
            }

            function w(m) {
                return B = {
                    p: [],
                    l: B,
                    h: m,
                    m: !0,
                    _: 0
                }
            }

            function S(m) {
                var _ = m[K];
                0 === _.i || 1 === _.i ? _.j() : _.g = !0
            }

            function P(m, _) {
                _._ = _.p.length;
                var C = _.p[0],
                    R = void 0 !== m && m !== C;
                return _.h.O || b("ES5").S(_, m, R), R ? (C[K].P && (g(_), n(4)), t(m) && (m = M(_, m), _.l || x(_, m)), _.u && b("Patches").M(C[K].t, m, _.u, _.s)) : m = M(_, C, []), g(_), _.u && _.v(_.u, _.s), m !== V ? m : void 0
            }

            function M(m, _, C) {
                if (y(_)) return _;
                var R = _[K];
                if (!R) return i(_, function(L, B) {
                    return A(m, R, _, L, B, C)
                }, !0), _;
                if (R.A !== m) return _;
                if (!R.P) return x(m, R.t, !0), R.t;
                if (!R.I) {
                    R.I = !0, R.A._--;
                    var L = 4 === R.i || 5 === R.i ? R.o = l(R.k) : R.o,
                        B = L,
                        F = !1;
                    3 === R.i && (B = new Set(L), L.clear(), F = !0), i(B, function(_, B) {
                        return A(m, R, L, _, B, C, F)
                    }), x(m, L, !1), C && m.u && b("Patches").N(R, C, m.u, m.s)
                }
                return R.o
            }

            function A(m, _, C, R, L, B, F) {
                if (r(L)) {
                    var U = M(m, L, B && _ && 3 !== _.i && !u(_.R, R) ? B.concat(R) : void 0);
                    if (f(C, R, U), !r(U)) return;
                    m.m = !1
                } else F && C.add(L);
                if (t(L) && !y(L)) {
                    if (!m.h.D && m._ < 1) return;
                    M(m, L), _ && _.A.l || x(m, L)
                }
            }

            function x(m, _, C) {
                void 0 === C && (C = !1), !m.l && m.h.D && m.m && d(_, C)
            }

            function z(m, _) {
                var C = m[K];
                return (C ? p(C) : m)[_]
            }

            function I(m, _) {
                if (_ in m)
                    for (var C = Object.getPrototypeOf(m); C;) {
                        var R = Object.getOwnPropertyDescriptor(C, _);
                        if (R) return R;
                        C = Object.getPrototypeOf(C)
                    }
            }

            function k(m) {
                m.P || (m.P = !0, m.l && k(m.l))
            }

            function E(m) {
                m.o || (m.o = l(m.t))
            }

            function N(m, _, C) {
                var R, L, F, U, H, q, V, X = s(_) ? b("MapSet").F(_, C) : v(_) ? b("MapSet").T(_, C) : m.O ? (F = L = {
                    i: (R = Array.isArray(_)) ? 1 : 0,
                    A: C ? C.A : B,
                    P: !1,
                    I: !1,
                    R: {},
                    l: C,
                    t: _,
                    k: null,
                    o: null,
                    j: null,
                    C: !1
                }, U = en, R && (F = [L], U = ei), q = (H = Proxy.revocable(F, U)).revoke, V = H.proxy, L.k = V, L.j = q, V) : b("ES5").J(_, C);
                return (C ? C.A : B).p.push(X), X
            }

            function D(m, _) {
                switch (_) {
                    case 2:
                        return new Map(m);
                    case 3:
                        return Array.from(m)
                }
                return l(m)
            }
            C.d(_, {
                Z: function() {
                    return eM
                }
            });
            var R, L, B, F = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"),
                U = "undefined" != typeof Map,
                H = "undefined" != typeof Set,
                q = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect,
                V = F ? Symbol.for("immer-nothing") : ((L = {})["immer-nothing"] = !0, L),
                X = F ? Symbol.for("immer-draftable") : "__$immer_draftable",
                K = F ? Symbol.for("immer-state") : "__$immer_state",
                Y = "" + Object.prototype.constructor,
                Q = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(m) {
                    return Object.getOwnPropertyNames(m).concat(Object.getOwnPropertySymbols(m))
                } : Object.getOwnPropertyNames,
                et = Object.getOwnPropertyDescriptors || function(m) {
                    var _ = {};
                    return Q(m).forEach(function(C) {
                        _[C] = Object.getOwnPropertyDescriptor(m, C)
                    }), _
                },
                er = {},
                en = {
                    get: function(m, _) {
                        if (_ === K) return m;
                        var C, R, L = p(m);
                        if (!u(L, _)) return (R = I(L, _)) ? "value" in R ? R.value : null === (C = R.get) || void 0 === C ? void 0 : C.call(m.k) : void 0;
                        var B = L[_];
                        return m.I || !t(B) ? B : B === z(m.t, _) ? (E(m), m.o[_] = N(m.A.h, B, m)) : B
                    },
                    has: function(m, _) {
                        return _ in p(m)
                    },
                    ownKeys: function(m) {
                        return Reflect.ownKeys(p(m))
                    },
                    set: function(m, _, C) {
                        var R = I(p(m), _);
                        if (null == R ? void 0 : R.set) return R.set.call(m.k, C), !0;
                        if (!m.P) {
                            var L = z(p(m), _),
                                B = null == L ? void 0 : L[K];
                            if (B && B.t === C) return m.o[_] = C, m.R[_] = !1, !0;
                            if (c(C, L) && (void 0 !== C || u(m.t, _))) return !0;
                            E(m), k(m)
                        }
                        return m.o[_] === C && (void 0 !== C || _ in m.o) || Number.isNaN(C) && Number.isNaN(m.o[_]) || (m.o[_] = C, m.R[_] = !0), !0
                    },
                    deleteProperty: function(m, _) {
                        return void 0 !== z(m.t, _) || _ in m.t ? (m.R[_] = !1, E(m), k(m)) : delete m.R[_], m.o && delete m.o[_], !0
                    },
                    getOwnPropertyDescriptor: function(m, _) {
                        var C = p(m),
                            R = Reflect.getOwnPropertyDescriptor(C, _);
                        return R ? {
                            writable: !0,
                            configurable: 1 !== m.i || "length" !== _,
                            enumerable: R.enumerable,
                            value: C[_]
                        } : R
                    },
                    defineProperty: function() {
                        n(11)
                    },
                    getPrototypeOf: function(m) {
                        return Object.getPrototypeOf(m.t)
                    },
                    setPrototypeOf: function() {
                        n(12)
                    }
                },
                ei = {};
            i(en, function(m, _) {
                ei[m] = function() {
                    return arguments[0] = arguments[0][0], _.apply(this, arguments)
                }
            }), ei.deleteProperty = function(m, _) {
                return ei.set.call(this, m, _, void 0)
            }, ei.set = function(m, _, C) {
                return en.set.call(this, m[0], _, C, m[0])
            };
            var eo = new(function() {
                function e(m) {
                    var _ = this;
                    this.O = q, this.D = !0, this.produce = function(m, C, R) {
                        if ("function" == typeof m && "function" != typeof C) {
                            var L, B = C;
                            return C = m,
                                function(m) {
                                    var R = this;
                                    void 0 === m && (m = B);
                                    for (var L = arguments.length, F = Array(L > 1 ? L - 1 : 0), U = 1; U < L; U++) F[U - 1] = arguments[U];
                                    return _.produce(m, function(m) {
                                        var _;
                                        return (_ = C).call.apply(_, [R, m].concat(F))
                                    })
                                }
                        }
                        if ("function" != typeof C && n(6), void 0 !== R && "function" != typeof R && n(7), t(m)) {
                            var F = w(_),
                                U = N(_, m, void 0),
                                H = !0;
                            try {
                                L = C(U), H = !1
                            } finally {
                                H ? g(F) : O(F)
                            }
                            return "undefined" != typeof Promise && L instanceof Promise ? L.then(function(m) {
                                return j(F, R), P(m, F)
                            }, function(m) {
                                throw g(F), m
                            }) : (j(F, R), P(L, F))
                        }
                        if (!m || "object" != typeof m) {
                            if (void 0 === (L = C(m)) && (L = m), L === V && (L = void 0), _.D && d(L, !0), R) {
                                var q = [],
                                    X = [];
                                b("Patches").M(m, L, q, X), R(q, X)
                            }
                            return L
                        }
                        n(21, m)
                    }, this.produceWithPatches = function(m, C) {
                        if ("function" == typeof m) return function(C) {
                            for (var R = arguments.length, L = Array(R > 1 ? R - 1 : 0), B = 1; B < R; B++) L[B - 1] = arguments[B];
                            return _.produceWithPatches(C, function(_) {
                                return m.apply(void 0, [_].concat(L))
                            })
                        };
                        var R, L, B = _.produce(m, C, function(m, _) {
                            R = m, L = _
                        });
                        return "undefined" != typeof Promise && B instanceof Promise ? B.then(function(m) {
                            return [m, R, L]
                        }) : [B, R, L]
                    }, "boolean" == typeof(null == m ? void 0 : m.useProxies) && this.setUseProxies(m.useProxies), "boolean" == typeof(null == m ? void 0 : m.autoFreeze) && this.setAutoFreeze(m.autoFreeze)
                }
                var m = e.prototype;
                return m.createDraft = function(m) {
                    t(m) || n(8), r(m) && (r(_ = m) || n(22, _), m = function n(m) {
                        if (!t(m)) return m;
                        var _, C = m[K],
                            R = o(m);
                        if (C) {
                            if (!C.P && (C.i < 4 || !b("ES5").K(C))) return C.t;
                            C.I = !0, _ = D(m, R), C.I = !1
                        } else _ = D(m, R);
                        return i(_, function(m, R) {
                            var L;
                            C && (2 === o(L = C.t) ? L.get(m) : L[m]) === R || f(_, m, n(R))
                        }), 3 === R ? new Set(_) : _
                    }(_));
                    var _, C = w(this),
                        R = N(this, m, void 0);
                    return R[K].C = !0, O(C), R
                }, m.finishDraft = function(m, _) {
                    var C = (m && m[K]).A;
                    return j(C, _), P(void 0, C)
                }, m.setAutoFreeze = function(m) {
                    this.D = m
                }, m.setUseProxies = function(m) {
                    m && !q && n(20), this.O = m
                }, m.applyPatches = function(m, _) {
                    for (C = _.length - 1; C >= 0; C--) {
                        var C, R = _[C];
                        if (0 === R.path.length && "replace" === R.op) {
                            m = R.value;
                            break
                        }
                    }
                    C > -1 && (_ = _.slice(C + 1));
                    var L = b("Patches").$;
                    return r(m) ? L(m, _) : this.produce(m, function(m) {
                        return L(m, _)
                    })
                }, e
            }());
            eo.produce, eo.produceWithPatches.bind(eo), eo.setAutoFreeze.bind(eo), eo.setUseProxies.bind(eo), eo.applyPatches.bind(eo), eo.createDraft.bind(eo), eo.finishDraft.bind(eo);
            var ea = C(1413);

            function formatProdErrorMessage(m) {
                return "Minified Redux error #" + m + "; visit https://redux.js.org/Errors?code=" + m + " for the full message or use the non-minified dev environment for full errors. "
            }
            var es = "function" == typeof Symbol && Symbol.observable || "@@observable",
                randomString = function() {
                    return Math.random().toString(36).substring(7).split("").join(".")
                },
                ec = {
                    INIT: "@@redux/INIT" + randomString(),
                    REPLACE: "@@redux/REPLACE" + randomString(),
                    PROBE_UNKNOWN_ACTION: function() {
                        return "@@redux/PROBE_UNKNOWN_ACTION" + randomString()
                    }
                };

            function compose() {
                for (var m = arguments.length, _ = Array(m), C = 0; C < m; C++) _[C] = arguments[C];
                return 0 === _.length ? function(m) {
                    return m
                } : 1 === _.length ? _[0] : _.reduce(function(m, _) {
                    return function() {
                        return m(_.apply(void 0, arguments))
                    }
                })
            }

            function applyMiddleware() {
                for (var m = arguments.length, _ = Array(m), C = 0; C < m; C++) _[C] = arguments[C];
                return function(m) {
                    return function() {
                        var C = m.apply(void 0, arguments),
                            _dispatch = function() {
                                throw Error(formatProdErrorMessage(15))
                            },
                            R = {
                                getState: C.getState,
                                dispatch: function() {
                                    return _dispatch.apply(void 0, arguments)
                                }
                            },
                            L = _.map(function(m) {
                                return m(R)
                            });
                        return _dispatch = compose.apply(void 0, L)(C.dispatch), (0, ea.Z)((0, ea.Z)({}, C), {}, {
                            dispatch: _dispatch
                        })
                    }
                }
            }

            function createThunkMiddleware(m) {
                return function(_) {
                    var C = _.dispatch,
                        R = _.getState;
                    return function(_) {
                        return function(L) {
                            return "function" == typeof L ? L(C, R, m) : _(L)
                        }
                    }
                }
            }
            var el = createThunkMiddleware();
            el.withExtraArgument = createThunkMiddleware, C(34155);
            var eu = (R = function(m, _) {
                    return (R = Object.setPrototypeOf || ({
                        __proto__: []
                    }) instanceof Array && function(m, _) {
                        m.__proto__ = _
                    } || function(m, _) {
                        for (var C in _) Object.prototype.hasOwnProperty.call(_, C) && (m[C] = _[C])
                    })(m, _)
                }, function(m, _) {
                    if ("function" != typeof _ && null !== _) throw TypeError("Class extends value " + String(_) + " is not a constructor or null");

                    function __() {
                        this.constructor = m
                    }
                    R(m, _), m.prototype = null === _ ? Object.create(_) : (__.prototype = _.prototype, new __)
                }),
                __generator = function(m, _) {
                    var C, R, L, B, F = {
                        label: 0,
                        sent: function() {
                            if (1 & L[0]) throw L[1];
                            return L[1]
                        },
                        trys: [],
                        ops: []
                    };
                    return B = {
                        next: verb(0),
                        throw: verb(1),
                        return: verb(2)
                    }, "function" == typeof Symbol && (B[Symbol.iterator] = function() {
                        return this
                    }), B;

                    function verb(B) {
                        return function(U) {
                            return function(B) {
                                if (C) throw TypeError("Generator is already executing.");
                                for (; F;) try {
                                    if (C = 1, R && (L = 2 & B[0] ? R.return : B[0] ? R.throw || ((L = R.return) && L.call(R), 0) : R.next) && !(L = L.call(R, B[1])).done) return L;
                                    switch (R = 0, L && (B = [2 & B[0], L.value]), B[0]) {
                                        case 0:
                                        case 1:
                                            L = B;
                                            break;
                                        case 4:
                                            return F.label++, {
                                                value: B[1],
                                                done: !1
                                            };
                                        case 5:
                                            F.label++, R = B[1], B = [0];
                                            continue;
                                        case 7:
                                            B = F.ops.pop(), F.trys.pop();
                                            continue;
                                        default:
                                            if (!(L = (L = F.trys).length > 0 && L[L.length - 1]) && (6 === B[0] || 2 === B[0])) {
                                                F = 0;
                                                continue
                                            }
                                            if (3 === B[0] && (!L || B[1] > L[0] && B[1] < L[3])) {
                                                F.label = B[1];
                                                break
                                            }
                                            if (6 === B[0] && F.label < L[1]) {
                                                F.label = L[1], L = B;
                                                break
                                            }
                                            if (L && F.label < L[2]) {
                                                F.label = L[2], F.ops.push(B);
                                                break
                                            }
                                            L[2] && F.ops.pop(), F.trys.pop();
                                            continue
                                    }
                                    B = _.call(m, F)
                                } catch (m) {
                                    B = [6, m], R = 0
                                } finally {
                                    C = L = 0
                                }
                                if (5 & B[0]) throw B[1];
                                return {
                                    value: B[0] ? B[1] : void 0,
                                    done: !0
                                }
                            }([B, U])
                        }
                    }
                },
                __spreadArray = function(m, _) {
                    for (var C = 0, R = _.length, L = m.length; C < R; C++, L++) m[L] = _[C];
                    return m
                },
                ed = Object.defineProperty,
                ep = Object.defineProperties,
                eh = Object.getOwnPropertyDescriptors,
                ef = Object.getOwnPropertySymbols,
                em = Object.prototype.hasOwnProperty,
                eg = Object.prototype.propertyIsEnumerable,
                __defNormalProp = function(m, _, C) {
                    return _ in m ? ed(m, _, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: C
                    }) : m[_] = C
                },
                __spreadValues = function(m, _) {
                    for (var C in _ || (_ = {})) em.call(_, C) && __defNormalProp(m, C, _[C]);
                    if (ef)
                        for (var R = 0, L = ef(_); R < L.length; R++) {
                            var C = L[R];
                            eg.call(_, C) && __defNormalProp(m, C, _[C])
                        }
                    return m
                },
                __spreadProps = function(m, _) {
                    return ep(m, eh(_))
                },
                ey = "undefined" != typeof window && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
                    if (0 != arguments.length) return "object" == typeof arguments[0] ? compose : compose.apply(null, arguments)
                };

            function createAction(m, _) {
                function actionCreator() {
                    for (var C = [], R = 0; R < arguments.length; R++) C[R] = arguments[R];
                    if (_) {
                        var L = _.apply(void 0, C);
                        if (!L) throw Error("prepareAction did not return an object");
                        return __spreadValues(__spreadValues({
                            type: m,
                            payload: L.payload
                        }, "meta" in L && {
                            meta: L.meta
                        }), "error" in L && {
                            error: L.error
                        })
                    }
                    return {
                        type: m,
                        payload: C[0]
                    }
                }
                return actionCreator.toString = function() {
                    return "" + m
                }, actionCreator.type = m, actionCreator.match = function(_) {
                    return _.type === m
                }, actionCreator
            }
            "undefined" != typeof window && window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__;
            var e_ = function(m) {
                    function MiddlewareArray() {
                        for (var _ = [], C = 0; C < arguments.length; C++) _[C] = arguments[C];
                        var R = m.apply(this, _) || this;
                        return Object.setPrototypeOf(R, MiddlewareArray.prototype), R
                    }
                    return eu(MiddlewareArray, m), Object.defineProperty(MiddlewareArray, Symbol.species, {
                        get: function() {
                            return MiddlewareArray
                        },
                        enumerable: !1,
                        configurable: !0
                    }), MiddlewareArray.prototype.concat = function() {
                        for (var _ = [], C = 0; C < arguments.length; C++) _[C] = arguments[C];
                        return m.prototype.concat.apply(this, _)
                    }, MiddlewareArray.prototype.prepend = function() {
                        for (var m = [], _ = 0; _ < arguments.length; _++) m[_] = arguments[_];
                        return 1 === m.length && Array.isArray(m[0]) ? new(MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], m[0].concat(this)))) : new(MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], m.concat(this))))
                    }, MiddlewareArray
                }(Array),
                ev = function(m) {
                    function EnhancerArray() {
                        for (var _ = [], C = 0; C < arguments.length; C++) _[C] = arguments[C];
                        var R = m.apply(this, _) || this;
                        return Object.setPrototypeOf(R, EnhancerArray.prototype), R
                    }
                    return eu(EnhancerArray, m), Object.defineProperty(EnhancerArray, Symbol.species, {
                        get: function() {
                            return EnhancerArray
                        },
                        enumerable: !1,
                        configurable: !0
                    }), EnhancerArray.prototype.concat = function() {
                        for (var _ = [], C = 0; C < arguments.length; C++) _[C] = arguments[C];
                        return m.prototype.concat.apply(this, _)
                    }, EnhancerArray.prototype.prepend = function() {
                        for (var m = [], _ = 0; _ < arguments.length; _++) m[_] = arguments[_];
                        return 1 === m.length && Array.isArray(m[0]) ? new(EnhancerArray.bind.apply(EnhancerArray, __spreadArray([void 0], m[0].concat(this)))) : new(EnhancerArray.bind.apply(EnhancerArray, __spreadArray([void 0], m.concat(this))))
                    }, EnhancerArray
                }(Array);

            function getDefaultMiddleware(m) {
                void 0 === m && (m = {});
                var _ = m.thunk,
                    C = void 0 === _ || _;
                m.immutableCheck, m.serializableCheck, m.actionCreatorCheck;
                var R = new e_;
                return C && ("boolean" == typeof C ? R.push(el) : R.push(el.withExtraArgument(C.extraArgument))), R
            }
            var nanoid = function(m) {
                    void 0 === m && (m = 21);
                    for (var _ = "", C = m; C--;) _ += "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW" [64 * Math.random() | 0];
                    return _
                },
                eb = ["name", "message", "stack", "code"],
                RejectWithValue = function(m, _) {
                    this.payload = m, this.meta = _
                },
                FulfillWithMeta = function(m, _) {
                    this.payload = m, this.meta = _
                },
                miniSerializeError = function(m) {
                    if ("object" == typeof m && null !== m) {
                        for (var _ = {}, C = 0; C < eb.length; C++) {
                            var R = eb[C];
                            "string" == typeof m[R] && (_[R] = m[R])
                        }
                        return _
                    }
                    return {
                        message: String(m)
                    }
                };

            function unwrapResult(m) {
                if (m.meta && m.meta.rejectedWithValue) throw m.payload;
                if (m.error) throw m.error;
                return m.payload
            }! function() {
                function createAsyncThunk2(m, _, C) {
                    var R = createAction(m + "/fulfilled", function(m, _, C, R) {
                            return {
                                payload: m,
                                meta: __spreadProps(__spreadValues({}, R || {}), {
                                    arg: C,
                                    requestId: _,
                                    requestStatus: "fulfilled"
                                })
                            }
                        }),
                        L = createAction(m + "/pending", function(m, _, C) {
                            return {
                                payload: void 0,
                                meta: __spreadProps(__spreadValues({}, C || {}), {
                                    arg: _,
                                    requestId: m,
                                    requestStatus: "pending"
                                })
                            }
                        }),
                        B = createAction(m + "/rejected", function(m, _, R, L, B) {
                            return {
                                payload: L,
                                error: (C && C.serializeError || miniSerializeError)(m || "Rejected"),
                                meta: __spreadProps(__spreadValues({}, B || {}), {
                                    arg: R,
                                    requestId: _,
                                    rejectedWithValue: !!L,
                                    requestStatus: "rejected",
                                    aborted: (null == m ? void 0 : m.name) === "AbortError",
                                    condition: (null == m ? void 0 : m.name) === "ConditionError"
                                })
                            }
                        }),
                        F = "undefined" != typeof AbortController ? AbortController : function() {
                            function class_1() {
                                this.signal = {
                                    aborted: !1,
                                    addEventListener: function() {},
                                    dispatchEvent: function() {
                                        return !1
                                    },
                                    onabort: function() {},
                                    removeEventListener: function() {},
                                    reason: void 0,
                                    throwIfAborted: function() {}
                                }
                            }
                            return class_1.prototype.abort = function() {}, class_1
                        }();
                    return Object.assign(function(m) {
                        return function(U, H, q) {
                            var V, X = (null == C ? void 0 : C.idGenerator) ? C.idGenerator(m) : nanoid(),
                                K = new F;

                            function abort(m) {
                                V = m, K.abort()
                            }
                            var Y = function() {
                                var F, Y;
                                return F = this, Y = function() {
                                    var F, Y, Q, et, er, en;
                                    return __generator(this, function(ei) {
                                        switch (ei.label) {
                                            case 0:
                                                var eo;
                                                if (ei.trys.push([0, 4, , 5]), !(null !== (eo = et = null == (F = null == C ? void 0 : C.condition) ? void 0 : F.call(C, m, {
                                                        getState: H,
                                                        extra: q
                                                    })) && "object" == typeof eo && "function" == typeof eo.then)) return [3, 2];
                                                return [4, et];
                                            case 1:
                                                et = ei.sent(), ei.label = 2;
                                            case 2:
                                                if (!1 === et || K.signal.aborted) throw {
                                                    name: "ConditionError",
                                                    message: "Aborted due to condition callback returning false."
                                                };
                                                return er = new Promise(function(m, _) {
                                                    return K.signal.addEventListener("abort", function() {
                                                        return _({
                                                            name: "AbortError",
                                                            message: V || "Aborted"
                                                        })
                                                    })
                                                }), U(L(X, m, null == (Y = null == C ? void 0 : C.getPendingMeta) ? void 0 : Y.call(C, {
                                                    requestId: X,
                                                    arg: m
                                                }, {
                                                    getState: H,
                                                    extra: q
                                                }))), [4, Promise.race([er, Promise.resolve(_(m, {
                                                    dispatch: U,
                                                    getState: H,
                                                    extra: q,
                                                    requestId: X,
                                                    signal: K.signal,
                                                    abort: abort,
                                                    rejectWithValue: function(m, _) {
                                                        return new RejectWithValue(m, _)
                                                    },
                                                    fulfillWithValue: function(m, _) {
                                                        return new FulfillWithMeta(m, _)
                                                    }
                                                })).then(function(_) {
                                                    if (_ instanceof RejectWithValue) throw _;
                                                    return _ instanceof FulfillWithMeta ? R(_.payload, X, m, _.meta) : R(_, X, m)
                                                })])];
                                            case 3:
                                                return Q = ei.sent(), [3, 5];
                                            case 4:
                                                return Q = (en = ei.sent()) instanceof RejectWithValue ? B(null, X, m, en.payload, en.meta) : B(en, X, m), [3, 5];
                                            case 5:
                                                return C && !C.dispatchConditionRejection && B.match(Q) && Q.meta.condition || U(Q), [2, Q]
                                        }
                                    })
                                }, new Promise(function(m, _) {
                                    var fulfilled = function(m) {
                                            try {
                                                step(Y.next(m))
                                            } catch (m) {
                                                _(m)
                                            }
                                        },
                                        rejected = function(m) {
                                            try {
                                                step(Y.throw(m))
                                            } catch (m) {
                                                _(m)
                                            }
                                        },
                                        step = function(_) {
                                            return _.done ? m(_.value) : Promise.resolve(_.value).then(fulfilled, rejected)
                                        };
                                    step((Y = Y.apply(F, null)).next())
                                })
                            }();
                            return Object.assign(Y, {
                                abort: abort,
                                requestId: X,
                                arg: m,
                                unwrap: function() {
                                    return Y.then(unwrapResult)
                                }
                            })
                        }
                    }, {
                        pending: L,
                        rejected: B,
                        fulfilled: R,
                        typePrefix: m
                    })
                }
                createAsyncThunk2.withTypes = function() {
                    return createAsyncThunk2
                }
            }();
            var eS = "listenerMiddleware";
            createAction(eS + "/add"), createAction(eS + "/removeAll"), createAction(eS + "/remove"), "function" == typeof queueMicrotask && queueMicrotask.bind("undefined" != typeof window ? window : void 0 !== C.g ? C.g : globalThis), "undefined" != typeof window && window.requestAnimationFrame && window.requestAnimationFrame,
                function() {
                    function t(_, C) {
                        var R = m[_];
                        return R ? R.enumerable = C : m[_] = R = {
                            configurable: !0,
                            enumerable: C,
                            get: function() {
                                var m = this[K];
                                return en.get(m, _)
                            },
                            set: function(m) {
                                var C = this[K];
                                en.set(C, _, m)
                            }
                        }, R
                    }

                    function e(m) {
                        for (var _ = m.length - 1; _ >= 0; _--) {
                            var C = m[_][K];
                            if (!C.P) switch (C.i) {
                                case 5:
                                    a(C) && k(C);
                                    break;
                                case 4:
                                    o(C) && k(C)
                            }
                        }
                    }

                    function o(m) {
                        for (var _ = m.t, C = m.k, R = Q(C), L = R.length - 1; L >= 0; L--) {
                            var B = R[L];
                            if (B !== K) {
                                var F = _[B];
                                if (void 0 === F && !u(_, B)) return !0;
                                var U = C[B],
                                    H = U && U[K];
                                if (H ? H.t !== F : !c(U, F)) return !0
                            }
                        }
                        var q = !!_[K];
                        return R.length !== Q(_).length + (q ? 0 : 1)
                    }

                    function a(m) {
                        var _ = m.k;
                        if (_.length !== m.t.length) return !0;
                        var C = Object.getOwnPropertyDescriptor(_, _.length - 1);
                        if (C && !C.get) return !0;
                        for (var R = 0; R < _.length; R++)
                            if (!_.hasOwnProperty(R)) return !0;
                        return !1
                    }
                    var m = {};
                    er.ES5 || (er.ES5 = {
                        J: function(m, _) {
                            var C = Array.isArray(m),
                                R = function(m, _) {
                                    if (m) {
                                        for (var C = Array(_.length), R = 0; R < _.length; R++) Object.defineProperty(C, "" + R, t(R, !0));
                                        return C
                                    }
                                    var L = et(_);
                                    delete L[K];
                                    for (var B = Q(L), F = 0; F < B.length; F++) {
                                        var U = B[F];
                                        L[U] = t(U, m || !!L[U].enumerable)
                                    }
                                    return Object.create(Object.getPrototypeOf(_), L)
                                }(C, m),
                                L = {
                                    i: C ? 5 : 4,
                                    A: _ ? _.A : B,
                                    P: !1,
                                    I: !1,
                                    R: {},
                                    l: _,
                                    t: m,
                                    k: R,
                                    o: null,
                                    g: !1,
                                    C: !1
                                };
                            return Object.defineProperty(R, K, {
                                value: L,
                                writable: !0
                            }), R
                        },
                        S: function(m, _, C) {
                            C ? r(_) && _[K].A === m && e(m.p) : (m.u && function n(m) {
                                if (m && "object" == typeof m) {
                                    var _ = m[K];
                                    if (_) {
                                        var C = _.t,
                                            R = _.k,
                                            L = _.R,
                                            B = _.i;
                                        if (4 === B) i(R, function(m) {
                                            m !== K && (void 0 !== C[m] || u(C, m) ? L[m] || n(R[m]) : (L[m] = !0, k(_)))
                                        }), i(C, function(m) {
                                            void 0 !== R[m] || u(R, m) || (L[m] = !1, k(_))
                                        });
                                        else if (5 === B) {
                                            if (a(_) && (k(_), L.length = !0), R.length < C.length)
                                                for (var F = R.length; F < C.length; F++) L[F] = !1;
                                            else
                                                for (var U = C.length; U < R.length; U++) L[U] = !0;
                                            for (var H = Math.min(R.length, C.length), q = 0; q < H; q++) R.hasOwnProperty(q) || (L[q] = !0), void 0 === L[q] && n(R[q])
                                        }
                                    }
                                }
                            }(m.p[0]), e(m.p))
                        },
                        K: function(m) {
                            return 4 === m.i ? o(m) : a(m)
                        }
                    })
                }();
            var ew = C(62961),
                eE = C(49089),
                ek = C(40400),
                ex = C(83198);
            let eI = {};
            eI = {
                factoredTradeModal: {
                    visible: !1,
                    tradeId: 0
                },
                token: localStorage.getItem("token"),
                firstLoaded: !1,
                analyticsId2: null,
                ipAddress: null,
                fflags: {
                    slots_enabled: null
                },
                cbGame: null,
                bjTables: null,
                bjTable: null,
                bjDecisions: {
                    currentDecision: null,
                    decisionList: []
                },
                discounts: null,
                isAuthenticated: null,
                lastSessionRefresh: 0,
                isLoading: !0,
                user: null,
                affiliate: null,
                wherefromcard: !1,
                autoBetPlinko: !1,
                autoBetTower: !1,
                autoBetMine: !1,
                showLoginModal: !1,
                showWithdraw: !1,
                showProvably: {
                    show: !1,
                    provablyData: null
                },
                showDeposit: null,
                showCryptoDeposit: null,
                showHowUFoundUs: null,
                showSellixDeposit: null,
                showPaygardenDeposit: null,
                showSwappedDeposit: null,
                showFreeCaseModal: null,
                showGiftcardDeposit: null,
                showRobuxDeposit: null,
                showItemsDeposit: null,
                showItemsSemiDeposit: null,
                showLandDeposit: null,
                showPromoDeposit: null,
                showSocialMediaDeposit: null,
                showMarketplaceModal: null,
                showRobuxWithdraw: null,
                showChatRules: !1,
                showFaq: !1,
                showConfirmLogout: !1,
                showRentionModal: !1,
                showAgeVerifyModal: !1,
                showGiveawayModal: !0,
                showInfo: {
                    show: !1,
                    infoFor: null
                },
                showHistoryModal: {
                    show: !1,
                    gameType: null,
                    historyData: null
                },
                showMuteModal: {
                    show: !1,
                    message: null
                },
                showDeleteModal: {
                    show: !1,
                    message: null
                },
                showTipModal: {
                    show: !1,
                    message: null
                }
            };
            let eO = getDefaultMiddleware({
                    immutableCheck: !1,
                    serializableCheck: !1
                }),
                eC = function(m) {
                    var _, curriedGetDefaultMiddleware = function(m) {
                            return getDefaultMiddleware(m)
                        },
                        C = m || {},
                        R = C.reducer,
                        L = void 0 === R ? void 0 : R,
                        B = C.middleware,
                        F = void 0 === B ? curriedGetDefaultMiddleware() : B,
                        U = C.devTools,
                        H = void 0 === U || U,
                        q = C.preloadedState,
                        V = void 0 === q ? void 0 : q,
                        X = C.enhancers,
                        K = void 0 === X ? void 0 : X;
                    if ("function" == typeof L) _ = L;
                    else if (function(m) {
                            if ("object" != typeof m || null === m) return !1;
                            var _ = Object.getPrototypeOf(m);
                            if (null === _) return !0;
                            for (var C = _; null !== Object.getPrototypeOf(C);) C = Object.getPrototypeOf(C);
                            return _ === C
                        }(L)) _ = function(m) {
                        for (var _, C = Object.keys(m), R = {}, L = 0; L < C.length; L++) {
                            var B = C[L];
                            "function" == typeof m[B] && (R[B] = m[B])
                        }
                        var F = Object.keys(R);
                        try {
                            ! function(m) {
                                Object.keys(m).forEach(function(_) {
                                    var C = m[_];
                                    if (void 0 === C(void 0, {
                                            type: ec.INIT
                                        })) throw Error(formatProdErrorMessage(12));
                                    if (void 0 === C(void 0, {
                                            type: ec.PROBE_UNKNOWN_ACTION()
                                        })) throw Error(formatProdErrorMessage(13))
                                })
                            }(R)
                        } catch (m) {
                            _ = m
                        }
                        return function(m, C) {
                            if (void 0 === m && (m = {}), _) throw _;
                            for (var L = !1, B = {}, U = 0; U < F.length; U++) {
                                var H = F[U],
                                    q = R[H],
                                    V = m[H],
                                    X = q(V, C);
                                if (void 0 === X) throw C && C.type, Error(formatProdErrorMessage(14));
                                B[H] = X, L = L || X !== V
                            }
                            return (L = L || F.length !== Object.keys(m).length) ? B : m
                        }
                    }(L);
                    else throw Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
                    var Y = F;
                    "function" == typeof Y && (Y = Y(curriedGetDefaultMiddleware));
                    var Q = applyMiddleware.apply(void 0, Y),
                        et = compose;
                    H && (et = ey(__spreadValues({
                        trace: !1
                    }, "object" == typeof H && H)));
                    var er = new ev(Q),
                        en = er;
                    return Array.isArray(K) ? en = __spreadArray([Q], K) : "function" == typeof K && (en = K(er)),
                        function createStore(m, _, C) {
                            if ("function" == typeof _ && "function" == typeof C || "function" == typeof C && "function" == typeof arguments[3]) throw Error(formatProdErrorMessage(0));
                            if ("function" == typeof _ && void 0 === C && (C = _, _ = void 0), void 0 !== C) {
                                if ("function" != typeof C) throw Error(formatProdErrorMessage(1));
                                return C(createStore)(m, _)
                            }
                            if ("function" != typeof m) throw Error(formatProdErrorMessage(2));
                            var R, L = m,
                                B = _,
                                F = [],
                                U = F,
                                H = !1;

                            function ensureCanMutateNextListeners() {
                                U === F && (U = F.slice())
                            }

                            function getState() {
                                if (H) throw Error(formatProdErrorMessage(3));
                                return B
                            }

                            function subscribe(m) {
                                if ("function" != typeof m) throw Error(formatProdErrorMessage(4));
                                if (H) throw Error(formatProdErrorMessage(5));
                                var _ = !0;
                                return ensureCanMutateNextListeners(), U.push(m),
                                    function() {
                                        if (_) {
                                            if (H) throw Error(formatProdErrorMessage(6));
                                            _ = !1, ensureCanMutateNextListeners();
                                            var C = U.indexOf(m);
                                            U.splice(C, 1), F = null
                                        }
                                    }
                            }

                            function dispatch(m) {
                                if (! function(m) {
                                        if ("object" != typeof m || null === m) return !1;
                                        for (var _ = m; null !== Object.getPrototypeOf(_);) _ = Object.getPrototypeOf(_);
                                        return Object.getPrototypeOf(m) === _
                                    }(m)) throw Error(formatProdErrorMessage(7));
                                if (void 0 === m.type) throw Error(formatProdErrorMessage(8));
                                if (H) throw Error(formatProdErrorMessage(9));
                                try {
                                    H = !0, B = L(B, m)
                                } finally {
                                    H = !1
                                }
                                for (var _ = F = U, C = 0; C < _.length; C++)(0, _[C])();
                                return m
                            }
                            return dispatch({
                                type: ec.INIT
                            }), (R = {
                                dispatch: dispatch,
                                subscribe: subscribe,
                                getState: getState,
                                replaceReducer: function(m) {
                                    if ("function" != typeof m) throw Error(formatProdErrorMessage(10));
                                    L = m, dispatch({
                                        type: ec.REPLACE
                                    })
                                }
                            })[es] = function() {
                                var m;
                                return (m = {
                                    subscribe: function(m) {
                                        if ("object" != typeof m || null === m) throw Error(formatProdErrorMessage(11));

                                        function observeState() {
                                            m.next && m.next(getState())
                                        }
                                        return observeState(), {
                                            unsubscribe: subscribe(observeState)
                                        }
                                    }
                                })[es] = function() {
                                    return this
                                }, m
                            }, R
                        }(_, V, et.apply(void 0, en))
                }({
                    reducer: {
                        auth: function() {
                            var m, _, C;
                            let R = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eI,
                                L = arguments.length > 1 ? arguments[1] : void 0,
                                {
                                    type: B,
                                    payload: F,
                                    shouldSendEvent: U
                                } = L;
                            if (B.startsWith("SHOW_PROFILE_")) return { ...R,
                                showProfileModal: !0,
                                profileModalUserId: parseInt(B.substring(13))
                            };
                            if (B.startsWith("SHOW_ACCEPT_TRADE_")) return { ...R,
                                factoredTradeModal: {
                                    visible: !0,
                                    tradeId: parseInt(B.substring(18))
                                }
                            };
                            switch (B) {
                                case ew.wl:
                                    return { ...R,
                                        factoredTradeModal: {
                                            visible: !1,
                                            tradeId: null
                                        }
                                    };
                                case ew.eB:
                                    return { ...R,
                                        lastSessionRefresh: Date.now()
                                    };
                                case ew.BU:
                                    return { ...R,
                                        fflags: F
                                    };
                                case ew.vH:
                                    return { ...R,
                                        showGiveawayModal: !1
                                    };
                                case ew.vx:
                                    return { ...R,
                                        showProfileModal: !1
                                    };
                                case ew.lC:
                                    return { ...R,
                                        showLoginModal: !1
                                    };
                                case ew.QU:
                                    return { ...R,
                                        ipAddress: F
                                    };
                                case ew.IP:
                                    return { ...R,
                                        showGiveawayModal: !0
                                    };
                                case ew.Mr:
                                    return U && (R.fflags.fe_posthog_enabled, R.fflags.fe_ga_enabled && eE.ZP.event({
                                        action: "DEPOSIT_MODAL_OPENED",
                                        category: "Auth"
                                    }), R.fflags.fe_mixpanel_enabled && ex.Z.track("DEPOSIT_MODAL_OPENED")), { ...R,
                                        showDeposit: !0
                                    };
                                case ew.xf:
                                    return { ...R,
                                        showDeposit: !1
                                    };
                                case ew.PB:
                                    return { ...R,
                                        showAgeVerifyModal: {
                                            visible: !0,
                                            forced: !0
                                        },
                                        showDeposit: !1
                                    };
                                case ew.Gu:
                                    return { ...R,
                                        showAgeVerifyModal: !0,
                                        showDeposit: !1
                                    };
                                case ew.mT:
                                    return { ...R,
                                        showAgeVerifyModal: !1
                                    };
                                case ew.DQ:
                                    return { ...R,
                                        showRentionModal: !0,
                                        showDeposit: !1
                                    };
                                case ew.Zm:
                                    return { ...R,
                                        showRentionModal: !1
                                    };
                                case ew.Lp:
                                    return R.fflags.fe_posthog_enabled, R.fflags.fe_ga_enabled && eE.ZP.event({
                                        action: "CRYPTO_DEPOSIT_OPENED",
                                        category: "Auth"
                                    }), R.fflags.fe_mixpanel_enabled && ex.Z.track("CRYPTO_DEPOSIT_OPENED"), { ...R,
                                        showSellixDeposit: !0,
                                        showDeposit: !1
                                    };
                                case ew.$H:
                                    return { ...R,
                                        showCryptoDeposit: !0,
                                        showDeposit: !1
                                    };
                                case ew.nX:
                                    return { ...R,
                                        showCryptoDeposit: !1
                                    };
                                case ew.RP:
                                    return { ...R,
                                        showPaygardenDeposit: !0,
                                        showDeposit: !1
                                    };
                                case ew.vO:
                                    return { ...R,
                                        showPaygardenDeposit: !1
                                    };
                                case ew.OS:
                                    return { ...R,
                                        showSwappedDeposit: !0,
                                        showDeposit: !1
                                    };
                                case ew.cp:
                                    return { ...R,
                                        showSwappedDeposit: !1
                                    };
                                case ew.lp:
                                    return { ...R,
                                        showFreeCaseModal: !0
                                    };
                                case ew.eg:
                                    return { ...R,
                                        showFreeCaseModal: !1
                                    };
                                case ew.jQ:
                                    return { ...R,
                                        showHowUFoundUs: !0
                                    };
                                case ew.Nf:
                                    return { ...R,
                                        showHowUFoundUs: !1
                                    };
                                case ew.GJ:
                                    return { ...R,
                                        showSellixDeposit: !1
                                    };
                                case ew.LT:
                                    return R.fflags.fe_posthog_enabled, R.fflags.fe_ga_enabled && eE.ZP.event({
                                        action: "GIFTCARD_DEPOSIT_OPENED",
                                        category: "Auth"
                                    }), R.fflags.fe_mixpanel_enabled && ex.Z.track("GIFTCARD_DEPOSIT_OPENED"), { ...R,
                                        showGiftcardDeposit: !0,
                                        showDeposit: !1
                                    };
                                case ew.jg:
                                    return { ...R,
                                        showGiftcardDeposit: !1
                                    };
                                case ew.vB:
                                    return R.fflags.fe_posthog_enabled, R.fflags.fe_ga_enabled && eE.ZP.event({
                                        action: "ITEMS_DEPOSIT_OPENED",
                                        category: "Auth"
                                    }), R.fflags.fe_mixpanel_enabled && ex.Z.track("ITEMS_DEPOSIT_OPENED"), { ...R,
                                        showItemsDeposit: !0,
                                        showDeposit: !1
                                    };
                                case ew.Z8:
                                    return { ...R,
                                        showItemsDeposit: !1
                                    };
                                case ew.hH:
                                    return { ...R,
                                        showItemsSemiDeposit: !0,
                                        showDeposit: !1
                                    };
                                case ew.R_:
                                    return { ...R,
                                        showItemsSemiDeposit: !1
                                    };
                                case ew.Bb:
                                    return R.fflags.fe_posthog_enabled, R.fflags.fe_ga_enabled && eE.ZP.event({
                                        action: "BLOXLAND_DEPOSIT_OPENED",
                                        category: "Auth"
                                    }), R.fflags.fe_mixpanel_enabled && ex.Z.track("BLOXLAND_DEPOSIT_OPENED"), { ...R,
                                        showLandDeposit: !0,
                                        showDeposit: !1
                                    };
                                case ew.By:
                                    return { ...R,
                                        showLandDeposit: !1
                                    };
                                case ew.jT:
                                    return R.fflags.fe_posthog_enabled, R.fflags.fe_ga_enabled && eE.ZP.event({
                                        action: "PROMOCODE_DEPOSIT_OPENED",
                                        category: "Auth"
                                    }), R.fflags.fe_mixpanel_enabled && ex.Z.track("PROMOCODE_DEPOSIT_OPENED"), { ...R,
                                        showPromoDeposit: !0,
                                        showDeposit: !1
                                    };
                                case ew.Nq:
                                    return { ...R,
                                        showPromoDeposit: !1
                                    };
                                case ew.NW:
                                    return R.fflags.fe_posthog_enabled, R.fflags.fe_ga_enabled && eE.ZP.event({
                                        action: "SOCIAL_MEDIA_DEPOSIT_OPENED",
                                        category: "Auth"
                                    }), R.fflags.fe_mixpanel_enabled && ex.Z.track("SOCIAL_MEDIA_DEPOSIT_OPENED"), { ...R,
                                        showSocialMediaDeposit: !0,
                                        showDeposit: !1
                                    };
                                case ew.Rj:
                                    return { ...R,
                                        showSocialMediaDeposit: !1
                                    };
                                case ew.Q$:
                                    return R.fflags.fe_posthog_enabled, R.fflags.fe_ga_enabled && eE.ZP.event({
                                        action: "ROBUX_DEPOSIT_OPENED",
                                        category: "Auth"
                                    }), R.fflags.fe_mixpanel_enabled && ex.Z.track("ROBUX_DEPOSIT_OPENED"), { ...R,
                                        showRobuxDeposit: !0,
                                        showDeposit: !1
                                    };
                                case ew.mI:
                                    return { ...R,
                                        showRobuxWithdraw: !0,
                                        showWithdraw: !1
                                    };
                                case ew.Tk:
                                    return { ...R,
                                        showRobuxDeposit: !1
                                    };
                                case ew.n4:
                                    return R.fflags.fe_posthog_enabled, R.fflags.fe_ga_enabled && eE.ZP.event({
                                        action: "CHAT_RULES_MODAL_OPENED",
                                        category: "Auth"
                                    }), R.fflags.fe_mixpanel_enabled && ex.Z.track("CHAT_RULES_MODAL_OPENED"), { ...R,
                                        showChatRules: !0
                                    };
                                case ew.G:
                                    return { ...R,
                                        showChatRules: !1
                                    };
                                case ew.bY:
                                    return R.fflags.fe_posthog_enabled, R.fflags.fe_ga_enabled && eE.ZP.event({
                                        action: "FAQ_MODAL_OPENED",
                                        category: "Auth"
                                    }), R.fflags.fe_mixpanel_enabled && ex.Z.track("FAQ_MODAL_OPENED"), { ...R,
                                        showFaq: !0
                                    };
                                case ew.we:
                                    return { ...R,
                                        showFaq: !1
                                    };
                                case ew.Lw:
                                    return { ...R,
                                        showConfirmLogout: !0
                                    };
                                case ew._x:
                                    return { ...R,
                                        showConfirmLogout: !1
                                    };
                                case ew.bN:
                                    return { ...R,
                                        showHistoryModal: {
                                            show: !0,
                                            gameType: F.gameType,
                                            historyData: F.historyData
                                        }
                                    };
                                case ew.XA:
                                    return { ...R,
                                        showHistoryModal: {
                                            show: !1,
                                            historyData: null
                                        }
                                    };
                                case ew.BG:
                                    return { ...R,
                                        showRobuxWithdraw: !1
                                    };
                                case ew.gr:
                                    return { ...R,
                                        showLoginModal: !0
                                    };
                                case ew.OT:
                                    return { ...R,
                                        showMarketplaceModal: !0
                                    };
                                case ew.ER:
                                    return R.fflags.fe_posthog_enabled, R.fflags.fe_ga_enabled && eE.ZP.event({
                                        action: "CREDIT_CARD_DEPOSIT_OPENED",
                                        category: "Auth"
                                    }), R.fflags.fe_mixpanel_enabled && ex.Z.track("CREDIT_CARD_DEPOSIT_OPENED"), { ...R,
                                        showDeposit: !1,
                                        showCardsModal: !0
                                    };
                                case ew.Ph:
                                    return { ...R,
                                        showMarketplaceModal: !1
                                    };
                                case ew.i8:
                                    return { ...R,
                                        showWithdraw: !0
                                    };
                                case ew.xm:
                                    return { ...R,
                                        showWithdraw: !1
                                    };
                                case ew.Fv:
                                    return { ...R,
                                        showCardsModal: !1
                                    };
                                case ew.Dz:
                                    return { ...R,
                                        showTwoFactor: !0
                                    };
                                case ew.qq:
                                    return { ...R,
                                        geoBlock: !0
                                    };
                                case ew.PT:
                                    return { ...R,
                                        showTwoFactor: !1
                                    };
                                case ew.U6:
                                    return { ...R,
                                        showProvablyConfig: !0
                                    };
                                case ew.Kv:
                                    return { ...R,
                                        showProvablyConfig: !1
                                    };
                                case ew.LE:
                                    return { ...R,
                                        showProvably: {
                                            show: !0,
                                            provablyData: F
                                        }
                                    };
                                case ew._z:
                                    return { ...R,
                                        showProvably: {
                                            show: !1,
                                            provablyData: null
                                        }
                                    };
                                case ew.hj:
                                    return { ...R,
                                        showInfo: {
                                            show: !0,
                                            infoFor: F
                                        }
                                    };
                                case ew.AF:
                                    return { ...R,
                                        showInfo: {
                                            show: !1,
                                            infoFor: null
                                        }
                                    };
                                case ew.ow:
                                    return { ...R,
                                        showMuteModal: {
                                            show: !0,
                                            message: F
                                        }
                                    };
                                case ew.SM:
                                    return { ...R,
                                        showMuteModal: {
                                            show: !1,
                                            message: null
                                        }
                                    };
                                case ew.FW:
                                    return { ...R,
                                        showDeleteModal: {
                                            show: !0,
                                            message: F
                                        }
                                    };
                                case ew.CP:
                                    return { ...R,
                                        showDeleteModal: {
                                            show: !1,
                                            message: null
                                        }
                                    };
                                case ew.t_:
                                    return { ...R,
                                        showTipModal: {
                                            show: !0,
                                            message: F
                                        }
                                    };
                                case ew.NZ:
                                    return { ...R,
                                        showTipModal: {
                                            show: !1,
                                            message: null
                                        }
                                    };
                                case ew.Cy:
                                    try {
                                        null === (m = window.$crisp) || void 0 === m || m.push(["set", "user:nickname", [F.user.robloxUsername]])
                                    } catch (m) {
                                        console.error(m)
                                    }
                                    return { ...R,
                                        isAuthenticated: !0,
                                        isLoading: !1,
                                        user: F.user
                                    };
                                case ew.xe:
                                    return { ...R,
                                        isAuthenticated: !1,
                                        isLoading: !0
                                    };
                                case ew.Uk:
                                    return { ...R,
                                        user: { ...R.user,
                                            wallet: parseFloat((0, ek.Z)(R.user.wallet + F)),
                                            wager: F < 0 ? R.user.wager + Math.abs(F) : R.user.wager
                                        }
                                    };
                                case ew.XP:
                                    return localStorage.setItem("_DO_NOT_SHARE_BLOXFLIP_TOKEN", F.token), { ...R,
                                        ...F,
                                        isAuthenticated: !0,
                                        isLoading: !0
                                    };
                                case ew.Qj:
                                case ew.Nv:
                                    return localStorage.removeItem("_DO_NOT_SHARE_BLOXFLIP_TOKEN"), ex.Z.reset(), eE.ZP.reset(), { ...R,
                                        token: null,
                                        isAuthenticated: !1,
                                        affiliate: null,
                                        isLoading: !1
                                    };
                                case ew.Ny:
                                    return { ...R,
                                        token: null,
                                        isAuthenticated: !1,
                                        isLoading: !1
                                    };
                                case ew.KV:
                                    return { ...R,
                                        affiliate: F
                                    };
                                case ew.NS:
                                    return { ...R,
                                        autoBetPlinko: F
                                    };
                                case ew.eH:
                                    return { ...R,
                                        autoBetTower: F
                                    };
                                case ew.jf:
                                    return { ...R,
                                        autoBetMine: F
                                    };
                                case ew.c9:
                                    return { ...R,
                                        bjTable: F ? { ...R.bjTable,
                                            ...F
                                        } : null != F ? F : null
                                    };
                                case ew.C_:
                                    return { ...R,
                                        bjTables: F || (null != F ? F : null)
                                    };
                                case ew.$w:
                                    return { ...R,
                                        bjDecisions: F ? { ...R.bjDecisions,
                                            ...F
                                        } : null != F ? F : null
                                    };
                                case ew.gQ:
                                    return { ...R,
                                        user: Object.assign({}, null !== (_ = R.user) && void 0 !== _ ? _ : {}, R.user ? {
                                            privacyEnabled: F
                                        } : {})
                                    };
                                case ew.Mc:
                                    return { ...R,
                                        wherefromcard: F
                                    };
                                case ew.Yk:
                                    return { ...R,
                                        cbGame: F ? { ...R.cbGame || {},
                                            ...F
                                        } : null != F ? F : null
                                    };
                                case ew.bO:
                                    return { ...R,
                                        firstLoaded: F
                                    };
                                case ew.fd:
                                    return { ...R,
                                        analyticsId2: F
                                    };
                                case ew.Sh:
                                    return { ...R,
                                        discounts: F ? { ...null !== (C = R.discounts) && void 0 !== C ? C : {},
                                            ...F
                                        } : F
                                    };
                                case ew.n9:
                                    return { ...R,
                                        gameIds: F
                                    };
                                default:
                                    return R
                            }
                        }
                    },
                    middleware: eO
                });
            var eM = eC
        },
        6428: function(m, _, C) {
            "use strict";
            C.d(_, {
                Z: function() {
                    return useWindowSize
                }
            });
            var R = C(67294);

            function useWindowSize() {
                let [m, _] = (0, R.useState)({
                    width: 0,
                    height: 0
                });

                function handleResize() {
                    _({
                        width: window.innerWidth,
                        height: window.innerHeight
                    })
                }
                return (0, R.useEffect)(() => (window.addEventListener("resize", handleResize), handleResize(), () => {
                    window.removeEventListener("resize", handleResize)
                }), []), m
            }
        },
        53215: function(m, _, C) {
            "use strict";
            let R, L, B, F, U, H, q, V, X, K, Y, Q, et, er, en, ei, eo, ea, es;
            var ec, el, eu, ed, ep, eh, ef, em, eg, ey = C(42990);

            function applySdkMetadata(m, _, C = [_], R = "npm") {
                let L = m._metadata || {};
                L.sdk || (L.sdk = {
                    name: `sentry.javascript.${_}`,
                    packages: C.map(m => ({
                        name: `${R}:@sentry/${m}`,
                        version: ey.J
                    })),
                    version: ey.J
                }), m._metadata = L
            }
            var e_ = C(39424),
                ev = C(41001),
                eb = C(41982),
                eS = C(89163),
                ew = C(94223);
            let eE = [];

            function afterSetupIntegrations(m, _) {
                for (let C of _) C && C.afterAllSetup && C.afterAllSetup(m)
            }

            function setupIntegration(m, _, C) {
                if (C[_.name]) {
                    ew.X && ev.kg.log(`Integration skipped because it was already installed: ${_.name}`);
                    return
                }
                if (C[_.name] = _, -1 === eE.indexOf(_.name) && "function" == typeof _.setupOnce && (_.setupOnce(), eE.push(_.name)), _.setup && "function" == typeof _.setup && _.setup(m), "function" == typeof _.preprocessEvent) {
                    let C = _.preprocessEvent.bind(_);
                    m.on("preprocessEvent", (_, R) => C(_, R, m))
                }
                if ("function" == typeof _.processEvent) {
                    let C = _.processEvent.bind(_),
                        R = Object.assign((_, R) => C(_, R, m), {
                            id: _.name
                        });
                    m.addEventProcessor(R)
                }
                ew.X && ev.kg.log(`Integration installed: ${_.name}`)
            }
            let ek = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, "undefined is not an object (evaluating 'a.L')", 'can\'t redefine non-configurable property "solana"', "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler"],
                inboundFiltersIntegration = (m = {}) => ({
                    name: "InboundFilters",
                    processEvent(_, C, R) {
                        var L;
                        let B = R.getOptions(),
                            F = function(m = {}, _ = {}) {
                                return {
                                    allowUrls: [...m.allowUrls || [], ..._.allowUrls || []],
                                    denyUrls: [...m.denyUrls || [], ..._.denyUrls || []],
                                    ignoreErrors: [...m.ignoreErrors || [], ..._.ignoreErrors || [], ...m.disableErrorDefaults ? [] : ek],
                                    ignoreTransactions: [...m.ignoreTransactions || [], ..._.ignoreTransactions || []],
                                    ignoreInternal: void 0 === m.ignoreInternal || m.ignoreInternal
                                }
                            }(m, B);
                        return (F.ignoreInternal && function(m) {
                            try {
                                return "SentryError" === m.exception.values[0].type
                            } catch (m) {}
                            return !1
                        }(_) ? (ew.X && ev.kg.warn(`Event dropped due to being internal Sentry Error.
Event: ${(0,eb.jH)(_)}`), 0) : (L = F.ignoreErrors, !_.type && L && L.length && (function(m) {
                            let _;
                            let C = [];
                            m.message && C.push(m.message);
                            try {
                                _ = m.exception.values[m.exception.values.length - 1]
                            } catch (m) {}
                            return _ && _.value && (C.push(_.value), _.type && C.push(`${_.type}: ${_.value}`)), C
                        })(_).some(m => (0, eS.U0)(m, L))) ? (ew.X && ev.kg.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${(0,eb.jH)(_)}`), 0) : _.type || !_.exception || !_.exception.values || 0 === _.exception.values.length || _.message || _.exception.values.some(m => m.stacktrace || m.type && "Error" !== m.type || m.value) ? ! function(m, _) {
                            if ("transaction" !== m.type || !_ || !_.length) return !1;
                            let C = m.transaction;
                            return !!C && (0, eS.U0)(C, _)
                        }(_, F.ignoreTransactions) ? ! function(m, _) {
                            if (!_ || !_.length) return !1;
                            let C = _getEventFilterUrl(m);
                            return !!C && (0, eS.U0)(C, _)
                        }(_, F.denyUrls) ? function(m, _) {
                            if (!_ || !_.length) return !0;
                            let C = _getEventFilterUrl(m);
                            return !C || (0, eS.U0)(C, _)
                        }(_, F.allowUrls) || (ew.X && ev.kg.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${(0,eb.jH)(_)}.
Url: ${_getEventFilterUrl(_)}`), 0) : (ew.X && ev.kg.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${(0,eb.jH)(_)}.
Url: ${_getEventFilterUrl(_)}`), 0) : (ew.X && ev.kg.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${(0,eb.jH)(_)}`), 0) : (ew.X && ev.kg.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${(0,eb.jH)(_)}`), 0)) ? _ : null
                    }
                });

            function _getEventFilterUrl(m) {
                try {
                    let _;
                    try {
                        _ = m.exception.values[0].stacktrace.frames
                    } catch (m) {}
                    return _ ? function(m = []) {
                        for (let _ = m.length - 1; _ >= 0; _--) {
                            let C = m[_];
                            if (C && "<anonymous>" !== C.filename && "[native code]" !== C.filename) return C.filename || null
                        }
                        return null
                    }(_) : null
                } catch (_) {
                    return ew.X && ev.kg.error(`Cannot extract url for event ${(0,eb.jH)(m)}`), null
                }
            }
            var ex = C(27179),
                eI = C(73076);
            let eO = new WeakMap,
                functionToStringIntegration = () => ({
                    name: "FunctionToString",
                    setupOnce() {
                        R = Function.prototype.toString;
                        try {
                            Function.prototype.toString = function(...m) {
                                let _ = (0, ex.HK)(this),
                                    C = eO.has((0, eI.s3)()) && void 0 !== _ ? _ : this;
                                return R.apply(C, m)
                            }
                        } catch (m) {}
                    },
                    setup(m) {
                        eO.set(m, !0)
                    }
                });
            var eC = C(42283);
            let dedupeIntegration = () => {
                let m;
                return {
                    name: "Dedupe",
                    processEvent(_) {
                        if (_.type) return _;
                        try {
                            var C;
                            if ((C = m) && (function(m, _) {
                                    let C = m.message,
                                        R = _.message;
                                    return !!((C || R) && (!C || R) && (C || !R) && C === R && _isSameFingerprint(m, _) && _isSameStacktrace(m, _))
                                }(_, C) || function(m, _) {
                                    let C = _getExceptionFromEvent(_),
                                        R = _getExceptionFromEvent(m);
                                    return !!(C && R && C.type === R.type && C.value === R.value && _isSameFingerprint(m, _) && _isSameStacktrace(m, _))
                                }(_, C))) return ew.X && ev.kg.warn("Event dropped due to being a duplicate of previously captured event."), null
                        } catch (m) {}
                        return m = _
                    }
                }
            };

            function _isSameStacktrace(m, _) {
                let C = (0, eC.Fr)(m),
                    R = (0, eC.Fr)(_);
                if (!C && !R) return !0;
                if (C && !R || !C && R || R.length !== C.length) return !1;
                for (let m = 0; m < R.length; m++) {
                    let _ = R[m],
                        L = C[m];
                    if (_.filename !== L.filename || _.lineno !== L.lineno || _.colno !== L.colno || _.function !== L.function) return !1
                }
                return !0
            }

            function _isSameFingerprint(m, _) {
                let C = m.fingerprint,
                    R = _.fingerprint;
                if (!C && !R) return !0;
                if (C && !R || !C && R) return !1;
                try {
                    return !(C.join("") !== R.join(""))
                } catch (m) {
                    return !1
                }
            }

            function _getExceptionFromEvent(m) {
                return m.exception && m.exception.values && m.exception.values[0]
            }
            var eM = C(1525),
                eT = C(29531);
            let eA = eT.GLOBAL_OBJ;

            function isNativeFunction(m) {
                return m && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(m.toString())
            }
            let eR = {},
                eP = {};

            function addHandler(m, _) {
                eR[m] = eR[m] || [], eR[m].push(_)
            }

            function maybeInstrument(m, _) {
                eP[m] || (_(), eP[m] = !0)
            }

            function triggerHandlers(m, _) {
                let C = m && eR[m];
                if (C)
                    for (let R of C) try {
                        R(_)
                    } catch (_) {
                        eM.X && ev.kg.error(`Error while triggering instrumentation handler.
Type: ${m}
Name: ${(0,eC.$P)(R)}
Error:`, _)
                    }
            }
            let eD = eT.GLOBAL_OBJ,
                eL = eT.GLOBAL_OBJ;

            function addHistoryInstrumentationHandler(m) {
                let _ = "history";
                addHandler(_, m), maybeInstrument(_, instrumentHistory)
            }

            function instrumentHistory() {
                if (! function() {
                        let m = eD.chrome,
                            _ = m && m.app && m.app.runtime,
                            C = "history" in eD && !!eD.history.pushState && !!eD.history.replaceState;
                        return !_ && C
                    }()) return;
                let m = eL.onpopstate;

                function historyReplacementFunction(m) {
                    return function(..._) {
                        let C = _.length > 2 ? _[2] : void 0;
                        if (C) {
                            let m = L,
                                _ = String(C);
                            L = _, triggerHandlers("history", {
                                from: m,
                                to: _
                            })
                        }
                        return m.apply(this, _)
                    }
                }
                eL.onpopstate = function(..._) {
                    let C = eL.location.href,
                        R = L;
                    if (L = C, triggerHandlers("history", {
                            from: R,
                            to: C
                        }), m) try {
                        return m.apply(this, _)
                    } catch (m) {}
                }, (0, ex.hl)(eL.history, "pushState", historyReplacementFunction), (0, ex.hl)(eL.history, "replaceState", historyReplacementFunction)
            }
            var eN = C(73326),
                eB = C(16824),
                ej = C(80128),
                eF = C(39432);
            let SentryError = class SentryError extends Error {
                constructor(m, _ = "warn") {
                    super(m), this.message = m, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = _
                }
            };
            var eU = C(26181),
                eH = C(11793),
                eW = C(10042),
                e$ = C(72123),
                eq = C(79769),
                eG = C(5808);
            let ez = "Not capturing exception because it's already been captured.";
            let BaseClient = class BaseClient {
                constructor(m) {
                    if (this._options = m, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], m.dsn ? this._dsn = (0, eN.vK)(m.dsn) : ew.X && ev.kg.warn("No DSN provided, client will not send events."), this._dsn) {
                        var _, C, R;
                        let L = (_ = this._dsn, C = m.tunnel, R = m._metadata ? m._metadata.sdk : void 0, C || `${function(m){let _=m.protocol?`${m.protocol}:`:"",C=m.port?`:${m.port}`:"";return`${_}//${m.host}${C}${m.path?`/${m.path}`:""}/api/`}(_)}${_.projectId}/envelope/?${(0,ex._j)({sentry_key:_.publicKey,sentry_version:"7",...R&&{sentry_client:`${R.name}/${R.version}`}})}`);
                        this._transport = m.transport({
                            tunnel: this._options.tunnel,
                            recordDroppedEvent: this.recordDroppedEvent.bind(this),
                            ...m.transportOptions,
                            url: L
                        })
                    }
                }
                captureException(m, _, C) {
                    let R = (0, eb.DM)();
                    if ((0, eb.YO)(m)) return ew.X && ev.kg.log(ez), R;
                    let L = {
                        event_id: R,
                        ..._
                    };
                    return this._process(this.eventFromException(m, L).then(m => this._captureEvent(m, L, C))), L.event_id
                }
                captureMessage(m, _, C, R) {
                    let L = {
                            event_id: (0, eb.DM)(),
                            ...C
                        },
                        B = (0, eB.Le)(m) ? m : String(m),
                        F = (0, eB.pt)(m) ? this.eventFromMessage(B, _, L) : this.eventFromException(m, L);
                    return this._process(F.then(m => this._captureEvent(m, L, R))), L.event_id
                }
                captureEvent(m, _, C) {
                    let R = (0, eb.DM)();
                    if (_ && _.originalException && (0, eb.YO)(_.originalException)) return ew.X && ev.kg.log(ez), R;
                    let L = {
                            event_id: R,
                            ..._
                        },
                        B = m.sdkProcessingMetadata || {},
                        F = B.capturedSpanScope;
                    return this._process(this._captureEvent(m, L, F || C)), L.event_id
                }
                captureSession(m) {
                    "string" != typeof m.release ? ew.X && ev.kg.warn("Discarded session because of missing or non-string release") : (this.sendSession(m), (0, eW.CT)(m, {
                        init: !1
                    }))
                }
                getDsn() {
                    return this._dsn
                }
                getOptions() {
                    return this._options
                }
                getSdkMetadata() {
                    return this._options._metadata
                }
                getTransport() {
                    return this._transport
                }
                flush(m) {
                    let _ = this._transport;
                    return _ ? (this.emit("flush"), this._isClientDoneProcessing(m).then(C => _.flush(m).then(m => C && m))) : (0, ej.WD)(!0)
                }
                close(m) {
                    return this.flush(m).then(m => (this.getOptions().enabled = !1, this.emit("close"), m))
                }
                getEventProcessors() {
                    return this._eventProcessors
                }
                addEventProcessor(m) {
                    this._eventProcessors.push(m)
                }
                init() {
                    (this._isEnabled() || this._options.integrations.some(({
                        name: m
                    }) => m.startsWith("Spotlight"))) && this._setupIntegrations()
                }
                getIntegrationByName(m) {
                    return this._integrations[m]
                }
                addIntegration(m) {
                    let _ = this._integrations[m.name];
                    setupIntegration(this, m, this._integrations), _ || afterSetupIntegrations(this, [m])
                }
                sendEvent(m, _ = {}) {
                    this.emit("beforeSendEvent", m, _);
                    let C = (0, eH.Mq)(m, this._dsn, this._options._metadata, this._options.tunnel);
                    for (let m of _.attachments || []) C = (0, eF.BO)(C, (0, eF.zQ)(m));
                    let R = this.sendEnvelope(C);
                    R && R.then(_ => this.emit("afterSendEvent", m, _), null)
                }
                sendSession(m) {
                    let _ = (0, eH.Q3)(m, this._dsn, this._options._metadata, this._options.tunnel);
                    this.sendEnvelope(_)
                }
                recordDroppedEvent(m, _, C) {
                    if (this._options.sendClientReports) {
                        let R = "number" == typeof C ? C : 1,
                            L = `${m}:${_}`;
                        ew.X && ev.kg.log(`Recording outcome: "${L}"${R>1?` (${R} times)`:""}`), this._outcomes[L] = (this._outcomes[L] || 0) + R
                    }
                }
                on(m, _) {
                    let C = this._hooks[m] = this._hooks[m] || [];
                    return C.push(_), () => {
                        let m = C.indexOf(_);
                        m > -1 && C.splice(m, 1)
                    }
                }
                emit(m, ..._) {
                    let C = this._hooks[m];
                    C && C.forEach(m => m(..._))
                }
                sendEnvelope(m) {
                    return (this.emit("beforeEnvelope", m), this._isEnabled() && this._transport) ? this._transport.send(m).then(null, m => (ew.X && ev.kg.error("Error while sending event:", m), m)) : (ew.X && ev.kg.error("Transport disabled"), (0, ej.WD)({}))
                }
                _setupIntegrations() {
                    let {
                        integrations: m
                    } = this._options;
                    this._integrations = function(m, _) {
                        let C = {};
                        return _.forEach(_ => {
                            _ && setupIntegration(m, _, C)
                        }), C
                    }(this, m), afterSetupIntegrations(this, m)
                }
                _updateSessionFromEvent(m, _) {
                    let C = !1,
                        R = !1,
                        L = _.exception && _.exception.values;
                    if (L)
                        for (let m of (R = !0, L)) {
                            let _ = m.mechanism;
                            if (_ && !1 === _.handled) {
                                C = !0;
                                break
                            }
                        }
                    let B = "ok" === m.status,
                        F = B && 0 === m.errors || B && C;
                    F && ((0, eW.CT)(m, { ...C && {
                            status: "crashed"
                        },
                        errors: m.errors || Number(R || C)
                    }), this.captureSession(m))
                }
                _isClientDoneProcessing(m) {
                    return new ej.cW(_ => {
                        let C = 0,
                            R = setInterval(() => {
                                0 == this._numProcessing ? (clearInterval(R), _(!0)) : (C += 1, m && C >= m && (clearInterval(R), _(!1)))
                            }, 1)
                    })
                }
                _isEnabled() {
                    return !1 !== this.getOptions().enabled && void 0 !== this._transport
                }
                _prepareEvent(m, _, C, R = (0, eI.aF)()) {
                    let L = this.getOptions(),
                        B = Object.keys(this._integrations);
                    return !_.integrations && B.length > 0 && (_.integrations = B), this.emit("preprocessEvent", m, _), m.type || R.setLastEventId(m.event_id || _.event_id), (0, eG.R)(L, m, _, C, this, R).then(m => {
                        if (null === m) return m;
                        let _ = { ...R.getPropagationContext(),
                                ...C ? C.getPropagationContext() : void 0
                            },
                            L = m.contexts && m.contexts.trace;
                        if (!L && _) {
                            let {
                                traceId: C,
                                spanId: R,
                                parentSpanId: L,
                                dsc: B
                            } = _;
                            m.contexts = {
                                trace: (0, ex.Jr)({
                                    trace_id: C,
                                    span_id: R,
                                    parent_span_id: L
                                }),
                                ...m.contexts
                            };
                            let F = B || (0, e$._l)(C, this);
                            m.sdkProcessingMetadata = {
                                dynamicSamplingContext: F,
                                ...m.sdkProcessingMetadata
                            }
                        }
                        return m
                    })
                }
                _captureEvent(m, _ = {}, C) {
                    return this._processEvent(m, _, C).then(m => m.event_id, m => {
                        ew.X && ("log" === m.logLevel ? ev.kg.log(m.message) : ev.kg.warn(m))
                    })
                }
                _processEvent(m, _, C) {
                    let R = this.getOptions(),
                        {
                            sampleRate: L
                        } = R,
                        B = isTransactionEvent(m),
                        F = isErrorEvent(m),
                        U = m.type || "error",
                        H = `before send for type \`${U}\``,
                        q = void 0 === L ? void 0 : (0, eq.o)(L);
                    if (F && "number" == typeof q && Math.random() > q) return this.recordDroppedEvent("sample_rate", "error", m), (0, ej.$2)(new SentryError(`Discarding event because it's not included in the random sample (sampling rate = ${L})`, "log"));
                    let V = "replay_event" === U ? "replay" : U,
                        X = m.sdkProcessingMetadata || {},
                        K = X.capturedSpanIsolationScope;
                    return this._prepareEvent(m, _, C, K).then(C => {
                        if (null === C) throw this.recordDroppedEvent("event_processor", V, m), new SentryError("An event processor returned `null`, will not send event.", "log");
                        let L = _.data && !0 === _.data.__sentry__;
                        if (L) return C;
                        let B = function(m, _, C, R) {
                            let {
                                beforeSend: L,
                                beforeSendTransaction: B,
                                beforeSendSpan: F
                            } = _;
                            if (isErrorEvent(C) && L) return L(C, R);
                            if (isTransactionEvent(C)) {
                                if (C.spans && F) {
                                    let _ = [];
                                    for (let R of C.spans) {
                                        let C = F(R);
                                        C ? _.push(C) : m.recordDroppedEvent("before_send", "span")
                                    }
                                    C.spans = _
                                }
                                if (B) {
                                    if (C.spans) {
                                        let m = C.spans.length;
                                        C.sdkProcessingMetadata = { ...C.sdkProcessingMetadata,
                                            spanCountBeforeProcessing: m
                                        }
                                    }
                                    return B(C, R)
                                }
                            }
                            return C
                        }(this, R, C, _);
                        return function(m, _) {
                            let C = `${_} must return \`null\` or a valid event.`;
                            if ((0, eB.J8)(m)) return m.then(m => {
                                if (!(0, eB.PO)(m) && null !== m) throw new SentryError(C);
                                return m
                            }, m => {
                                throw new SentryError(`${_} rejected with ${m}`)
                            });
                            if (!(0, eB.PO)(m) && null !== m) throw new SentryError(C);
                            return m
                        }(B, H)
                    }).then(R => {
                        if (null === R) {
                            if (this.recordDroppedEvent("before_send", V, m), B) {
                                let _ = m.spans || [],
                                    C = 1 + _.length;
                                this.recordDroppedEvent("before_send", "span", C)
                            }
                            throw new SentryError(`${H} returned \`null\`, will not send event.`, "log")
                        }
                        let L = C && C.getSession();
                        if (!B && L && this._updateSessionFromEvent(L, R), B) {
                            let m = R.sdkProcessingMetadata && R.sdkProcessingMetadata.spanCountBeforeProcessing || 0,
                                _ = R.spans ? R.spans.length : 0,
                                C = m - _;
                            C > 0 && this.recordDroppedEvent("before_send", "span", C)
                        }
                        let F = R.transaction_info;
                        return B && F && R.transaction !== m.transaction && (R.transaction_info = { ...F,
                            source: "custom"
                        }), this.sendEvent(R, _), R
                    }).then(null, m => {
                        if (m instanceof SentryError) throw m;
                        throw this.captureException(m, {
                            data: {
                                __sentry__: !0
                            },
                            originalException: m
                        }), new SentryError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${m}`)
                    })
                }
                _process(m) {
                    this._numProcessing++, m.then(m => (this._numProcessing--, m), m => (this._numProcessing--, m))
                }
                _clearOutcomes() {
                    let m = this._outcomes;
                    return this._outcomes = {}, Object.entries(m).map(([m, _]) => {
                        let [C, R] = m.split(":");
                        return {
                            reason: C,
                            category: R,
                            quantity: _
                        }
                    })
                }
                _flushOutcomes() {
                    ew.X && ev.kg.log("Flushing outcomes...");
                    let m = this._clearOutcomes();
                    if (0 === m.length) {
                        ew.X && ev.kg.log("No outcomes to send");
                        return
                    }
                    if (!this._dsn) {
                        ew.X && ev.kg.log("No dsn provided, will not send outcomes");
                        return
                    }
                    ew.X && ev.kg.log("Sending outcomes:", m);
                    let _ = function(m, _, C) {
                        let R = [{
                            type: "client_report"
                        }, {
                            timestamp: (0, eU.yW)(),
                            discarded_events: m
                        }];
                        return (0, eF.Jd)(_ ? {
                            dsn: _
                        } : {}, [R])
                    }(m, this._options.tunnel && (0, eN.RA)(this._dsn));
                    this.sendEnvelope(_)
                }
            };

            function isErrorEvent(m) {
                return void 0 === m.type
            }

            function isTransactionEvent(m) {
                return "transaction" === m.type
            }
            var eV = C(83408);

            function exceptionFromError(m, _) {
                let C = parseStackFrames(m, _),
                    R = {
                        type: function(m) {
                            let _ = m && m.name;
                            if (!_ && isWebAssemblyException(m)) {
                                let _ = m.message && Array.isArray(m.message) && 2 == m.message.length;
                                return _ ? m.message[0] : "WebAssembly.Exception"
                            }
                            return _
                        }(_),
                        value: function(m) {
                            let _ = m && m.message;
                            return _ ? _.error && "string" == typeof _.error.message ? _.error.message : isWebAssemblyException(m) && Array.isArray(m.message) && 2 == m.message.length ? m.message[1] : _ : "No error message"
                        }(_)
                    };
                return C.length && (R.stacktrace = {
                    frames: C
                }), void 0 === R.type && "" === R.value && (R.value = "Unrecoverable error caught"), R
            }

            function eventFromError(m, _) {
                return {
                    exception: {
                        values: [exceptionFromError(m, _)]
                    }
                }
            }

            function parseStackFrames(m, _) {
                let C = _.stacktrace || _.stack || "",
                    R = _ && eJ.test(_.message) ? 1 : 0,
                    L = "number" == typeof _.framesToPop ? _.framesToPop : 0;
                try {
                    return m(C, R, L)
                } catch (m) {}
                return []
            }
            let eJ = /Minified React error #\d+;/i;

            function isWebAssemblyException(m) {
                return "undefined" != typeof WebAssembly && void 0 !== WebAssembly.Exception && m instanceof WebAssembly.Exception
            }

            function eventFromUnknownInput(m, _, C, R, L) {
                let B;
                if ((0, eB.VW)(_) && _.error) return eventFromError(m, _.error);
                if ((0, eB.TX)(_) || (0, eB.fm)(_)) {
                    if ("stack" in _) B = eventFromError(m, _);
                    else {
                        let L = _.name || ((0, eB.TX)(_) ? "DOMError" : "DOMException"),
                            F = _.message ? `${L}: ${_.message}` : L;
                        B = eventFromString(m, F, C, R), (0, eb.Db)(B, F)
                    }
                    return "code" in _ && (B.tags = { ...B.tags,
                        "DOMException.code": `${_.code}`
                    }), B
                }
                return (0, eB.VZ)(_) ? eventFromError(m, _) : ((0, eB.PO)(_) || (0, eB.cO)(_) ? B = function(m, _, C, R) {
                    let L = (0, eI.s3)(),
                        B = L && L.getOptions().normalizeDepth,
                        F = function(m) {
                            for (let _ in m)
                                if (Object.prototype.hasOwnProperty.call(m, _)) {
                                    let C = m[_];
                                    if (C instanceof Error) return C
                                }
                        }(_),
                        U = {
                            __serialized__: (0, eV.Qy)(_, B)
                        };
                    if (F) return {
                        exception: {
                            values: [exceptionFromError(m, F)]
                        },
                        extra: U
                    };
                    let H = {
                        exception: {
                            values: [{
                                type: (0, eB.cO)(_) ? _.constructor.name : R ? "UnhandledRejection" : "Error",
                                value: function(m, {
                                    isUnhandledRejection: _
                                }) {
                                    let C = (0, ex.zf)(m),
                                        R = _ ? "promise rejection" : "exception";
                                    if ((0, eB.VW)(m)) return `Event \`ErrorEvent\` captured as ${R} with message \`${m.message}\``;
                                    if ((0, eB.cO)(m)) {
                                        let _ = function(m) {
                                            try {
                                                let _ = Object.getPrototypeOf(m);
                                                return _ ? _.constructor.name : void 0
                                            } catch (m) {}
                                        }(m);
                                        return `Event \`${_}\` (type=${m.type}) captured as ${R}`
                                    }
                                    return `Object captured as ${R} with keys: ${C}`
                                }(_, {
                                    isUnhandledRejection: R
                                })
                            }]
                        },
                        extra: U
                    };
                    if (C) {
                        let _ = parseStackFrames(m, C);
                        _.length && (H.exception.values[0].stacktrace = {
                            frames: _
                        })
                    }
                    return H
                }(m, _, C, L) : (B = eventFromString(m, _, C, R), (0, eb.Db)(B, `${_}`, void 0)), (0, eb.EG)(B, {
                    synthetic: !0
                }), B)
            }

            function eventFromString(m, _, C, R) {
                let L = {};
                if (R && C) {
                    let R = parseStackFrames(m, C);
                    R.length && (L.exception = {
                        values: [{
                            value: _,
                            stacktrace: {
                                frames: R
                            }
                        }]
                    })
                }
                if ((0, eB.Le)(_)) {
                    let {
                        __sentry_template_string__: m,
                        __sentry_template_values__: C
                    } = _;
                    return L.logentry = {
                        message: m,
                        params: C
                    }, L
                }
                return L.message = _, L
            }
            let eX = eT.GLOBAL_OBJ,
                eK = 0;

            function wrap(m, _ = {}, C) {
                if ("function" != typeof m) return m;
                try {
                    let _ = m.__sentry_wrapped__;
                    if (_) {
                        if ("function" == typeof _) return _;
                        return m
                    }
                    if ((0, ex.HK)(m)) return m
                } catch (_) {
                    return m
                }
                let sentryWrapped = function() {
                    let R = Array.prototype.slice.call(arguments);
                    try {
                        C && "function" == typeof C && C.apply(this, arguments);
                        let L = R.map(m => wrap(m, _));
                        return m.apply(this, L)
                    } catch (m) {
                        throw eK++, setTimeout(() => {
                            eK--
                        }), (0, eI.$e)(C => {
                            C.addEventProcessor(m => (_.mechanism && ((0, eb.Db)(m, void 0, void 0), (0, eb.EG)(m, _.mechanism)), m.extra = { ...m.extra,
                                arguments: R
                            }, m)), (0, e_.Tb)(m)
                        }), m
                    }
                };
                try {
                    for (let _ in m) Object.prototype.hasOwnProperty.call(m, _) && (sentryWrapped[_] = m[_])
                } catch (m) {}(0, ex.$Q)(sentryWrapped, m), (0, ex.xp)(m, "__sentry_wrapped__", sentryWrapped);
                try {
                    let _ = Object.getOwnPropertyDescriptor(sentryWrapped, "name");
                    _.configurable && Object.defineProperty(sentryWrapped, "name", {
                        get: () => m.name
                    })
                } catch (m) {}
                return sentryWrapped
            }
            let BrowserClient = class BrowserClient extends BaseClient {
                constructor(m) {
                    let _ = {
                            parentSpanIsAlwaysRootSpan: !0,
                            ...m
                        },
                        C = eX.SENTRY_SDK_SOURCE || "npm";
                    applySdkMetadata(_, "browser", ["browser"], C), super(_), _.sendClientReports && eX.document && eX.document.addEventListener("visibilitychange", () => {
                        "hidden" === eX.document.visibilityState && this._flushOutcomes()
                    })
                }
                eventFromException(m, _) {
                    return function(m, _, C, R) {
                        let L = C && C.syntheticException || void 0,
                            B = eventFromUnknownInput(m, _, L, R);
                        return (0, eb.EG)(B), B.level = "error", C && C.event_id && (B.event_id = C.event_id), (0, ej.WD)(B)
                    }(this._options.stackParser, m, _, this._options.attachStacktrace)
                }
                eventFromMessage(m, _ = "info", C) {
                    return function(m, _, C = "info", R, L) {
                        let B = R && R.syntheticException || void 0,
                            F = eventFromString(m, _, B, L);
                        return F.level = C, R && R.event_id && (F.event_id = R.event_id), (0, ej.WD)(F)
                    }(this._options.stackParser, m, _, C, this._options.attachStacktrace)
                }
                captureUserFeedback(m) {
                    if (!this._isEnabled()) return;
                    let _ = function(m, {
                        metadata: _,
                        tunnel: C,
                        dsn: R
                    }) {
                        let L = {
                                event_id: m.event_id,
                                sent_at: new Date().toISOString(),
                                ..._ && _.sdk && {
                                    sdk: {
                                        name: _.sdk.name,
                                        version: _.sdk.version
                                    }
                                },
                                ...!!C && !!R && {
                                    dsn: (0, eN.RA)(R)
                                }
                            },
                            B = [{
                                type: "user_report"
                            }, m];
                        return (0, eF.Jd)(L, [B])
                    }(m, {
                        metadata: this.getSdkMetadata(),
                        dsn: this.getDsn(),
                        tunnel: this.getOptions().tunnel
                    });
                    this.sendEnvelope(_)
                }
                _prepareEvent(m, _, C) {
                    return m.platform = m.platform || "javascript", super._prepareEvent(m, _, C)
                }
            };

            function addClickKeypressInstrumentationHandler(m) {
                addHandler("dom", m), maybeInstrument("dom", instrumentDOM)
            }

            function instrumentDOM() {
                if (!eL.document) return;
                let m = triggerHandlers.bind(null, "dom"),
                    _ = makeDOMEventHandler(m, !0);
                eL.document.addEventListener("click", _, !1), eL.document.addEventListener("keypress", _, !1), ["EventTarget", "Node"].forEach(_ => {
                    let C = eL[_] && eL[_].prototype;
                    C && C.hasOwnProperty && C.hasOwnProperty("addEventListener") && ((0, ex.hl)(C, "addEventListener", function(_) {
                        return function(C, R, L) {
                            if ("click" === C || "keypress" == C) try {
                                let R = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {},
                                    B = R[C] = R[C] || {
                                        refCount: 0
                                    };
                                if (!B.handler) {
                                    let R = makeDOMEventHandler(m);
                                    B.handler = R, _.call(this, C, R, L)
                                }
                                B.refCount++
                            } catch (m) {}
                            return _.call(this, C, R, L)
                        }
                    }), (0, ex.hl)(C, "removeEventListener", function(m) {
                        return function(_, C, R) {
                            if ("click" === _ || "keypress" == _) try {
                                let C = this.__sentry_instrumentation_handlers__ || {},
                                    L = C[_];
                                L && (L.refCount--, L.refCount <= 0 && (m.call(this, _, L.handler, R), L.handler = void 0, delete C[_]), 0 === Object.keys(C).length && delete this.__sentry_instrumentation_handlers__)
                            } catch (m) {}
                            return m.call(this, _, C, R)
                        }
                    }))
                })
            }

            function makeDOMEventHandler(m, _ = !1) {
                return C => {
                    if (!C || C._sentryCaptured) return;
                    let R = function(m) {
                        try {
                            return m.target
                        } catch (m) {
                            return null
                        }
                    }(C);
                    if ("keypress" === C.type && (!R || !R.tagName || "INPUT" !== R.tagName && "TEXTAREA" !== R.tagName && !R.isContentEditable)) return;
                    (0, ex.xp)(C, "_sentryCaptured", !0), R && !R._sentryId && (0, ex.xp)(R, "_sentryId", (0, eb.DM)());
                    let L = "keypress" === C.type ? "input" : C.type;
                    ! function(m) {
                        if (m.type !== F) return !1;
                        try {
                            if (!m.target || m.target._sentryId !== U) return !1
                        } catch (m) {}
                        return !0
                    }(C) && (m({
                        event: C,
                        name: L,
                        global: _
                    }), F = C.type, U = R ? R._sentryId : void 0), clearTimeout(B), B = eL.setTimeout(() => {
                        U = void 0, F = void 0
                    }, 1e3)
                }
            }
            let eZ = "__sentry_xhr_v3__";

            function addXhrInstrumentationHandler(m) {
                addHandler("xhr", m), maybeInstrument("xhr", instrumentXHR)
            }

            function instrumentXHR() {
                if (!eL.XMLHttpRequest) return;
                let m = XMLHttpRequest.prototype;
                m.open = new Proxy(m.open, {
                    apply(m, _, C) {
                        let R = 1e3 * (0, eU.ph)(),
                            L = (0, eB.HD)(C[0]) ? C[0].toUpperCase() : void 0,
                            B = function(m) {
                                if ((0, eB.HD)(m)) return m;
                                try {
                                    return m.toString()
                                } catch (m) {}
                            }(C[1]);
                        if (!L || !B) return m.apply(_, C);
                        _[eZ] = {
                            method: L,
                            url: B,
                            request_headers: {}
                        }, "POST" === L && B.match(/sentry_key/) && (_.__sentry_own_request__ = !0);
                        let onreadystatechangeHandler = () => {
                            let m = _[eZ];
                            if (m && 4 === _.readyState) {
                                try {
                                    m.status_code = _.status
                                } catch (m) {}
                                let C = {
                                    endTimestamp: 1e3 * (0, eU.ph)(),
                                    startTimestamp: R,
                                    xhr: _
                                };
                                triggerHandlers("xhr", C)
                            }
                        };
                        return "onreadystatechange" in _ && "function" == typeof _.onreadystatechange ? _.onreadystatechange = new Proxy(_.onreadystatechange, {
                            apply: (m, _, C) => (onreadystatechangeHandler(), m.apply(_, C))
                        }) : _.addEventListener("readystatechange", onreadystatechangeHandler), _.setRequestHeader = new Proxy(_.setRequestHeader, {
                            apply(m, _, C) {
                                let [R, L] = C, B = _[eZ];
                                return B && (0, eB.HD)(R) && (0, eB.HD)(L) && (B.request_headers[R.toLowerCase()] = L), m.apply(_, C)
                            }
                        }), m.apply(_, C)
                    }
                }), m.send = new Proxy(m.send, {
                    apply(m, _, C) {
                        let R = _[eZ];
                        if (!R) return m.apply(_, C);
                        void 0 !== C[0] && (R.body = C[0]);
                        let L = {
                            startTimestamp: 1e3 * (0, eU.ph)(),
                            xhr: _
                        };
                        return triggerHandlers("xhr", L), m.apply(_, C)
                    }
                })
            }

            function addBreadcrumb(m, _) {
                let C = (0, eI.s3)(),
                    R = (0, eI.aF)();
                if (!C) return;
                let {
                    beforeBreadcrumb: L = null,
                    maxBreadcrumbs: B = 100
                } = C.getOptions();
                if (B <= 0) return;
                let F = (0, eU.yW)(),
                    U = {
                        timestamp: F,
                        ...m
                    },
                    H = L ? (0, ev.Cf)(() => L(U, _)) : U;
                null !== H && (C.emit && C.emit("beforeAddBreadcrumb", H, _), R.addBreadcrumb(H, B))
            }

            function instrumentConsole() {
                "console" in eT.GLOBAL_OBJ && ev.RU.forEach(function(m) {
                    m in eT.GLOBAL_OBJ.console && (0, ex.hl)(eT.GLOBAL_OBJ.console, m, function(_) {
                        return ev.LD[m] = _,
                            function(..._) {
                                triggerHandlers("console", {
                                    args: _,
                                    level: m
                                });
                                let C = ev.LD[m];
                                C && C.apply(eT.GLOBAL_OBJ.console, _)
                            }
                    })
                })
            }

            function addFetchInstrumentationHandler(m, _) {
                let C = "fetch";
                addHandler(C, m), maybeInstrument(C, () => instrumentFetch(void 0, _))
            }

            function instrumentFetch(m, _ = !1) {
                (!_ || function() {
                    if ("string" == typeof EdgeRuntime) return !0;
                    if (! function() {
                            if (!("fetch" in eA)) return !1;
                            try {
                                return new Headers, new Request("http://www.example.com"), new Response, !0
                            } catch (m) {
                                return !1
                            }
                        }()) return !1;
                    if (isNativeFunction(eA.fetch)) return !0;
                    let m = !1,
                        _ = eA.document;
                    if (_ && "function" == typeof _.createElement) try {
                        let C = _.createElement("iframe");
                        C.hidden = !0, _.head.appendChild(C), C.contentWindow && C.contentWindow.fetch && (m = isNativeFunction(C.contentWindow.fetch)), _.head.removeChild(C)
                    } catch (m) {
                        eM.X && ev.kg.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", m)
                    }
                    return m
                }()) && (0, ex.hl)(eT.GLOBAL_OBJ, "fetch", function(_) {
                    return function(...C) {
                        let {
                            method: R,
                            url: L
                        } = function(m) {
                            if (0 === m.length) return {
                                method: "GET",
                                url: ""
                            };
                            if (2 === m.length) {
                                let [_, C] = m;
                                return {
                                    url: getUrlFromResource(_),
                                    method: hasProp(C, "method") ? String(C.method).toUpperCase() : "GET"
                                }
                            }
                            let _ = m[0];
                            return {
                                url: getUrlFromResource(_),
                                method: hasProp(_, "method") ? String(_.method).toUpperCase() : "GET"
                            }
                        }(C), B = {
                            args: C,
                            fetchData: {
                                method: R,
                                url: L
                            },
                            startTimestamp: 1e3 * (0, eU.ph)()
                        };
                        m || triggerHandlers("fetch", { ...B
                        });
                        let F = Error().stack;
                        return _.apply(eT.GLOBAL_OBJ, C).then(async _ => (m ? m(_) : triggerHandlers("fetch", { ...B,
                            endTimestamp: 1e3 * (0, eU.ph)(),
                            response: _
                        }), _), m => {
                            throw triggerHandlers("fetch", { ...B,
                                endTimestamp: 1e3 * (0, eU.ph)(),
                                error: m
                            }), (0, eB.VZ)(m) && void 0 === m.stack && (m.stack = F, (0, ex.xp)(m, "framesToPop", 1)), m
                        })
                    }
                })
            }
            async function resolveResponse(m, _) {
                if (m && m.body) {
                    let C = m.body,
                        R = C.getReader(),
                        L = setTimeout(() => {
                            C.cancel().then(null, () => {})
                        }, 9e4),
                        B = !0;
                    for (; B;) {
                        let m;
                        try {
                            m = setTimeout(() => {
                                C.cancel().then(null, () => {})
                            }, 5e3);
                            let {
                                done: L
                            } = await R.read();
                            clearTimeout(m), L && (_(), B = !1)
                        } catch (m) {
                            B = !1
                        } finally {
                            clearTimeout(m)
                        }
                    }
                    clearTimeout(L), R.releaseLock(), C.cancel().then(null, () => {})
                }
            }

            function streamHandler(m) {
                let _;
                try {
                    _ = m.clone()
                } catch (m) {
                    return
                }
                resolveResponse(_, () => {
                    triggerHandlers("fetch-body-resolved", {
                        endTimestamp: 1e3 * (0, eU.ph)(),
                        response: m
                    })
                })
            }

            function hasProp(m, _) {
                return !!m && "object" == typeof m && !!m[_]
            }

            function getUrlFromResource(m) {
                return "string" == typeof m ? m : m ? hasProp(m, "url") ? m.url : m.toString ? m.toString() : "" : ""
            }
            var eY = C(1869);
            let eQ = ["fatal", "error", "warning", "log", "info", "debug"];

            function getBreadcrumbLogLevelFromHttpStatusCode(m) {
                if (void 0 !== m) return m >= 400 && m < 500 ? "warning" : m >= 500 ? "error" : void 0
            }

            function url_parseUrl(m) {
                if (!m) return {};
                let _ = m.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
                if (!_) return {};
                let C = _[6] || "",
                    R = _[8] || "";
                return {
                    host: _[4],
                    path: _[5],
                    protocol: _[2],
                    search: C,
                    hash: R,
                    relative: _[5] + C + R
                }
            }
            let breadcrumbsIntegration = (m = {}) => {
                    let _ = {
                        console: !0,
                        dom: !0,
                        fetch: !0,
                        history: !0,
                        sentry: !0,
                        xhr: !0,
                        ...m
                    };
                    return {
                        name: "Breadcrumbs",
                        setup(m) {
                            var C;
                            _.console && function(m) {
                                let _ = "console";
                                addHandler(_, m), maybeInstrument(_, instrumentConsole)
                            }(function(_) {
                                var C;
                                if ((0, eI.s3)() !== m) return;
                                let R = {
                                    category: "console",
                                    data: {
                                        arguments: _.args,
                                        logger: "console"
                                    },
                                    level: "warn" === (C = _.level) ? "warning" : eQ.includes(C) ? C : "log",
                                    message: (0, eS.nK)(_.args, " ")
                                };
                                if ("assert" === _.level) {
                                    if (!1 !== _.args[0]) return;
                                    R.message = `Assertion failed: ${(0,eS.nK)(_.args.slice(1)," ")||"console.assert"}`, R.data.arguments = _.args.slice(1)
                                }
                                addBreadcrumb(R, {
                                    input: _.args,
                                    level: _.level
                                })
                            }), _.dom && addClickKeypressInstrumentationHandler((C = _.dom, function(_) {
                                let R, L;
                                if ((0, eI.s3)() !== m) return;
                                let B = "object" == typeof C ? C.serializeAttribute : void 0,
                                    F = "object" == typeof C && "number" == typeof C.maxStringLength ? C.maxStringLength : void 0;
                                F && F > 1024 && (F = 1024), "string" == typeof B && (B = [B]);
                                try {
                                    let m = _.event,
                                        C = m && m.target ? m.target : m;
                                    R = (0, eY.Rt)(C, {
                                        keyAttrs: B,
                                        maxStringLength: F
                                    }), L = (0, eY.iY)(C)
                                } catch (m) {
                                    R = "<unknown>"
                                }
                                if (0 === R.length) return;
                                let U = {
                                    category: `ui.${_.name}`,
                                    message: R
                                };
                                L && (U.data = {
                                    "ui.component_name": L
                                }), addBreadcrumb(U, {
                                    event: _.event,
                                    name: _.name,
                                    global: _.global
                                })
                            })), _.xhr && addXhrInstrumentationHandler(function(_) {
                                if ((0, eI.s3)() !== m) return;
                                let {
                                    startTimestamp: C,
                                    endTimestamp: R
                                } = _, L = _.xhr[eZ];
                                if (!C || !R || !L) return;
                                let {
                                    method: B,
                                    url: F,
                                    status_code: U,
                                    body: H
                                } = L, q = {
                                    xhr: _.xhr,
                                    input: H,
                                    startTimestamp: C,
                                    endTimestamp: R
                                }, V = getBreadcrumbLogLevelFromHttpStatusCode(U);
                                addBreadcrumb({
                                    category: "xhr",
                                    data: {
                                        method: B,
                                        url: F,
                                        status_code: U
                                    },
                                    type: "http",
                                    level: V
                                }, q)
                            }), _.fetch && addFetchInstrumentationHandler(function(_) {
                                if ((0, eI.s3)() !== m) return;
                                let {
                                    startTimestamp: C,
                                    endTimestamp: R
                                } = _;
                                if (!(!R || _.fetchData.url.match(/sentry_key/) && "POST" === _.fetchData.method)) {
                                    if (_.error) {
                                        let m = _.fetchData,
                                            L = {
                                                data: _.error,
                                                input: _.args,
                                                startTimestamp: C,
                                                endTimestamp: R
                                            };
                                        addBreadcrumb({
                                            category: "fetch",
                                            data: m,
                                            level: "error",
                                            type: "http"
                                        }, L)
                                    } else {
                                        let m = _.response,
                                            L = { ..._.fetchData,
                                                status_code: m && m.status
                                            },
                                            B = {
                                                input: _.args,
                                                response: m,
                                                startTimestamp: C,
                                                endTimestamp: R
                                            },
                                            F = getBreadcrumbLogLevelFromHttpStatusCode(L.status_code);
                                        addBreadcrumb({
                                            category: "fetch",
                                            data: L,
                                            type: "http",
                                            level: F
                                        }, B)
                                    }
                                }
                            }), _.history && addHistoryInstrumentationHandler(function(_) {
                                if ((0, eI.s3)() !== m) return;
                                let C = _.from,
                                    R = _.to,
                                    L = url_parseUrl(eX.location.href),
                                    B = C ? url_parseUrl(C) : void 0,
                                    F = url_parseUrl(R);
                                B && B.path || (B = L), L.protocol === F.protocol && L.host === F.host && (R = F.relative), L.protocol === B.protocol && L.host === B.host && (C = B.relative), addBreadcrumb({
                                    category: "navigation",
                                    data: {
                                        from: C,
                                        to: R
                                    }
                                })
                            }), _.sentry && m.on("beforeSendEvent", function(_) {
                                (0, eI.s3)() === m && addBreadcrumb({
                                    category: `sentry.${"transaction"===_.type?"transaction":"event"}`,
                                    event_id: _.event_id,
                                    level: _.level,
                                    message: (0, eb.jH)(_)
                                }, {
                                    event: _
                                })
                            })
                        }
                    }
                },
                e0 = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"],
                browserApiErrorsIntegration = (m = {}) => {
                    let _ = {
                        XMLHttpRequest: !0,
                        eventTarget: !0,
                        requestAnimationFrame: !0,
                        setInterval: !0,
                        setTimeout: !0,
                        ...m
                    };
                    return {
                        name: "BrowserApiErrors",
                        setupOnce() {
                            _.setTimeout && (0, ex.hl)(eX, "setTimeout", _wrapTimeFunction), _.setInterval && (0, ex.hl)(eX, "setInterval", _wrapTimeFunction), _.requestAnimationFrame && (0, ex.hl)(eX, "requestAnimationFrame", _wrapRAF), _.XMLHttpRequest && "XMLHttpRequest" in eX && (0, ex.hl)(XMLHttpRequest.prototype, "send", _wrapXHR);
                            let m = _.eventTarget;
                            if (m) {
                                let _ = Array.isArray(m) ? m : e0;
                                _.forEach(_wrapEventTarget)
                            }
                        }
                    }
                };

            function _wrapTimeFunction(m) {
                return function(..._) {
                    let C = _[0];
                    return _[0] = wrap(C, {
                        mechanism: {
                            data: {
                                function: (0, eC.$P)(m)
                            },
                            handled: !1,
                            type: "instrument"
                        }
                    }), m.apply(this, _)
                }
            }

            function _wrapRAF(m) {
                return function(_) {
                    return m.apply(this, [wrap(_, {
                        mechanism: {
                            data: {
                                function: "requestAnimationFrame",
                                handler: (0, eC.$P)(m)
                            },
                            handled: !1,
                            type: "instrument"
                        }
                    })])
                }
            }

            function _wrapXHR(m) {
                return function(..._) {
                    let C = this;
                    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(m => {
                        m in C && "function" == typeof C[m] && (0, ex.hl)(C, m, function(_) {
                            let C = {
                                    mechanism: {
                                        data: {
                                            function: m,
                                            handler: (0, eC.$P)(_)
                                        },
                                        handled: !1,
                                        type: "instrument"
                                    }
                                },
                                R = (0, ex.HK)(_);
                            return R && (C.mechanism.data.handler = (0, eC.$P)(R)), wrap(_, C)
                        })
                    }), m.apply(this, _)
                }
            }

            function _wrapEventTarget(m) {
                let _ = eX[m] && eX[m].prototype;
                _ && _.hasOwnProperty && _.hasOwnProperty("addEventListener") && ((0, ex.hl)(_, "addEventListener", function(_) {
                    return function(C, R, L) {
                        try {
                            "function" == typeof R.handleEvent && (R.handleEvent = wrap(R.handleEvent, {
                                mechanism: {
                                    data: {
                                        function: "handleEvent",
                                        handler: (0, eC.$P)(R),
                                        target: m
                                    },
                                    handled: !1,
                                    type: "instrument"
                                }
                            }))
                        } catch (m) {}
                        return _.apply(this, [C, wrap(R, {
                            mechanism: {
                                data: {
                                    function: "addEventListener",
                                    handler: (0, eC.$P)(R),
                                    target: m
                                },
                                handled: !1,
                                type: "instrument"
                            }
                        }), L])
                    }
                }), (0, ex.hl)(_, "removeEventListener", function(m) {
                    return function(_, C, R) {
                        try {
                            let L = C && C.__sentry_wrapped__;
                            L && m.call(this, _, L, R)
                        } catch (m) {}
                        return m.call(this, _, C, R)
                    }
                }))
            }
            let e1 = null;

            function addGlobalErrorInstrumentationHandler(m) {
                let _ = "error";
                addHandler(_, m), maybeInstrument(_, instrumentError)
            }

            function instrumentError() {
                e1 = eT.GLOBAL_OBJ.onerror, eT.GLOBAL_OBJ.onerror = function(m, _, C, R, L) {
                    return triggerHandlers("error", {
                        column: R,
                        error: L,
                        line: C,
                        msg: m,
                        url: _
                    }), !!e1 && !e1.__SENTRY_LOADER__ && e1.apply(this, arguments)
                }, eT.GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = !0
            }
            let e2 = null;

            function addGlobalUnhandledRejectionInstrumentationHandler(m) {
                let _ = "unhandledrejection";
                addHandler(_, m), maybeInstrument(_, instrumentUnhandledRejection)
            }

            function instrumentUnhandledRejection() {
                e2 = eT.GLOBAL_OBJ.onunhandledrejection, eT.GLOBAL_OBJ.onunhandledrejection = function(m) {
                    return triggerHandlers("unhandledrejection", m), !e2 || !!e2.__SENTRY_LOADER__ || e2.apply(this, arguments)
                }, eT.GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
            }
            let globalHandlersIntegration = (m = {}) => {
                let _ = {
                    onerror: !0,
                    onunhandledrejection: !0,
                    ...m
                };
                return {
                    name: "GlobalHandlers",
                    setupOnce() {
                        Error.stackTraceLimit = 50
                    },
                    setup(m) {
                        _.onerror && addGlobalErrorInstrumentationHandler(_ => {
                            let {
                                stackParser: C,
                                attachStacktrace: R
                            } = getOptions();
                            if ((0, eI.s3)() !== m || eK > 0) return;
                            let {
                                msg: L,
                                url: B,
                                line: F,
                                column: U,
                                error: H
                            } = _, q = function(m, _, C, R) {
                                let L = m.exception = m.exception || {},
                                    B = L.values = L.values || [],
                                    F = B[0] = B[0] || {},
                                    U = F.stacktrace = F.stacktrace || {},
                                    H = U.frames = U.frames || [],
                                    q = isNaN(parseInt(R, 10)) ? void 0 : R,
                                    V = isNaN(parseInt(C, 10)) ? void 0 : C,
                                    X = (0, eB.HD)(_) && _.length > 0 ? _ : (0, eY.l4)();
                                return 0 === H.length && H.push({
                                    colno: q,
                                    filename: X,
                                    function: eC.Fi,
                                    in_app: !0,
                                    lineno: V
                                }), m
                            }(eventFromUnknownInput(C, H || L, void 0, R, !1), B, F, U);
                            q.level = "error", (0, e_.eN)(q, {
                                originalException: H,
                                mechanism: {
                                    handled: !1,
                                    type: "onerror"
                                }
                            })
                        }), _.onunhandledrejection && addGlobalUnhandledRejectionInstrumentationHandler(_ => {
                            let {
                                stackParser: C,
                                attachStacktrace: R
                            } = getOptions();
                            if ((0, eI.s3)() !== m || eK > 0) return;
                            let L = function(m) {
                                    if ((0, eB.pt)(m)) return m;
                                    try {
                                        if ("reason" in m) return m.reason;
                                        if ("detail" in m && "reason" in m.detail) return m.detail.reason
                                    } catch (m) {}
                                    return m
                                }(_),
                                B = (0, eB.pt)(L) ? {
                                    exception: {
                                        values: [{
                                            type: "UnhandledRejection",
                                            value: `Non-Error promise rejection captured with value: ${String(L)}`
                                        }]
                                    }
                                } : eventFromUnknownInput(C, L, void 0, R, !0);
                            B.level = "error", (0, e_.eN)(B, {
                                originalException: L,
                                mechanism: {
                                    handled: !1,
                                    type: "onunhandledrejection"
                                }
                            })
                        })
                    }
                }
            };

            function getOptions() {
                let m = (0, eI.s3)(),
                    _ = m && m.getOptions() || {
                        stackParser: () => [],
                        attachStacktrace: !1
                    };
                return _
            }
            let httpContextIntegration = () => ({
                name: "HttpContext",
                preprocessEvent(m) {
                    if (!eX.navigator && !eX.location && !eX.document) return;
                    let _ = m.request && m.request.url || eX.location && eX.location.href,
                        {
                            referrer: C
                        } = eX.document || {},
                        {
                            userAgent: R
                        } = eX.navigator || {},
                        L = { ...m.request && m.request.headers,
                            ...C && {
                                Referer: C
                            },
                            ...R && {
                                "User-Agent": R
                            }
                        },
                        B = { ...m.request,
                            ..._ && {
                                url: _
                            },
                            headers: L
                        };
                    m.request = B
                }
            });

            function applyExceptionGroupFieldsForParentException(m, _) {
                m.mechanism = m.mechanism || {
                    type: "generic",
                    handled: !0
                }, m.mechanism = { ...m.mechanism,
                    ..."AggregateError" === m.type && {
                        is_exception_group: !0
                    },
                    exception_id: _
                }
            }

            function applyExceptionGroupFieldsForChildException(m, _, C, R) {
                m.mechanism = m.mechanism || {
                    type: "generic",
                    handled: !0
                }, m.mechanism = { ...m.mechanism,
                    type: "chained",
                    source: _,
                    exception_id: C,
                    parent_id: R
                }
            }
            let linkedErrorsIntegration = (m = {}) => {
                let _ = m.limit || 5,
                    C = m.key || "cause";
                return {
                    name: "LinkedErrors",
                    preprocessEvent(m, R, L) {
                        let B = L.getOptions();
                        ! function(m, _, C = 250, R, L, B, F) {
                            if (!B.exception || !B.exception.values || !F || !(0, eB.V9)(F.originalException, Error)) return;
                            let U = B.exception.values.length > 0 ? B.exception.values[B.exception.values.length - 1] : void 0;
                            U && (B.exception.values = (function aggregateExceptionsFromError(m, _, C, R, L, B, F, U) {
                                if (B.length >= C + 1) return B;
                                let H = [...B];
                                if ((0, eB.V9)(R[L], Error)) {
                                    applyExceptionGroupFieldsForParentException(F, U);
                                    let B = m(_, R[L]),
                                        q = H.length;
                                    applyExceptionGroupFieldsForChildException(B, L, q, U), H = aggregateExceptionsFromError(m, _, C, R[L], L, [B, ...H], B, q)
                                }
                                return Array.isArray(R.errors) && R.errors.forEach((R, B) => {
                                    if ((0, eB.V9)(R, Error)) {
                                        applyExceptionGroupFieldsForParentException(F, U);
                                        let q = m(_, R),
                                            V = H.length;
                                        applyExceptionGroupFieldsForChildException(q, `errors[${B}]`, V, U), H = aggregateExceptionsFromError(m, _, C, R, L, [q, ...H], q, V)
                                    }
                                }), H
                            })(m, _, L, F.originalException, R, B.exception.values, U, 0).map(m => (m.value && (m.value = (0, eS.$G)(m.value, C)), m)))
                        }(exceptionFromError, B.stackParser, B.maxValueLength, C, _, m, R)
                    }
                }
            };

            function createFrame(m, _, C, R) {
                let L = {
                    filename: m,
                    function: "<anonymous>" === _ ? eC.Fi : _,
                    in_app: !0
                };
                return void 0 !== C && (L.lineno = C), void 0 !== R && (L.colno = R), L
            }
            let e3 = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i,
                e5 = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
                e6 = /\((\S*)(?::(\d+))(?::(\d+))\)/,
                e4 = [30, m => {
                    let _ = e3.exec(m);
                    if (_) {
                        let [, m, C, R] = _;
                        return createFrame(m, eC.Fi, +C, +R)
                    }
                    let C = e5.exec(m);
                    if (C) {
                        let m = C[2] && 0 === C[2].indexOf("eval");
                        if (m) {
                            let m = e6.exec(C[2]);
                            m && (C[2] = m[1], C[3] = m[2], C[4] = m[3])
                        }
                        let [_, R] = extractSafariExtensionDetails(C[1] || eC.Fi, C[2]);
                        return createFrame(R, _, C[3] ? +C[3] : void 0, C[4] ? +C[4] : void 0)
                    }
                }],
                e8 = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
                e9 = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
                e7 = [50, m => {
                    let _ = e8.exec(m);
                    if (_) {
                        let m = _[3] && _[3].indexOf(" > eval") > -1;
                        if (m) {
                            let m = e9.exec(_[3]);
                            m && (_[1] = _[1] || "eval", _[3] = m[1], _[4] = m[2], _[5] = "")
                        }
                        let C = _[3],
                            R = _[1] || eC.Fi;
                        return [R, C] = extractSafariExtensionDetails(R, C), createFrame(C, R, _[4] ? +_[4] : void 0, _[5] ? +_[5] : void 0)
                    }
                }],
                te = (0, eC.pE)(...[e4, e7]),
                extractSafariExtensionDetails = (m, _) => {
                    let C = -1 !== m.indexOf("safari-extension"),
                        R = -1 !== m.indexOf("safari-web-extension");
                    return C || R ? [-1 !== m.indexOf("@") ? m.split("@")[0] : eC.Fi, C ? `safari-extension:${_}` : `safari-web-extension:${_}`] : [m, _]
                },
                tt = {};

            function getNativeImplementation(m) {
                let _ = tt[m];
                if (_) return _;
                let C = eL[m];
                if (isNativeFunction(C)) return tt[m] = C.bind(eL);
                let R = eL.document;
                if (R && "function" == typeof R.createElement) try {
                    let _ = R.createElement("iframe");
                    _.hidden = !0, R.head.appendChild(_);
                    let L = _.contentWindow;
                    L && L[m] && (C = L[m]), R.head.removeChild(_)
                } catch (m) {}
                return C ? tt[m] = C.bind(eL) : C
            }

            function getNativeImplementation_setTimeout(...m) {
                return getNativeImplementation("setTimeout")(...m)
            }

            function isRateLimited(m, _, C = Date.now()) {
                return (m[_] || m.all || 0) > C
            }

            function updateRateLimits(m, {
                statusCode: _,
                headers: C
            }, R = Date.now()) {
                let L = { ...m
                    },
                    B = C && C["x-sentry-rate-limits"],
                    F = C && C["retry-after"];
                if (B)
                    for (let m of B.trim().split(",")) {
                        let [_, C, , , B] = m.split(":", 5), F = parseInt(_, 10), U = (isNaN(F) ? 60 : F) * 1e3;
                        if (C)
                            for (let m of C.split(";")) "metric_bucket" === m ? (!B || B.split(";").includes("custom")) && (L[m] = R + U) : L[m] = R + U;
                        else L.all = R + U
                    } else F ? L.all = R + function(m, _ = Date.now()) {
                        let C = parseInt(`${m}`, 10);
                        if (!isNaN(C)) return 1e3 * C;
                        let R = Date.parse(`${m}`);
                        return isNaN(R) ? 6e4 : R - _
                    }(F, R) : 429 === _ && (L.all = R + 6e4);
                return L
            }

            function getEventForEnvelopeItem(m, _) {
                if ("event" === _ || "transaction" === _) return Array.isArray(m) ? m[1] : void 0
            }

            function makeFetchTransport(m, _ = getNativeImplementation("fetch")) {
                let C = 0,
                    R = 0;
                return function(m, _, C = function(m) {
                    let _ = [];

                    function remove(m) {
                        return _.splice(_.indexOf(m), 1)[0] || Promise.resolve(void 0)
                    }
                    return {
                        $: _,
                        add: function(C) {
                            if (!(void 0 === m || _.length < m)) return (0, ej.$2)(new SentryError("Not adding Promise because buffer limit was reached."));
                            let R = C();
                            return -1 === _.indexOf(R) && _.push(R), R.then(() => remove(R)).then(null, () => remove(R).then(null, () => {})), R
                        },
                        drain: function(m) {
                            return new ej.cW((C, R) => {
                                let L = _.length;
                                if (!L) return C(!0);
                                let B = setTimeout(() => {
                                    m && m > 0 && C(!1)
                                }, m);
                                _.forEach(m => {
                                    (0, ej.WD)(m).then(() => {
                                        --L || (clearTimeout(B), C(!0))
                                    }, R)
                                })
                            })
                        }
                    }
                }(m.bufferSize || 64)) {
                    let R = {};
                    return {
                        send: function(L) {
                            let B = [];
                            if ((0, eF.gv)(L, (_, C) => {
                                    let L = (0, eF.mL)(C);
                                    if (isRateLimited(R, L)) {
                                        let R = getEventForEnvelopeItem(_, C);
                                        m.recordDroppedEvent("ratelimit_backoff", L, R)
                                    } else B.push(_)
                                }), 0 === B.length) return (0, ej.WD)({});
                            let F = (0, eF.Jd)(L[0], B),
                                recordEnvelopeLoss = _ => {
                                    (0, eF.gv)(F, (C, R) => {
                                        let L = getEventForEnvelopeItem(C, R);
                                        m.recordDroppedEvent(_, (0, eF.mL)(R), L)
                                    })
                                };
                            return C.add(() => _({
                                body: (0, eF.V$)(F)
                            }).then(m => (void 0 !== m.statusCode && (m.statusCode < 200 || m.statusCode >= 300) && ew.X && ev.kg.warn(`Sentry responded with status code ${m.statusCode} to sent event.`), R = updateRateLimits(R, m), m), m => {
                                throw recordEnvelopeLoss("network_error"), m
                            })).then(m => m, m => {
                                if (m instanceof SentryError) return ew.X && ev.kg.error("Skipped sending event because buffer is full."), recordEnvelopeLoss("queue_overflow"), (0, ej.WD)({});
                                throw m
                            })
                        },
                        flush: m => C.drain(m)
                    }
                }(m, function(L) {
                    let B = L.body.length;
                    C += B, R++;
                    let F = {
                        body: L.body,
                        method: "POST",
                        referrerPolicy: "origin",
                        headers: m.headers,
                        keepalive: C <= 6e4 && R < 15,
                        ...m.fetchOptions
                    };
                    if (!_) return tt.fetch = void 0, (0, ej.$2)("No fetch implementation available");
                    try {
                        return _(m.url, F).then(m => (C -= B, R--, {
                            statusCode: m.status,
                            headers: {
                                "x-sentry-rate-limits": m.headers.get("X-Sentry-Rate-Limits"),
                                "retry-after": m.headers.get("Retry-After")
                            }
                        }))
                    } catch (m) {
                        return tt.fetch = void 0, C -= B, R--, (0, ej.$2)(m)
                    }
                })
            }

            function getDefaultIntegrations(m) {
                return [inboundFiltersIntegration(), functionToStringIntegration(), browserApiErrorsIntegration(), breadcrumbsIntegration(), globalHandlersIntegration(), linkedErrorsIntegration(), dedupeIntegration(), httpContextIntegration()]
            }
            var tr = C(67294),
                tn = C(34155),
                ti = C(81585),
                to = C(99450),
                ta = C(31218),
                ts = C(72441);

            function _optionalChain(m) {
                let _;
                let C = m[0],
                    R = 1;
                for (; R < m.length;) {
                    let L = m[R],
                        B = m[R + 1];
                    if (R += 2, ("optionalAccess" === L || "optionalCall" === L) && null == C) return;
                    "access" === L || "optionalAccess" === L ? (_ = C, C = B(C)) : ("call" === L || "optionalCall" === L) && (C = B((...m) => C.call(_, ...m)), _ = void 0)
                }
                return C
            }
            let getRating = (m, _) => m > _[1] ? "poor" : m > _[0] ? "needs-improvement" : "good",
                bindReporter = (m, _, C, R) => {
                    let L, B;
                    return F => {
                        _.value >= 0 && (F || R) && ((B = _.value - (L || 0)) || void 0 === L) && (L = _.value, _.delta = B, _.rating = getRating(_.value, C), m(_))
                    }
                },
                generateUniqueID = () => `v3-${Date.now()}-${Math.floor(Math.random()*(9e12-1))+1e12}`,
                getNavigationEntry = () => eL.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0],
                getActivationStart = () => {
                    let m = getNavigationEntry();
                    return m && m.activationStart || 0
                },
                initMetric = (m, _) => {
                    let C = getNavigationEntry(),
                        R = "navigate";
                    return C && (eL.document && eL.document.prerendering || getActivationStart() > 0 ? R = "prerender" : eL.document && eL.document.wasDiscarded ? R = "restore" : C.type && (R = C.type.replace(/_/g, "-"))), {
                        name: m,
                        value: void 0 === _ ? -1 : _,
                        rating: "good",
                        delta: 0,
                        entries: [],
                        id: generateUniqueID(),
                        navigationType: R
                    }
                },
                observe = (m, _, C) => {
                    try {
                        if (PerformanceObserver.supportedEntryTypes.includes(m)) {
                            let R = new PerformanceObserver(m => {
                                Promise.resolve().then(() => {
                                    _(m.getEntries())
                                })
                            });
                            return R.observe(Object.assign({
                                type: m,
                                buffered: !0
                            }, C || {})), R
                        }
                    } catch (m) {}
                },
                onHidden = m => {
                    let onHiddenOrPageHide = _ => {
                        ("pagehide" === _.type || eL.document && "hidden" === eL.document.visibilityState) && m(_)
                    };
                    eL.document && (addEventListener("visibilitychange", onHiddenOrPageHide, !0), addEventListener("pagehide", onHiddenOrPageHide, !0))
                },
                runOnce = m => {
                    let _ = !1;
                    return C => {
                        _ || (m(C), _ = !0)
                    }
                },
                tc = -1,
                initHiddenTime = () => {
                    tc = "hidden" !== eL.document.visibilityState || eL.document.prerendering ? 1 / 0 : 0
                },
                onVisibilityUpdate = m => {
                    "hidden" === eL.document.visibilityState && tc > -1 && (tc = "visibilitychange" === m.type ? m.timeStamp : 0, removeEventListener("visibilitychange", onVisibilityUpdate, !0), removeEventListener("prerenderingchange", onVisibilityUpdate, !0))
                },
                addChangeListeners = () => {
                    addEventListener("visibilitychange", onVisibilityUpdate, !0), addEventListener("prerenderingchange", onVisibilityUpdate, !0)
                },
                getVisibilityWatcher = () => (eL.document && tc < 0 && (initHiddenTime(), addChangeListeners()), {
                    get firstHiddenTime() {
                        return tc
                    }
                }),
                whenActivated = m => {
                    eL.document && eL.document.prerendering ? addEventListener("prerenderingchange", () => m(), !0) : m()
                },
                tl = [1800, 3e3],
                onFCP = (m, _ = {}) => {
                    whenActivated(() => {
                        let C;
                        let R = getVisibilityWatcher(),
                            L = initMetric("FCP"),
                            B = observe("paint", m => {
                                m.forEach(m => {
                                    "first-contentful-paint" === m.name && (B.disconnect(), m.startTime < R.firstHiddenTime && (L.value = Math.max(m.startTime - getActivationStart(), 0), L.entries.push(m), C(!0)))
                                })
                            });
                        B && (C = bindReporter(m, L, tl, _.reportAllChanges))
                    })
                },
                tu = [.1, .25],
                onCLS = (m, _ = {}) => {
                    onFCP(runOnce(() => {
                        let C;
                        let R = initMetric("CLS", 0),
                            L = 0,
                            B = [],
                            handleEntries = m => {
                                m.forEach(m => {
                                    if (!m.hadRecentInput) {
                                        let _ = B[0],
                                            C = B[B.length - 1];
                                        L && _ && C && m.startTime - C.startTime < 1e3 && m.startTime - _.startTime < 5e3 ? (L += m.value, B.push(m)) : (L = m.value, B = [m])
                                    }
                                }), L > R.value && (R.value = L, R.entries = B, C())
                            },
                            F = observe("layout-shift", handleEntries);
                        F && (C = bindReporter(m, R, tu, _.reportAllChanges), onHidden(() => {
                            handleEntries(F.takeRecords()), C(!0)
                        }), setTimeout(C, 0))
                    }))
                },
                td = [100, 300],
                onFID = (m, _ = {}) => {
                    whenActivated(() => {
                        let C;
                        let R = getVisibilityWatcher(),
                            L = initMetric("FID"),
                            handleEntry = m => {
                                m.startTime < R.firstHiddenTime && (L.value = m.processingStart - m.startTime, L.entries.push(m), C(!0))
                            },
                            handleEntries = m => {
                                m.forEach(handleEntry)
                            },
                            B = observe("first-input", handleEntries);
                        C = bindReporter(m, L, td, _.reportAllChanges), B && onHidden(runOnce(() => {
                            handleEntries(B.takeRecords()), B.disconnect()
                        }))
                    })
                },
                tp = 0,
                th = 1 / 0,
                tf = 0,
                updateEstimate = m => {
                    m.forEach(m => {
                        m.interactionId && (th = Math.min(th, m.interactionId), tp = (tf = Math.max(tf, m.interactionId)) ? (tf - th) / 7 + 1 : 0)
                    })
                },
                getInteractionCount = () => H ? tp : performance.interactionCount || 0,
                initInteractionCountPolyfill = () => {
                    "interactionCount" in performance || H || (H = observe("event", updateEstimate, {
                        type: "event",
                        buffered: !0,
                        durationThreshold: 0
                    }))
                },
                tm = [200, 500],
                getInteractionCountForNavigation = () => getInteractionCount() - 0,
                tg = [],
                ty = {},
                processEntry = m => {
                    let _ = tg[tg.length - 1],
                        C = ty[m.interactionId];
                    if (C || tg.length < 10 || _ && m.duration > _.latency) {
                        if (C) C.entries.push(m), C.latency = Math.max(C.latency, m.duration);
                        else {
                            let _ = {
                                id: m.interactionId,
                                latency: m.duration,
                                entries: [m]
                            };
                            ty[_.id] = _, tg.push(_)
                        }
                        tg.sort((m, _) => _.latency - m.latency), tg.splice(10).forEach(m => {
                            delete ty[m.id]
                        })
                    }
                },
                estimateP98LongestInteraction = () => {
                    let m = Math.min(tg.length - 1, Math.floor(getInteractionCountForNavigation() / 50));
                    return tg[m]
                },
                onINP = (m, _ = {}) => {
                    whenActivated(() => {
                        let C;
                        initInteractionCountPolyfill();
                        let R = initMetric("INP"),
                            handleEntries = m => {
                                m.forEach(m => {
                                    if (m.interactionId && processEntry(m), "first-input" === m.entryType) {
                                        let _ = !tg.some(_ => _.entries.some(_ => m.duration === _.duration && m.startTime === _.startTime));
                                        _ && processEntry(m)
                                    }
                                });
                                let _ = estimateP98LongestInteraction();
                                _ && _.latency !== R.value && (R.value = _.latency, R.entries = _.entries, C())
                            },
                            L = observe("event", handleEntries, {
                                durationThreshold: null != _.durationThreshold ? _.durationThreshold : 40
                            });
                        C = bindReporter(m, R, tm, _.reportAllChanges), L && ("PerformanceEventTiming" in eL && "interactionId" in PerformanceEventTiming.prototype && L.observe({
                            type: "first-input",
                            buffered: !0
                        }), onHidden(() => {
                            handleEntries(L.takeRecords()), R.value < 0 && getInteractionCountForNavigation() > 0 && (R.value = 0, R.entries = []), C(!0)
                        }))
                    })
                },
                t_ = [2500, 4e3],
                tv = {},
                onLCP = (m, _ = {}) => {
                    whenActivated(() => {
                        let C;
                        let R = getVisibilityWatcher(),
                            L = initMetric("LCP"),
                            handleEntries = m => {
                                let _ = m[m.length - 1];
                                _ && _.startTime < R.firstHiddenTime && (L.value = Math.max(_.startTime - getActivationStart(), 0), L.entries = [_], C())
                            },
                            B = observe("largest-contentful-paint", handleEntries);
                        if (B) {
                            C = bindReporter(m, L, t_, _.reportAllChanges);
                            let R = runOnce(() => {
                                tv[L.id] || (handleEntries(B.takeRecords()), B.disconnect(), tv[L.id] = !0, C(!0))
                            });
                            ["keydown", "click"].forEach(m => {
                                eL.document && addEventListener(m, () => setTimeout(R, 0), !0)
                            }), onHidden(R)
                        }
                    })
                },
                tb = [800, 1800],
                whenReady = m => {
                    eL.document && eL.document.prerendering ? whenActivated(() => whenReady(m)) : eL.document && "complete" !== eL.document.readyState ? addEventListener("load", () => whenReady(m), !0) : setTimeout(m, 0)
                },
                onTTFB = (m, _ = {}) => {
                    let C = initMetric("TTFB"),
                        R = bindReporter(m, C, tb, _.reportAllChanges);
                    whenReady(() => {
                        let m = getNavigationEntry();
                        if (m) {
                            let _ = m.responseStart;
                            if (_ <= 0 || _ > performance.now()) return;
                            C.value = Math.max(_ - getActivationStart(), 0), C.entries = [m], R(!0)
                        }
                    })
                },
                tS = {},
                tw = {};

            function addClsInstrumentationHandler(m, _ = !1) {
                return addMetricObserver("cls", m, instrumentCls, q, _)
            }

            function addLcpInstrumentationHandler(m, _ = !1) {
                return addMetricObserver("lcp", m, instrumentLcp, X, _)
            }

            function addFidInstrumentationHandler(m) {
                return addMetricObserver("fid", m, instrumentFid, V)
            }

            function addInpInstrumentationHandler(m) {
                return addMetricObserver("inp", m, instrumentInp, Y)
            }

            function addPerformanceInstrumentationHandler(m, _) {
                return instrument_addHandler(m, _), tw[m] || (function(m) {
                    let _ = {};
                    "event" === m && (_.durationThreshold = 0), observe(m, _ => {
                        instrument_triggerHandlers(m, {
                            entries: _
                        })
                    }, _)
                }(m), tw[m] = !0), getCleanupCallback(m, _)
            }

            function instrument_triggerHandlers(m, _) {
                let C = tS[m];
                if (C && C.length)
                    for (let m of C) try {
                        m(_)
                    } catch (m) {}
            }

            function instrumentCls() {
                return onCLS(m => {
                    instrument_triggerHandlers("cls", {
                        metric: m
                    }), q = m
                }, {
                    reportAllChanges: !0
                })
            }

            function instrumentFid() {
                return onFID(m => {
                    instrument_triggerHandlers("fid", {
                        metric: m
                    }), V = m
                })
            }

            function instrumentLcp() {
                return onLCP(m => {
                    instrument_triggerHandlers("lcp", {
                        metric: m
                    }), X = m
                }, {
                    reportAllChanges: !0
                })
            }

            function instrumentTtfb() {
                return onTTFB(m => {
                    instrument_triggerHandlers("ttfb", {
                        metric: m
                    }), K = m
                })
            }

            function instrumentInp() {
                return onINP(m => {
                    instrument_triggerHandlers("inp", {
                        metric: m
                    }), Y = m
                })
            }

            function addMetricObserver(m, _, C, R, L = !1) {
                let B;
                return instrument_addHandler(m, _), tw[m] || (B = C(), tw[m] = !0), R && _({
                    metric: R
                }), getCleanupCallback(m, _, L ? B : void 0)
            }

            function instrument_addHandler(m, _) {
                tS[m] = tS[m] || [], tS[m].push(_)
            }

            function getCleanupCallback(m, _, C) {
                return () => {
                    C && C();
                    let R = tS[m];
                    if (!R) return;
                    let L = R.indexOf(_); - 1 !== L && R.splice(L, 1)
                }
            }

            function isMeasurementValue(m) {
                return "number" == typeof m && isFinite(m)
            }

            function startAndEndSpan(m, _, C, { ...R
            }) {
                let L = (0, ti.XU)(m).start_timestamp;
                return L && L > _ && "function" == typeof m.updateStartTime && m.updateStartTime(_), (0, to._d)(m, () => {
                    let m = (0, to.qp)({
                        startTime: _,
                        ...R
                    });
                    return m && m.end(C), m
                })
            }

            function startStandaloneWebVitalSpan(m) {
                let _;
                let C = (0, eI.s3)();
                if (!C) return;
                let {
                    name: R,
                    transaction: L,
                    attributes: B,
                    startTime: F
                } = m, {
                    release: U,
                    environment: H
                } = C.getOptions(), q = C.getIntegrationByName("Replay"), V = q && q.getReplayId(), X = (0, eI.nZ)(), K = X.getUser(), Y = void 0 !== K ? K.email || K.id || K.ip_address : void 0;
                try {
                    _ = X.getScopeData().contexts.profile.profile_id
                } catch (m) {}
                let Q = {
                    release: U,
                    environment: H,
                    user: Y || void 0,
                    profile_id: _ || void 0,
                    replay_id: V || void 0,
                    transaction: L,
                    "user_agent.original": eL.navigator && eL.navigator.userAgent,
                    ...B
                };
                return (0, to.qp)({
                    name: R,
                    attributes: Q,
                    startTime: F,
                    experimental: {
                        standalone: !0
                    }
                })
            }

            function getBrowserPerformanceAPI() {
                return eL && eL.addEventListener && eL.performance
            }

            function msToSec(m) {
                return m / 1e3
            }
            let tE = 0,
                tk = {};

            function _addPerformanceNavigationTiming(m, _, C, R, L, B) {
                let F = B ? _[B] : _[`${C}End`],
                    U = _[`${C}Start`];
                U && F && startAndEndSpan(m, R + msToSec(U), R + msToSec(F), {
                    op: `browser.${L||C}`,
                    name: _.name,
                    attributes: {
                        [ta.S3]: "auto.ui.browser.metrics"
                    }
                })
            }

            function setResourceEntrySizeData(m, _, C, R) {
                let L = _[C];
                null != L && L < 2147483647 && (m[R] = L)
            }
            let tx = [],
                tI = new Map,
                tO = {
                    click: "click",
                    pointerdown: "click",
                    pointerup: "click",
                    mousedown: "click",
                    mouseup: "click",
                    touchstart: "click",
                    touchend: "click",
                    mouseover: "hover",
                    mouseout: "hover",
                    mouseenter: "hover",
                    mouseleave: "hover",
                    pointerover: "hover",
                    pointerout: "hover",
                    pointerenter: "hover",
                    pointerleave: "hover",
                    dragstart: "drag",
                    dragend: "drag",
                    drag: "drag",
                    dragenter: "drag",
                    dragleave: "drag",
                    dragover: "drag",
                    drop: "drag",
                    keydown: "press",
                    keyup: "press",
                    keypress: "press",
                    input: "press"
                };
            var tC = C(67973),
                tM = C(89366),
                tT = C(58915),
                tA = C(69737);
            let tR = {
                idleTimeout: 1e3,
                finalTimeout: 3e4,
                childSpanTimeout: 15e3
            };

            function startIdleSpan(m, _ = {}) {
                let C;
                let R = new Map,
                    L = !1,
                    B = "externalFinish",
                    F = !_.disableAutoFinish,
                    U = [],
                    {
                        idleTimeout: H = tR.idleTimeout,
                        finalTimeout: q = tR.finalTimeout,
                        childSpanTimeout: V = tR.childSpanTimeout,
                        beforeSpanEnd: X
                    } = _,
                    K = (0, eI.s3)();
                if (!K || !(0, tC.z)()) return new tT.b;
                let Y = (0, eI.nZ)(),
                    Q = (0, ti.HN)(),
                    et = function(m) {
                        let _ = (0, to.qp)(m);
                        return (0, tM.D)((0, eI.nZ)(), _), ew.X && ev.kg.log("[Tracing] Started span is an idle span"), _
                    }(m);

                function _cancelIdleTimeout() {
                    C && (clearTimeout(C), C = void 0)
                }

                function _restartIdleTimeout(m) {
                    _cancelIdleTimeout(), C = setTimeout(() => {
                        !L && 0 === R.size && F && (B = "idleTimeout", et.end(m))
                    }, H)
                }

                function _restartChildSpanTimeout(m) {
                    C = setTimeout(() => {
                        !L && F && (B = "heartbeatFailed", et.end(m))
                    }, V)
                }

                function onIdleSpanEnded(m) {
                    L = !0, R.clear(), U.forEach(m => m()), (0, tM.D)(Y, Q);
                    let _ = (0, ti.XU)(et),
                        {
                            start_timestamp: C
                        } = _;
                    if (!C) return;
                    let F = _.data || {};
                    F[ta.ju] || et.setAttribute(ta.ju, B), ev.kg.log(`[Tracing] Idle span "${_.op}" finished`);
                    let V = (0, ti.Dp)(et).filter(m => m !== et),
                        X = 0;
                    V.forEach(_ => {
                        _.isRecording() && (_.setStatus({
                            code: tA.jt,
                            message: "cancelled"
                        }), _.end(m), ew.X && ev.kg.log("[Tracing] Cancelling span since span ended early", JSON.stringify(_, void 0, 2)));
                        let C = (0, ti.XU)(_),
                            {
                                timestamp: R = 0,
                                start_timestamp: L = 0
                            } = C,
                            B = L <= m,
                            F = (q + H) / 1e3,
                            U = R - L <= F;
                        if (ew.X) {
                            let m = JSON.stringify(_, void 0, 2);
                            B ? U || ev.kg.log("[Tracing] Discarding span since it finished after idle span final timeout", m) : ev.kg.log("[Tracing] Discarding span since it happened after idle span was finished", m)
                        }(!U || !B) && ((0, ti.ed)(et, _), X++)
                    }), X > 0 && et.setAttribute("sentry.idle_span_discarded_spans", X)
                }
                return et.end = new Proxy(et.end, {
                    apply(m, _, C) {
                        X && X(et);
                        let [R, ...L] = C, B = R || (0, eU.ph)(), F = (0, ti.$k)(B), U = (0, ti.Dp)(et).filter(m => m !== et);
                        if (!U.length) return onIdleSpanEnded(F), Reflect.apply(m, _, [F, ...L]);
                        let H = U.map(m => (0, ti.XU)(m).timestamp).filter(m => !!m),
                            V = H.length ? Math.max(...H) : void 0,
                            K = (0, ti.XU)(et).start_timestamp,
                            Y = Math.min(K ? K + q / 1e3 : 1 / 0, Math.max(K || -1 / 0, Math.min(F, V || 1 / 0)));
                        return onIdleSpanEnded(Y), Reflect.apply(m, _, [Y, ...L])
                    }
                }), U.push(K.on("spanStart", m => {
                    if (L || m === et || (0, ti.XU)(m).timestamp) return;
                    let _ = (0, ti.Dp)(et);
                    _.includes(m) && function(m) {
                        _cancelIdleTimeout(), R.set(m, !0);
                        let _ = (0, eU.ph)();
                        _restartChildSpanTimeout(_ + V / 1e3)
                    }(m.spanContext().spanId)
                })), U.push(K.on("spanEnd", m => {
                    L || function(m) {
                        if (R.has(m) && R.delete(m), 0 === R.size) {
                            let m = (0, eU.ph)();
                            _restartIdleTimeout(m + H / 1e3)
                        }
                    }(m.spanContext().spanId)
                })), U.push(K.on("idleSpanEnableAutoFinish", m => {
                    m === et && (F = !0, _restartIdleTimeout(), R.size && _restartChildSpanTimeout())
                })), _.disableAutoFinish || _restartIdleTimeout(), setTimeout(() => {
                    L || (et.setStatus({
                        code: tA.jt,
                        message: "deadline_exceeded"
                    }), B = "finalTimeout", et.end())
                }, q), et
            }
            let tP = !1;

            function errorCallback() {
                let m = (0, ti.HN)(),
                    _ = m && (0, ti.Gx)(m);
                if (_) {
                    let m = "internal_error";
                    ew.X && ev.kg.log(`[Tracing] Root span: ${m} -> Global error occured`), _.setStatus({
                        code: tA.jt,
                        message: m
                    })
                }
            }
            errorCallback.tag = "sentry_tracingErrorCallback";
            var tD = C(85712),
                tL = C(19548),
                tN = C(60859);
            let tB = new WeakMap,
                tj = new Map,
                tF = {
                    traceFetch: !0,
                    traceXHR: !0,
                    enableHTTPTimings: !0
                };

            function addHTTPTimings(m) {
                let {
                    url: _
                } = (0, ti.XU)(m).data || {};
                if (!_ || "string" != typeof _) return;
                let C = addPerformanceInstrumentationHandler("resource", ({
                    entries: R
                }) => {
                    R.forEach(R => {
                        if ("resource" === R.entryType && "initiatorType" in R && "string" == typeof R.nextHopProtocol && ("fetch" === R.initiatorType || "xmlhttprequest" === R.initiatorType) && R.name.endsWith(_)) {
                            let _ = function(m) {
                                let {
                                    name: _,
                                    version: C
                                } = function(m) {
                                    let _ = "unknown",
                                        C = "unknown",
                                        R = "";
                                    for (let L of m) {
                                        if ("/" === L) {
                                            [_, C] = m.split("/");
                                            break
                                        }
                                        if (!isNaN(Number(L))) {
                                            _ = "h" === R ? "http" : R, C = m.split(R)[1];
                                            break
                                        }
                                        R += L
                                    }
                                    return R === m && (_ = R), {
                                        name: _,
                                        version: C
                                    }
                                }(m.nextHopProtocol), R = [];
                                return (R.push(["network.protocol.version", C], ["network.protocol.name", _]), eU.Z1) ? [...R, ["http.request.redirect_start", getAbsoluteTime(m.redirectStart)],
                                    ["http.request.fetch_start", getAbsoluteTime(m.fetchStart)],
                                    ["http.request.domain_lookup_start", getAbsoluteTime(m.domainLookupStart)],
                                    ["http.request.domain_lookup_end", getAbsoluteTime(m.domainLookupEnd)],
                                    ["http.request.connect_start", getAbsoluteTime(m.connectStart)],
                                    ["http.request.secure_connection_start", getAbsoluteTime(m.secureConnectionStart)],
                                    ["http.request.connection_end", getAbsoluteTime(m.connectEnd)],
                                    ["http.request.request_start", getAbsoluteTime(m.requestStart)],
                                    ["http.request.response_start", getAbsoluteTime(m.responseStart)],
                                    ["http.request.response_end", getAbsoluteTime(m.responseEnd)]
                                ] : R
                            }(R);
                            _.forEach(_ => m.setAttribute(..._)), setTimeout(C)
                        }
                    })
                })
            }

            function getAbsoluteTime(m = 0) {
                return ((eU.Z1 || performance.timeOrigin) + m) / 1e3
            }

            function request_getFullURL(m) {
                try {
                    let _ = new URL(m, eX.location.origin);
                    return _.href
                } catch (m) {
                    return
                }
            }
            let tU = { ...tR,
                    instrumentNavigation: !0,
                    instrumentPageLoad: !0,
                    markBackgroundSpan: !0,
                    enableLongTask: !0,
                    enableLongAnimationFrame: !0,
                    enableInp: !0,
                    _experiments: {},
                    ...tF
                },
                browserTracingIntegration = (m = {}) => {
                    tP || (tP = !0, addGlobalErrorInstrumentationHandler(errorCallback), addGlobalUnhandledRejectionInstrumentationHandler(errorCallback));
                    let {
                        enableInp: _,
                        enableLongTask: C,
                        enableLongAnimationFrame: R,
                        _experiments: {
                            enableInteractions: L,
                            enableStandaloneClsSpans: B
                        },
                        beforeStartSpan: F,
                        idleTimeout: U,
                        finalTimeout: H,
                        childSpanTimeout: q,
                        markBackgroundSpan: V,
                        traceFetch: X,
                        traceXHR: Y,
                        shouldCreateSpanForRequest: er,
                        enableHTTPTimings: en,
                        instrumentPageLoad: ei,
                        instrumentNavigation: eo
                    } = { ...tU,
                        ...m
                    }, ea = function({
                        recordClsStandaloneSpans: m
                    }) {
                        let _ = getBrowserPerformanceAPI();
                        if (_ && eU.Z1) {
                            _.mark && eL.performance.mark("sentry-tracing-init");
                            let C = addFidInstrumentationHandler(({
                                    metric: m
                                }) => {
                                    let _ = m.entries[m.entries.length - 1];
                                    if (!_) return;
                                    let C = msToSec(eU.Z1),
                                        R = msToSec(_.startTime);
                                    tk.fid = {
                                        value: m.value,
                                        unit: "millisecond"
                                    }, tk["mark.fid"] = {
                                        value: C + R,
                                        unit: "second"
                                    }
                                }),
                                R = addLcpInstrumentationHandler(({
                                    metric: m
                                }) => {
                                    let _ = m.entries[m.entries.length - 1];
                                    _ && (tk.lcp = {
                                        value: m.value,
                                        unit: "millisecond"
                                    }, Q = _)
                                }, !0),
                                L = addMetricObserver("ttfb", ({
                                    metric: m
                                }) => {
                                    let _ = m.entries[m.entries.length - 1];
                                    _ && (tk.ttfb = {
                                        value: m.value,
                                        unit: "millisecond"
                                    })
                                }, instrumentTtfb, K),
                                B = m ? function() {
                                    let m, _, C = 0;
                                    if (! function() {
                                            try {
                                                return _optionalChain([PerformanceObserver, "access", m => m.supportedEntryTypes, "optionalAccess", m => m.includes, "call", m => m("layout-shift")])
                                            } catch (m) {
                                                return !1
                                            }
                                        }()) return;
                                    let R = !1;

                                    function _collectClsOnce() {
                                        R || (R = !0, _ && function(m, _, C) {
                                            let R = msToSec((eU.Z1 || 0) + (_optionalChain([_, "optionalAccess", m => m.startTime]) || 0)),
                                                L = (0, eI.nZ)().getScopeData().transactionName,
                                                B = _ ? (0, eY.Rt)(_optionalChain([_, "access", m => m.sources, "access", m => m[0], "optionalAccess", m => m.node])) : "Layout shift",
                                                F = (0, ex.Jr)({
                                                    [ta.S3]: "auto.http.browser.cls",
                                                    [ta.$J]: "ui.webvital.cls",
                                                    [ta.JQ]: _optionalChain([_, "optionalAccess", m => m.duration]) || 0,
                                                    "sentry.pageload.span_id": C
                                                }),
                                                U = startStandaloneWebVitalSpan({
                                                    name: B,
                                                    transaction: L,
                                                    attributes: F,
                                                    startTime: R
                                                });
                                            _optionalChain([U, "optionalAccess", m => m.addEvent, "call", _ => _("cls", {
                                                [ta.E1]: "",
                                                [ta.Wb]: m
                                            })]), _optionalChain([U, "optionalAccess", m => m.end, "call", m => m(R)])
                                        }(C, m, _), L())
                                    }
                                    let L = addClsInstrumentationHandler(({
                                        metric: _
                                    }) => {
                                        let R = _.entries[_.entries.length - 1];
                                        R && (C = _.value, m = R)
                                    }, !0);
                                    onHidden(() => {
                                        _collectClsOnce()
                                    }), setTimeout(() => {
                                        let m = (0, eI.s3)(),
                                            C = _optionalChain([m, "optionalAccess", m => m.on, "call", m => m("startNavigationSpan", () => {
                                                _collectClsOnce(), C && C()
                                            })]),
                                            R = (0, ti.HN)(),
                                            L = R && (0, ti.Gx)(R),
                                            B = L && (0, ti.XU)(L);
                                        B && "pageload" === B.op && (_ = L.spanContext().spanId)
                                    }, 0)
                                }() : addClsInstrumentationHandler(({
                                    metric: m
                                }) => {
                                    let _ = m.entries[m.entries.length - 1];
                                    _ && (tk.cls = {
                                        value: m.value,
                                        unit: ""
                                    }, et = _)
                                }, !0);
                            return () => {
                                C(), R(), L(), B && B()
                            }
                        }
                        return () => void 0
                    }({
                        recordClsStandaloneSpans: B || !1
                    });
                    _ && function() {
                        let m = getBrowserPerformanceAPI();
                        if (m && eU.Z1) {
                            let m = addInpInstrumentationHandler(({
                                metric: m
                            }) => {
                                if (void 0 == m.value) return;
                                let _ = m.entries.find(_ => _.duration === m.value && tO[_.name]);
                                if (!_) return;
                                let {
                                    interactionId: C
                                } = _, R = tO[_.name], L = msToSec(eU.Z1 + _.startTime), B = msToSec(m.value), F = (0, ti.HN)(), U = F ? (0, ti.Gx)(F) : void 0, H = null != C ? tI.get(C) : void 0, q = H || U, V = q ? (0, ti.XU)(q).description : (0, eI.nZ)().getScopeData().transactionName, X = (0, eY.Rt)(_.target), K = (0, ex.Jr)({
                                    [ta.S3]: "auto.http.browser.inp",
                                    [ta.$J]: `ui.interaction.${R}`,
                                    [ta.JQ]: _.duration
                                }), Y = startStandaloneWebVitalSpan({
                                    name: X,
                                    transaction: V,
                                    attributes: K,
                                    startTime: L
                                });
                                _optionalChain([Y, "optionalAccess", m => m.addEvent, "call", _ => _("inp", {
                                    [ta.E1]: "millisecond",
                                    [ta.Wb]: m.value
                                })]), _optionalChain([Y, "optionalAccess", m => m.end, "call", m => m(L + B)])
                            })
                        }
                    }(), R && eT.GLOBAL_OBJ.PerformanceObserver && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes("long-animation-frame") ? function() {
                        let m = new PerformanceObserver(m => {
                            if ((0, ti.HN)())
                                for (let _ of m.getEntries()) {
                                    if (!_.scripts[0]) continue;
                                    let m = msToSec(eU.Z1 + _.startTime),
                                        C = msToSec(_.duration),
                                        R = {
                                            [ta.S3]: "auto.ui.browser.metrics"
                                        },
                                        L = _.scripts[0],
                                        {
                                            invoker: B,
                                            invokerType: F,
                                            sourceURL: U,
                                            sourceFunctionName: H,
                                            sourceCharPosition: q
                                        } = L;
                                    R["browser.script.invoker"] = B, R["browser.script.invoker_type"] = F, U && (R["code.filepath"] = U), H && (R["code.function"] = H), -1 !== q && (R["browser.script.source_char_position"] = q);
                                    let V = (0, to.qp)({
                                        name: "Main UI thread blocked",
                                        op: "ui.long-animation-frame",
                                        startTime: m,
                                        attributes: R
                                    });
                                    V && V.end(m + C)
                                }
                        });
                        m.observe({
                            type: "long-animation-frame",
                            buffered: !0
                        })
                    }() : C && addPerformanceInstrumentationHandler("longtask", ({
                        entries: m
                    }) => {
                        if ((0, ti.HN)())
                            for (let _ of m) {
                                let m = msToSec(eU.Z1 + _.startTime),
                                    C = msToSec(_.duration),
                                    R = (0, to.qp)({
                                        name: "Main UI thread blocked",
                                        op: "ui.long-task",
                                        startTime: m,
                                        attributes: {
                                            [ta.S3]: "auto.ui.browser.metrics"
                                        }
                                    });
                                R && R.end(m + C)
                            }
                    }), L && addPerformanceInstrumentationHandler("event", ({
                        entries: m
                    }) => {
                        if ((0, ti.HN)()) {
                            for (let _ of m)
                                if ("click" === _.name) {
                                    let m = msToSec(eU.Z1 + _.startTime),
                                        C = msToSec(_.duration),
                                        R = {
                                            name: (0, eY.Rt)(_.target),
                                            op: `ui.interaction.${_.name}`,
                                            startTime: m,
                                            attributes: {
                                                [ta.S3]: "auto.ui.browser.metrics"
                                            }
                                        },
                                        L = (0, eY.iY)(_.target);
                                    L && (R.attributes["ui.component_name"] = L);
                                    let B = (0, to.qp)(R);
                                    B && B.end(m + C)
                                }
                        }
                    });
                    let es = {
                        name: void 0,
                        source: void 0
                    };

                    function _createRouteSpan(m, _) {
                        let C = "pageload" === _.op,
                            R = F ? F(_) : _,
                            L = R.attributes || {};
                        _.name !== R.name && (L[ta.Zj] = "custom", R.attributes = L), es.name = R.name, es.source = L[ta.Zj];
                        let V = startIdleSpan(R, {
                            idleTimeout: U,
                            finalTimeout: H,
                            childSpanTimeout: q,
                            disableAutoFinish: C,
                            beforeSpanEnd: m => {
                                ea(),
                                    function(m, _) {
                                        let C = getBrowserPerformanceAPI();
                                        if (!C || !eL.performance.getEntries || !eU.Z1) return;
                                        let R = msToSec(eU.Z1),
                                            L = C.getEntries(),
                                            {
                                                op: B,
                                                start_timestamp: F
                                            } = (0, ti.XU)(m);
                                        if (L.slice(tE).forEach(_ => {
                                                let C = msToSec(_.startTime),
                                                    L = msToSec(Math.max(0, _.duration));
                                                if ("navigation" !== B || !F || !(R + C < F)) switch (_.entryType) {
                                                    case "navigation":
                                                        ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach(C => {
                                                                _addPerformanceNavigationTiming(m, _, C, R)
                                                            }), _addPerformanceNavigationTiming(m, _, "secureConnection", R, "TLS/SSL", "connectEnd"), _addPerformanceNavigationTiming(m, _, "fetch", R, "cache", "domainLookupStart"), _addPerformanceNavigationTiming(m, _, "domainLookup", R, "DNS"),
                                                            function(m, _, C) {
                                                                let R = C + msToSec(_.requestStart),
                                                                    L = C + msToSec(_.responseEnd),
                                                                    B = C + msToSec(_.responseStart);
                                                                _.responseEnd && (startAndEndSpan(m, R, L, {
                                                                    op: "browser.request",
                                                                    name: _.name,
                                                                    attributes: {
                                                                        [ta.S3]: "auto.ui.browser.metrics"
                                                                    }
                                                                }), startAndEndSpan(m, B, L, {
                                                                    op: "browser.response",
                                                                    name: _.name,
                                                                    attributes: {
                                                                        [ta.S3]: "auto.ui.browser.metrics"
                                                                    }
                                                                }))
                                                            }(m, _, R);
                                                        break;
                                                    case "mark":
                                                    case "paint":
                                                    case "measure":
                                                        {
                                                            (function(m, _, C, R, L) {
                                                                let B = getNavigationEntry(),
                                                                    F = msToSec(B ? B.requestStart : 0),
                                                                    U = L + Math.max(C, F),
                                                                    H = L + C,
                                                                    q = {
                                                                        [ta.S3]: "auto.resource.browser.metrics"
                                                                    };
                                                                U !== H && (q["sentry.browser.measure_happened_before_request"] = !0, q["sentry.browser.measure_start_time"] = U), startAndEndSpan(m, U, H + R, {
                                                                    name: _.name,
                                                                    op: _.entryType,
                                                                    attributes: q
                                                                })
                                                            })(m, _, C, L, R);
                                                            let B = getVisibilityWatcher(),
                                                                F = _.startTime < B.firstHiddenTime;
                                                            "first-paint" === _.name && F && (tk.fp = {
                                                                value: _.startTime,
                                                                unit: "millisecond"
                                                            }),
                                                            "first-contentful-paint" === _.name && F && (tk.fcp = {
                                                                value: _.startTime,
                                                                unit: "millisecond"
                                                            });
                                                            break
                                                        }
                                                    case "resource":
                                                        (function(m, _, C, R, L, B) {
                                                            if ("xmlhttprequest" === _.initiatorType || "fetch" === _.initiatorType) return;
                                                            let F = url_parseUrl(C),
                                                                U = {
                                                                    [ta.S3]: "auto.resource.browser.metrics"
                                                                };
                                                            setResourceEntrySizeData(U, _, "transferSize", "http.response_transfer_size"), setResourceEntrySizeData(U, _, "encodedBodySize", "http.response_content_length"), setResourceEntrySizeData(U, _, "decodedBodySize", "http.decoded_response_content_length"), "renderBlockingStatus" in _ && (U["resource.render_blocking_status"] = _.renderBlockingStatus), F.protocol && (U["url.scheme"] = F.protocol.split(":").pop()), F.host && (U["server.address"] = F.host), U["url.same_origin"] = C.includes(eL.location.origin);
                                                            let H = B + R,
                                                                q = H + L;
                                                            startAndEndSpan(m, H, q, {
                                                                name: C.replace(eL.location.origin, ""),
                                                                op: _.initiatorType ? `resource.${_.initiatorType}` : "resource.other",
                                                                attributes: U
                                                            })
                                                        })(m, _, _.name, C, L, R)
                                                }
                                            }), tE = Math.max(L.length - 1, 0), function(m) {
                                                let _ = eL.navigator;
                                                if (!_) return;
                                                let C = _.connection;
                                                C && (C.effectiveType && m.setAttribute("effectiveConnectionType", C.effectiveType), C.type && m.setAttribute("connectionType", C.type), isMeasurementValue(C.rtt) && (tk["connection.rtt"] = {
                                                    value: C.rtt,
                                                    unit: "millisecond"
                                                })), isMeasurementValue(_.deviceMemory) && m.setAttribute("deviceMemory", `${_.deviceMemory} GB`), isMeasurementValue(_.hardwareConcurrency) && m.setAttribute("hardwareConcurrency", String(_.hardwareConcurrency))
                                            }(m), "pageload" === B) {
                                            (function(m) {
                                                let _ = getNavigationEntry();
                                                if (!_) return;
                                                let {
                                                    responseStart: C,
                                                    requestStart: R
                                                } = _;
                                                R <= C && (m["ttfb.requestTime"] = {
                                                    value: C - R,
                                                    unit: "millisecond"
                                                })
                                            })(tk);
                                            let C = tk["mark.fid"];
                                            C && tk.fid && (startAndEndSpan(m, C.value, C.value + msToSec(tk.fid.value), {
                                                name: "first input delay",
                                                op: "ui.action",
                                                attributes: {
                                                    [ta.S3]: "auto.ui.browser.metrics"
                                                }
                                            }), delete tk["mark.fid"]), "fcp" in tk && _.recordClsOnPageloadSpan || delete tk.cls, Object.entries(tk).forEach(([m, _]) => {
                                                (0, ts.o)(m, _.value, _.unit)
                                            }), m.setAttribute("performance.timeOrigin", R), m.setAttribute("performance.activationStart", getActivationStart()), Q && (Q.element && m.setAttribute("lcp.element", (0, eY.Rt)(Q.element)), Q.id && m.setAttribute("lcp.id", Q.id), Q.url && m.setAttribute("lcp.url", Q.url.trim().slice(0, 200)), m.setAttribute("lcp.size", Q.size)), et && et.sources && et.sources.forEach((_, C) => m.setAttribute(`cls.source.${C+1}`, (0, eY.Rt)(_.node)))
                                        }
                                        Q = void 0, et = void 0, tk = {}
                                    }(m, {
                                        recordClsOnPageloadSpan: !B
                                    })
                            }
                        });

                        function emitFinish() {
                            ["interactive", "complete"].includes(eX.document.readyState) && m.emit("idleSpanEnableAutoFinish", V)
                        }
                        return C && eX.document && (eX.document.addEventListener("readystatechange", () => {
                            emitFinish()
                        }), emitFinish()), V
                    }
                    return {
                        name: "BrowserTracing",
                        afterAllSetup(m) {
                            let C, R;
                            let B = eX.location && eX.location.href;
                            m.on("startNavigationSpan", _ => {
                                    (0, eI.s3)() === m && (C && !(0, ti.XU)(C).timestamp && C.end(), C = _createRouteSpan(m, {
                                        op: "navigation",
                                        ..._
                                    }))
                                }), m.on("startPageLoadSpan", (_, R = {}) => {
                                    if ((0, eI.s3)() !== m) return;
                                    C && !(0, ti.XU)(C).timestamp && C.end();
                                    let L = R.sentryTrace || getMetaContent("sentry-trace"),
                                        B = R.baggage || getMetaContent("baggage"),
                                        F = (0, tD.pT)(L, B);
                                    (0, eI.nZ)().setPropagationContext(F), C = _createRouteSpan(m, {
                                        op: "pageload",
                                        ..._
                                    })
                                }), m.on("spanEnd", m => {
                                    let _ = (0, ti.XU)(m).op;
                                    if (m !== (0, ti.Gx)(m) || "navigation" !== _ && "pageload" !== _) return;
                                    let C = (0, eI.nZ)(),
                                        R = C.getPropagationContext();
                                    C.setPropagationContext({ ...R,
                                        sampled: void 0 !== R.sampled ? R.sampled : (0, ti.Tt)(m),
                                        dsc: R.dsc || (0, e$.jC)(m)
                                    })
                                }), eX.location && (ei && startBrowserTracingPageLoadSpan(m, {
                                    name: eX.location.pathname,
                                    startTime: eU.Z1 ? eU.Z1 / 1e3 : void 0,
                                    attributes: {
                                        [ta.Zj]: "url",
                                        [ta.S3]: "auto.pageload.browser"
                                    }
                                }), eo && addHistoryInstrumentationHandler(({
                                    to: _,
                                    from: C
                                }) => {
                                    if (void 0 === C && B && -1 !== B.indexOf(_)) {
                                        B = void 0;
                                        return
                                    }
                                    C !== _ && (B = void 0, startBrowserTracingNavigationSpan(m, {
                                        name: eX.location.pathname,
                                        attributes: {
                                            [ta.Zj]: "url",
                                            [ta.S3]: "auto.navigation.browser"
                                        }
                                    }))
                                })), V && eX && eX.document && eX.document.addEventListener("visibilitychange", () => {
                                    let m = (0, ti.HN)();
                                    if (!m) return;
                                    let _ = (0, ti.Gx)(m);
                                    if (eX.document.hidden && _) {
                                        let {
                                            op: m,
                                            status: C
                                        } = (0, ti.XU)(_);
                                        C || _.setStatus({
                                            code: tA.jt,
                                            message: "cancelled"
                                        }), _.setAttribute("sentry.cancellation_reason", "document.hidden"), _.end()
                                    }
                                }), L && eX.document && addEventListener("click", () => {
                                    let m = (0, ti.HN)(),
                                        _ = m && (0, ti.Gx)(m);
                                    if (_) {
                                        let m = (0, ti.XU)(_).op;
                                        if (["navigation", "pageload"].includes(m)) return
                                    }
                                    R && (R.setAttribute(ta.ju, "interactionInterrupted"), R.end(), R = void 0), es.name && (R = startIdleSpan({
                                        name: es.name,
                                        op: "ui.action.click",
                                        attributes: {
                                            [ta.Zj]: es.source || "url"
                                        }
                                    }, {
                                        idleTimeout: U,
                                        finalTimeout: H,
                                        childSpanTimeout: q
                                    }))
                                }, {
                                    once: !1,
                                    capture: !0
                                }), _ && function() {
                                    let handleEntries = ({
                                        entries: m
                                    }) => {
                                        let _ = (0, ti.HN)(),
                                            C = _ && (0, ti.Gx)(_);
                                        m.forEach(m => {
                                            if (!("duration" in m) || !C) return;
                                            let _ = m.interactionId;
                                            if (!(null == _ || tI.has(_))) {
                                                if (tx.length > 10) {
                                                    let m = tx.shift();
                                                    tI.delete(m)
                                                }
                                                tx.push(_), tI.set(_, C)
                                            }
                                        })
                                    };
                                    addPerformanceInstrumentationHandler("event", handleEntries), addPerformanceInstrumentationHandler("first-input", handleEntries)
                                }(),
                                function(m, _) {
                                    let {
                                        traceFetch: C,
                                        traceXHR: R,
                                        shouldCreateSpanForRequest: L,
                                        enableHTTPTimings: B,
                                        tracePropagationTargets: F
                                    } = {
                                        traceFetch: tF.traceFetch,
                                        traceXHR: tF.traceXHR,
                                        ..._
                                    }, U = "function" == typeof L ? L : m => !0, shouldAttachHeadersWithTargets = m => (function(m, _) {
                                        let C = eX.location && eX.location.href;
                                        if (C) {
                                            let R, L;
                                            try {
                                                R = new URL(m, C), L = new URL(C).origin
                                            } catch (m) {
                                                return !1
                                            }
                                            let B = R.origin === L;
                                            return _ ? (0, eS.U0)(R.toString(), _) || B && (0, eS.U0)(R.pathname, _) : B
                                        } {
                                            let C = !!m.match(/^\/(?!\/)/);
                                            return _ ? (0, eS.U0)(m, _) : C
                                        }
                                    })(m, F), H = {};
                                    C && (m.addEventProcessor(m => ("transaction" === m.type && m.spans && m.spans.forEach(m => {
                                        if ("http.client" === m.op) {
                                            let _ = tj.get(m.span_id);
                                            _ && (m.timestamp = _ / 1e3, tj.delete(m.span_id))
                                        }
                                    }), m)), function(m) {
                                        let _ = "fetch-body-resolved";
                                        addHandler(_, m), maybeInstrument(_, () => instrumentFetch(streamHandler))
                                    }(m => {
                                        if (m.response) {
                                            let _ = tB.get(m.response);
                                            _ && m.endTimestamp && tj.set(_, m.endTimestamp)
                                        }
                                    }), addFetchInstrumentationHandler(m => {
                                        let _ = function(m, _, C, R, L = "auto.http.browser") {
                                            if (!m.fetchData) return;
                                            let B = (0, tC.z)() && _(m.fetchData.url);
                                            if (m.endTimestamp && B) {
                                                let _ = m.fetchData.__span;
                                                if (!_) return;
                                                let C = R[_];
                                                C && (function(m, _) {
                                                    if (_.response) {
                                                        (0, tA.Q0)(m, _.response.status);
                                                        let C = _.response && _.response.headers && _.response.headers.get("content-length");
                                                        if (C) {
                                                            let _ = parseInt(C);
                                                            _ > 0 && m.setAttribute("http.response_content_length", _)
                                                        }
                                                    } else _.error && m.setStatus({
                                                        code: tA.jt,
                                                        message: "internal_error"
                                                    });
                                                    m.end()
                                                }(C, m), delete R[_]);
                                                return
                                            }
                                            let F = (0, eI.nZ)(),
                                                U = (0, eI.s3)(),
                                                {
                                                    method: H,
                                                    url: q
                                                } = m.fetchData,
                                                V = function(m) {
                                                    try {
                                                        let _ = new URL(m);
                                                        return _.href
                                                    } catch (m) {
                                                        return
                                                    }
                                                }(q),
                                                X = V ? url_parseUrl(V).host : void 0,
                                                K = !!(0, ti.HN)(),
                                                Y = B && K ? (0, to.qp)({
                                                    name: `${H} ${q}`,
                                                    attributes: {
                                                        url: q,
                                                        type: "fetch",
                                                        "http.method": H,
                                                        "http.url": V,
                                                        "server.address": X,
                                                        [ta.S3]: L,
                                                        [ta.$J]: "http.client"
                                                    }
                                                }) : new tT.b;
                                            if (m.fetchData.__span = Y.spanContext().spanId, R[Y.spanContext().spanId] = Y, C(m.fetchData.url) && U) {
                                                let _ = m.args[0];
                                                m.args[1] = m.args[1] || {};
                                                let C = m.args[1];
                                                C.headers = function(m, _, C, R, L) {
                                                    let B = (0, eI.aF)(),
                                                        {
                                                            traceId: F,
                                                            spanId: U,
                                                            sampled: H,
                                                            dsc: q
                                                        } = { ...B.getPropagationContext(),
                                                            ...C.getPropagationContext()
                                                        },
                                                        V = L ? (0, ti.Hb)(L) : (0, tD.$p)(F, U, H),
                                                        X = (0, tN.IQ)(q || (L ? (0, e$.jC)(L) : (0, e$._l)(F, _))),
                                                        K = R.headers || ("undefined" != typeof Request && (0, eB.V9)(m, Request) ? m.headers : void 0);
                                                    if (!K) return {
                                                        "sentry-trace": V,
                                                        baggage: X
                                                    };
                                                    if ("undefined" != typeof Headers && (0, eB.V9)(K, Headers)) {
                                                        let m = new Headers(K);
                                                        return m.append("sentry-trace", V), X && m.append(tN.bU, X), m
                                                    }
                                                    if (Array.isArray(K)) {
                                                        let m = [...K, ["sentry-trace", V]];
                                                        return X && m.push([tN.bU, X]), m
                                                    } {
                                                        let m = "baggage" in K ? K.baggage : void 0,
                                                            _ = [];
                                                        return Array.isArray(m) ? _.push(...m) : m && _.push(m), X && _.push(X), { ...K,
                                                            "sentry-trace": V,
                                                            baggage: _.length > 0 ? _.join(",") : void 0
                                                        }
                                                    }
                                                }(_, U, F, C, (0, tC.z)() && K ? Y : void 0)
                                            }
                                            return Y
                                        }(m, U, shouldAttachHeadersWithTargets, H);
                                        if (m.response && m.fetchData.__span && tB.set(m.response, m.fetchData.__span), _) {
                                            let C = request_getFullURL(m.fetchData.url),
                                                R = C ? url_parseUrl(C).host : void 0;
                                            _.setAttributes({
                                                "http.url": C,
                                                "server.address": R
                                            })
                                        }
                                        B && _ && addHTTPTimings(_)
                                    })), R && addXhrInstrumentationHandler(m => {
                                        let _ = function(m, _, C, R) {
                                            let L = m.xhr,
                                                B = L && L[eZ];
                                            if (!L || L.__sentry_own_request__ || !B) return;
                                            let F = (0, tC.z)() && _(B.url);
                                            if (m.endTimestamp && F) {
                                                let m = L.__sentry_xhr_span_id__;
                                                if (!m) return;
                                                let _ = R[m];
                                                _ && void 0 !== B.status_code && ((0, tA.Q0)(_, B.status_code), _.end(), delete R[m]);
                                                return
                                            }
                                            let U = request_getFullURL(B.url),
                                                H = U ? url_parseUrl(U).host : void 0,
                                                q = !!(0, ti.HN)(),
                                                V = F && q ? (0, to.qp)({
                                                    name: `${B.method} ${B.url}`,
                                                    attributes: {
                                                        type: "xhr",
                                                        "http.method": B.method,
                                                        "http.url": U,
                                                        url: B.url,
                                                        "server.address": H,
                                                        [ta.S3]: "auto.http.browser",
                                                        [ta.$J]: "http.client"
                                                    }
                                                }) : new tT.b;
                                            L.__sentry_xhr_span_id__ = V.spanContext().spanId, R[L.__sentry_xhr_span_id__] = V;
                                            let X = (0, eI.s3)();
                                            return L.setRequestHeader && C(B.url) && X && function(m, _, C) {
                                                let R = (0, eI.nZ)(),
                                                    L = (0, eI.aF)(),
                                                    {
                                                        traceId: B,
                                                        spanId: F,
                                                        sampled: U,
                                                        dsc: H
                                                    } = { ...L.getPropagationContext(),
                                                        ...R.getPropagationContext()
                                                    },
                                                    q = C && (0, tC.z)() ? (0, ti.Hb)(C) : (0, tD.$p)(B, F, U),
                                                    V = (0, tN.IQ)(H || (C ? (0, e$.jC)(C) : (0, e$._l)(B, _)));
                                                (function(m, _, C) {
                                                    try {
                                                        m.setRequestHeader("sentry-trace", _), C && m.setRequestHeader(tN.bU, C)
                                                    } catch (m) {}
                                                })(m, q, V)
                                            }(L, X, (0, tC.z)() && q ? V : void 0), V
                                        }(m, U, shouldAttachHeadersWithTargets, H);
                                        B && _ && addHTTPTimings(_)
                                    })
                                }(m, {
                                    traceFetch: X,
                                    traceXHR: Y,
                                    tracePropagationTargets: m.getOptions().tracePropagationTargets,
                                    shouldCreateSpanForRequest: er,
                                    enableHTTPTimings: en
                                })
                        }
                    }
                };

            function startBrowserTracingPageLoadSpan(m, _, C) {
                m.emit("startPageLoadSpan", _, C), (0, eI.nZ)().setTransactionName(_.name);
                let R = (0, ti.HN)(),
                    L = R && (0, ti.XU)(R).op;
                return "pageload" === L ? R : void 0
            }

            function startBrowserTracingNavigationSpan(m, _) {
                (0, eI.aF)().setPropagationContext((0, tL.Q)()), (0, eI.nZ)().setPropagationContext((0, tL.Q)()), m.emit("startNavigationSpan", _), (0, eI.nZ)().setTransactionName(_.name);
                let C = (0, ti.HN)(),
                    R = C && (0, ti.XU)(C).op;
                return "navigation" === R ? C : void 0
            }

            function getMetaContent(m) {
                let _ = (0, eY.qT)(`meta[name=${m}]`);
                return _ ? _.getAttribute("content") : void 0
            }
            let tH = "incomplete-app-router-transaction",
                tW = eT.GLOBAL_OBJ;

            function transactionNameifyRouterArgument(m) {
                try {
                    return new URL(m, "http://some-random-base.com/").pathname
                } catch (m) {
                    return "/"
                }
            }
            var t$ = C(11163),
                tq = C(36096);
            let tG = t$.events ? t$ : t$.default,
                tz = /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/;

            function resolve(...m) {
                let _ = "",
                    C = !1;
                for (let R = m.length - 1; R >= -1 && !C; R--) {
                    let L = R >= 0 ? m[R] : "/";
                    L && (_ = `${L}/${_}`, C = "/" === L.charAt(0))
                }
                return _ = (function(m, _) {
                    let C = 0;
                    for (let _ = m.length - 1; _ >= 0; _--) {
                        let R = m[_];
                        "." === R ? m.splice(_, 1) : ".." === R ? (m.splice(_, 1), C++) : C && (m.splice(_, 1), C--)
                    }
                    if (_)
                        for (; C--; C) m.unshift("..");
                    return m
                })(_.split("/").filter(m => !!m), !C).join("/"), (C ? "/" : "") + _ || "."
            }

            function trim(m) {
                let _ = 0;
                for (; _ < m.length && "" === m[_]; _++);
                let C = m.length - 1;
                for (; C >= 0 && "" === m[C]; C--);
                return _ > C ? [] : m.slice(_, C - _ + 1)
            }
            let rewriteFramesIntegration = (m = {}) => {
                    let _ = m.root,
                        C = m.prefix || "app:///",
                        R = "window" in eT.GLOBAL_OBJ && void 0 !== eT.GLOBAL_OBJ.window,
                        L = m.iteratee || function({
                            isBrowser: m,
                            root: _,
                            prefix: C
                        }) {
                            return R => {
                                if (!R.filename) return R;
                                let L = /^[a-zA-Z]:\\/.test(R.filename) || R.filename.includes("\\") && !R.filename.includes("/"),
                                    B = /^\//.test(R.filename);
                                if (m) {
                                    if (_) {
                                        let m = R.filename;
                                        0 === m.indexOf(_) && (R.filename = m.replace(_, C))
                                    }
                                } else if (L || B) {
                                    var F;
                                    let m;
                                    let B = L ? R.filename.replace(/^[a-zA-Z]:/, "").replace(/\\/g, "/") : R.filename,
                                        U = _ ? function(m, _) {
                                            m = resolve(m).slice(1), _ = resolve(_).slice(1);
                                            let C = trim(m.split("/")),
                                                R = trim(_.split("/")),
                                                L = Math.min(C.length, R.length),
                                                B = L;
                                            for (let m = 0; m < L; m++)
                                                if (C[m] !== R[m]) {
                                                    B = m;
                                                    break
                                                }
                                            let F = [];
                                            for (let m = B; m < C.length; m++) F.push("..");
                                            return (F = F.concat(R.slice(B))).join("/")
                                        }(_, B) : (m = function(m) {
                                            let _ = m.length > 1024 ? `<truncated>${m.slice(-1024)}` : m,
                                                C = tz.exec(_);
                                            return C ? C.slice(1) : []
                                        }(B)[2] || "", F && m.slice(-1 * F.length) === F && (m = m.slice(0, m.length - F.length)), m);
                                    R.filename = `${C}${U}`
                                }
                                return R
                            }
                        }({
                            isBrowser: R,
                            root: _,
                            prefix: C
                        });
                    return {
                        name: "RewriteFrames",
                        processEvent(m) {
                            let _ = m;
                            return m.exception && Array.isArray(m.exception.values) && (_ = function(m) {
                                try {
                                    return { ...m,
                                        exception: { ...m.exception,
                                            values: m.exception.values.map(m => {
                                                var _;
                                                return { ...m,
                                                    ...m.stacktrace && {
                                                        stacktrace: { ..._ = m.stacktrace,
                                                            frames: _ && _.frames && _.frames.map(m => L(m))
                                                        }
                                                    }
                                                }
                                            })
                                        }
                                    }
                                } catch (_) {
                                    return m
                                }
                            }(_)), _
                        }
                    }
                },
                nextjsClientStackFrameNormalizationIntegration = ({
                    assetPrefixPath: m
                }) => {
                    let _ = rewriteFramesIntegration({
                        iteratee: _ => {
                            try {
                                let {
                                    origin: C
                                } = new URL(_.filename);
                                _.filename = _optionalChain([_, "access", m => m.filename, "optionalAccess", m => m.replace, "call", m => m(C, "app://"), "access", m => m.replace, "call", _ => _(m, "")])
                            } catch (m) {}
                            return _.filename && _.filename.startsWith("app:///_next") && (_.filename = decodeURI(_.filename)), _.filename && _.filename.match(/^app:\/\/\/_next\/static\/chunks\/(main-|main-app-|polyfills-|webpack-|framework-|framework\.)[0-9a-f]+\.js$/) && (_.in_app = !1), _
                        }
                    });
                    return { ..._,
                        name: "NextjsClientStackFrameNormalization"
                    }
                },
                tV = eT.GLOBAL_OBJ,
                tJ = eT.GLOBAL_OBJ;

            function removeTrailingSlash(m) {
                return "/" === m[m.length - 1] ? m.slice(0, -1) : m
            }
            var tX = C(34155);

            function isBrowser() {
                return "undefined" != typeof window && (!(!("undefined" != typeof __SENTRY_BROWSER_BUNDLE__ && __SENTRY_BROWSER_BUNDLE__) && "[object process]" === Object.prototype.toString.call(void 0 !== tX ? tX : 0)) || void 0 !== eT.GLOBAL_OBJ.process && "renderer" === eT.GLOBAL_OBJ.process.type)
            }
            let tK = eT.GLOBAL_OBJ,
                tZ = "sentryReplaySession",
                tY = "Unable to send Replay";

            function _nullishCoalesce$1(m, _) {
                return null != m ? m : _()
            }

            function _optionalChain$5(m) {
                let _;
                let C = m[0],
                    R = 1;
                for (; R < m.length;) {
                    let L = m[R],
                        B = m[R + 1];
                    if (R += 2, ("optionalAccess" === L || "optionalCall" === L) && null == C) return;
                    "access" === L || "optionalAccess" === L ? (_ = C, C = B(C)) : ("call" === L || "optionalCall" === L) && (C = B((...m) => C.call(_, ...m)), _ = void 0)
                }
                return C
            }

            function isShadowRoot(m) {
                let _ = _optionalChain$5([m, "optionalAccess", m => m.host]);
                return _optionalChain$5([_, "optionalAccess", m => m.shadowRoot]) === m
            }

            function isNativeShadowDom(m) {
                return "[object ShadowRoot]" === Object.prototype.toString.call(m)
            }

            function stringifyStylesheet(m) {
                try {
                    var _;
                    let C = m.rules || m.cssRules;
                    return C ? ((_ = Array.from(C, stringifyRule).join("")).includes(" background-clip: text;") && !_.includes(" -webkit-background-clip: text;") && (_ = _.replace(/\sbackground-clip:\s*text;/g, " -webkit-background-clip: text; background-clip: text;")), _) : null
                } catch (m) {
                    return null
                }
            }

            function stringifyRule(m) {
                let _;
                if ("styleSheet" in m) try {
                    _ = stringifyStylesheet(m.styleSheet) || function(m) {
                        let {
                            cssText: _
                        } = m;
                        if (_.split('"').length < 3) return _;
                        let C = ["@import", `url(${JSON.stringify(m.href)})`];
                        return "" === m.layerName ? C.push("layer") : m.layerName && C.push(`layer(${m.layerName})`), m.supportsText && C.push(`supports(${m.supportsText})`), m.media.length && C.push(m.media.mediaText), C.join(" ") + ";"
                    }(m)
                } catch (m) {} else if ("selectorText" in m && m.selectorText.includes(":")) return m.cssText.replace(/(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm, "$1\\$2");
                return _ || m.cssText
            }(ec = em || (em = {}))[ec.Document = 0] = "Document", ec[ec.DocumentType = 1] = "DocumentType", ec[ec.Element = 2] = "Element", ec[ec.Text = 3] = "Text", ec[ec.CDATA = 4] = "CDATA", ec[ec.Comment = 5] = "Comment";
            let Mirror = class Mirror {
                constructor() {
                    this.idNodeMap = new Map, this.nodeMetaMap = new WeakMap
                }
                getId(m) {
                    if (!m) return -1;
                    let _ = _optionalChain$5([this, "access", m => m.getMeta, "call", _ => _(m), "optionalAccess", m => m.id]);
                    return _nullishCoalesce$1(_, () => -1)
                }
                getNode(m) {
                    return this.idNodeMap.get(m) || null
                }
                getIds() {
                    return Array.from(this.idNodeMap.keys())
                }
                getMeta(m) {
                    return this.nodeMetaMap.get(m) || null
                }
                removeNodeFromMap(m) {
                    let _ = this.getId(m);
                    this.idNodeMap.delete(_), m.childNodes && m.childNodes.forEach(m => this.removeNodeFromMap(m))
                }
                has(m) {
                    return this.idNodeMap.has(m)
                }
                hasNode(m) {
                    return this.nodeMetaMap.has(m)
                }
                add(m, _) {
                    let C = _.id;
                    this.idNodeMap.set(C, m), this.nodeMetaMap.set(m, _)
                }
                replace(m, _) {
                    let C = this.getNode(m);
                    if (C) {
                        let m = this.nodeMetaMap.get(C);
                        m && this.nodeMetaMap.set(_, m)
                    }
                    this.idNodeMap.set(m, _)
                }
                reset() {
                    this.idNodeMap = new Map, this.nodeMetaMap = new WeakMap
                }
            };

            function shouldMaskInput({
                maskInputOptions: m,
                tagName: _,
                type: C
            }) {
                return "OPTION" === _ && (_ = "SELECT"), !!(m[_.toLowerCase()] || C && m[C] || "password" === C || "INPUT" === _ && !C && m.text)
            }

            function maskInputValue({
                isMasked: m,
                element: _,
                value: C,
                maskInputFn: R
            }) {
                let L = C || "";
                return m ? (R && (L = R(L, _)), "*".repeat(L.length)) : L
            }

            function toLowerCase(m) {
                return m.toLowerCase()
            }

            function toUpperCase(m) {
                return m.toUpperCase()
            }
            let tQ = "__rrweb_original__";

            function getInputType(m) {
                let _ = m.type;
                return m.hasAttribute("data-rr-is-password") ? "password" : _ ? toLowerCase(_) : null
            }

            function getInputValue(m, _, C) {
                return "INPUT" === _ && ("radio" === C || "checkbox" === C) ? m.getAttribute("value") || "" : m.value
            }

            function extractFileExtension(m, _) {
                let C;
                try {
                    C = new URL(m, _nullishCoalesce$1(_, () => window.location.href))
                } catch (m) {
                    return null
                }
                let R = C.pathname.match(/\.([0-9a-z]+)(?:$)/i);
                return _nullishCoalesce$1(_optionalChain$5([R, "optionalAccess", m => m[1]]), () => null)
            }
            let t0 = {};

            function getImplementation$1(m) {
                let _ = t0[m];
                if (_) return _;
                let C = window.document,
                    R = window[m];
                if (C && "function" == typeof C.createElement) try {
                    let _ = C.createElement("iframe");
                    _.hidden = !0, C.head.appendChild(_);
                    let L = _.contentWindow;
                    L && L[m] && (R = L[m]), C.head.removeChild(_)
                } catch (m) {}
                return t0[m] = R.bind(window)
            }

            function setTimeout$2(...m) {
                return getImplementation$1("setTimeout")(...m)
            }

            function clearTimeout$2(...m) {
                return getImplementation$1("clearTimeout")(...m)
            }
            let t1 = 1,
                t2 = RegExp("[^a-z0-9-_:]");

            function genId() {
                return t1++
            }
            let t3 = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm,
                t5 = /^(?:[a-z+]+:)?\/\//i,
                t6 = /^www\..*/i,
                t4 = /^(data:)([^,]*),(.*)/i;

            function absoluteToStylesheet(m, _) {
                return (m || "").replace(t3, (m, C, R, L, B, F) => {
                    let U = R || B || F,
                        H = C || L || "";
                    if (!U) return m;
                    if (t5.test(U) || t6.test(U) || t4.test(U)) return `url(${H}${U}${H})`;
                    if ("/" === U[0]) return `url(${H}${(_.indexOf("//")>-1?_.split("/").slice(0,3).join("/"):_.split("/")[0]).split("?")[0]+U}${H})`;
                    let q = _.split("/"),
                        V = U.split("/");
                    for (let m of (q.pop(), V)) "." !== m && (".." === m ? q.pop() : q.push(m));
                    return `url(${H}${q.join("/")}${H})`
                })
            }
            let t8 = /^[^ \t\n\r\u000c]+/,
                t9 = /^[, \t\n\r\u000c]+/,
                t7 = new WeakMap;

            function absoluteToDoc(m, _) {
                return _ && "" !== _.trim() ? getHref(m, _) : _
            }

            function getHref(m, _) {
                let C = t7.get(m);
                if (C || (C = m.createElement("a"), t7.set(m, C)), _) {
                    if (_.startsWith("blob:") || _.startsWith("data:")) return _
                } else _ = "";
                return C.setAttribute("href", _), C.href
            }

            function transformAttribute(m, _, C, R, L, B) {
                return R ? "src" !== C && ("href" !== C || "use" === _ && "#" === R[0]) && ("xlink:href" !== C || "#" === R[0]) && ("background" !== C || "table" !== _ && "td" !== _ && "th" !== _) ? "srcset" === C ? function(m, _) {
                    if ("" === _.trim()) return _;
                    let C = 0;

                    function collectCharacters(m) {
                        let R;
                        let L = m.exec(_.substring(C));
                        return L ? (R = L[0], C += R.length, R) : ""
                    }
                    let R = [];
                    for (; collectCharacters(t9), !(C >= _.length);) {
                        let L = collectCharacters(t8);
                        if ("," === L.slice(-1)) L = absoluteToDoc(m, L.substring(0, L.length - 1)), R.push(L);
                        else {
                            let B = "";
                            L = absoluteToDoc(m, L);
                            let F = !1;
                            for (;;) {
                                let m = _.charAt(C);
                                if ("" === m) {
                                    R.push((L + B).trim());
                                    break
                                }
                                if (F) ")" === m && (F = !1);
                                else {
                                    if ("," === m) {
                                        C += 1, R.push((L + B).trim());
                                        break
                                    }
                                    "(" === m && (F = !0)
                                }
                                B += m, C += 1
                            }
                        }
                    }
                    return R.join(", ")
                }(m, R) : "style" === C ? absoluteToStylesheet(R, getHref(m)) : "object" === _ && "data" === C ? absoluteToDoc(m, R) : "function" == typeof B ? B(C, R, L) : R : absoluteToDoc(m, R) : R
            }

            function ignoreAttribute(m, _, C) {
                return ("video" === m || "audio" === m) && "autoplay" === _
            }

            function distanceToMatch(m, _, C = 1 / 0, R = 0) {
                return !m || m.nodeType !== m.ELEMENT_NODE || R > C ? -1 : _(m) ? R : distanceToMatch(m.parentNode, _, C, R + 1)
            }

            function createMatchPredicate(m, _) {
                return C => {
                    if (null === C) return !1;
                    try {
                        if (m) {
                            if ("string" == typeof m) {
                                if (C.matches(`.${m}`)) return !0
                            } else if (function(m, _) {
                                    for (let C = m.classList.length; C--;) {
                                        let R = m.classList[C];
                                        if (_.test(R)) return !0
                                    }
                                    return !1
                                }(C, m)) return !0
                        }
                        if (_ && C.matches(_)) return !0;
                        return !1
                    } catch (m) {
                        return !1
                    }
                }
            }

            function needMaskingText(m, _, C, R, L, B) {
                try {
                    let F = m.nodeType === m.ELEMENT_NODE ? m : m.parentElement;
                    if (null === F) return !1;
                    if ("INPUT" === F.tagName) {
                        let m = F.getAttribute("autocomplete");
                        if (["current-password", "new-password", "cc-number", "cc-exp", "cc-exp-month", "cc-exp-year", "cc-csc"].includes(m)) return !0
                    }
                    let U = -1,
                        H = -1;
                    if (B) {
                        if ((H = distanceToMatch(F, createMatchPredicate(R, L))) < 0) return !0;
                        U = distanceToMatch(F, createMatchPredicate(_, C), H >= 0 ? H : 1 / 0)
                    } else {
                        if ((U = distanceToMatch(F, createMatchPredicate(_, C))) < 0) return !1;
                        H = distanceToMatch(F, createMatchPredicate(R, L), U >= 0 ? U : 1 / 0)
                    }
                    return U >= 0 ? !(H >= 0) || U <= H : !(H >= 0) && !!B
                } catch (m) {}
                return !!B
            }

            function lowerIfExists(m) {
                return null == m ? "" : m.toLowerCase()
            }

            function serializeNodeWithId(m, _) {
                let C;
                let {
                    doc: R,
                    mirror: L,
                    blockClass: B,
                    blockSelector: F,
                    unblockSelector: U,
                    maskAllText: H,
                    maskTextClass: q,
                    unmaskTextClass: V,
                    maskTextSelector: X,
                    unmaskTextSelector: K,
                    skipChild: Y = !1,
                    inlineStylesheet: Q = !0,
                    maskInputOptions: et = {},
                    maskAttributeFn: ei,
                    maskTextFn: eo,
                    maskInputFn: ea,
                    slimDOMOptions: es,
                    dataURLOptions: ec = {},
                    inlineImages: el = !1,
                    recordCanvas: eu = !1,
                    onSerialize: ed,
                    onIframeLoad: ep,
                    iframeLoadTimeout: eh = 5e3,
                    onStylesheetLoad: ef,
                    stylesheetLoadTimeout: eg = 5e3,
                    keepIframeSrcFn: ey = () => !1,
                    newlyAddedElement: e_ = !1
                } = _, {
                    preserveWhiteSpace: ev = !0
                } = _, eb = function(m, _) {
                    let {
                        doc: C,
                        mirror: R,
                        blockClass: L,
                        blockSelector: B,
                        unblockSelector: F,
                        maskAllText: U,
                        maskAttributeFn: H,
                        maskTextClass: q,
                        unmaskTextClass: V,
                        maskTextSelector: X,
                        unmaskTextSelector: K,
                        inlineStylesheet: Y,
                        maskInputOptions: Q = {},
                        maskTextFn: et,
                        maskInputFn: ei,
                        dataURLOptions: eo = {},
                        inlineImages: ea,
                        recordCanvas: es,
                        keepIframeSrcFn: ec,
                        newlyAddedElement: el = !1
                    } = _, eu = function(m, _) {
                        if (!_.hasNode(m)) return;
                        let C = _.getId(m);
                        return 1 === C ? void 0 : C
                    }(C, R);
                    switch (m.nodeType) {
                        case m.DOCUMENT_NODE:
                            if ("CSS1Compat" !== m.compatMode) return {
                                type: em.Document,
                                childNodes: [],
                                compatMode: m.compatMode
                            };
                            return {
                                type: em.Document,
                                childNodes: []
                            };
                        case m.DOCUMENT_TYPE_NODE:
                            return {
                                type: em.DocumentType,
                                name: m.name,
                                publicId: m.publicId,
                                systemId: m.systemId,
                                rootId: eu
                            };
                        case m.ELEMENT_NODE:
                            return function(m, _) {
                                let C;
                                let {
                                    doc: R,
                                    blockClass: L,
                                    blockSelector: B,
                                    unblockSelector: F,
                                    inlineStylesheet: U,
                                    maskInputOptions: H = {},
                                    maskAttributeFn: q,
                                    maskInputFn: V,
                                    dataURLOptions: X = {},
                                    inlineImages: K,
                                    recordCanvas: Y,
                                    keepIframeSrcFn: Q,
                                    newlyAddedElement: et = !1,
                                    rootId: ei,
                                    maskAllText: eo,
                                    maskTextClass: ea,
                                    unmaskTextClass: es,
                                    maskTextSelector: ec,
                                    unmaskTextSelector: el
                                } = _, eu = function(m, _, C, R) {
                                    try {
                                        if (R && m.matches(R)) return !1;
                                        if ("string" == typeof _) {
                                            if (m.classList.contains(_)) return !0
                                        } else
                                            for (let C = m.classList.length; C--;) {
                                                let R = m.classList[C];
                                                if (_.test(R)) return !0
                                            }
                                        if (C) return m.matches(C)
                                    } catch (m) {}
                                    return !1
                                }(m, L, B, F), ed = function(m) {
                                    if (m instanceof HTMLFormElement) return "form";
                                    let _ = toLowerCase(m.tagName);
                                    return t2.test(_) ? "div" : _
                                }(m), ep = {}, eh = m.attributes.length;
                                for (let _ = 0; _ < eh; _++) {
                                    let C = m.attributes[_];
                                    C.name && !ignoreAttribute(ed, C.name, C.value) && (ep[C.name] = transformAttribute(R, ed, toLowerCase(C.name), C.value, m, q))
                                }
                                if ("link" === ed && U) {
                                    let _ = Array.from(R.styleSheets).find(_ => _.href === m.href),
                                        C = null;
                                    _ && (C = stringifyStylesheet(_)), C && (delete ep.rel, delete ep.href, ep._cssText = absoluteToStylesheet(C, _.href))
                                }
                                if ("style" === ed && m.sheet && !(m.innerText || m.textContent || "").trim().length) {
                                    let _ = stringifyStylesheet(m.sheet);
                                    _ && (ep._cssText = absoluteToStylesheet(_, getHref(R)))
                                }
                                if ("input" === ed || "textarea" === ed || "select" === ed || "option" === ed) {
                                    let _ = getInputType(m),
                                        C = getInputValue(m, toUpperCase(ed), _),
                                        R = m.checked;
                                    if ("submit" !== _ && "button" !== _ && C) {
                                        let R = needMaskingText(m, ea, ec, es, el, shouldMaskInput({
                                            type: _,
                                            tagName: toUpperCase(ed),
                                            maskInputOptions: H
                                        }));
                                        ep.value = maskInputValue({
                                            isMasked: R,
                                            element: m,
                                            value: C,
                                            maskInputFn: V
                                        })
                                    }
                                    R && (ep.checked = R)
                                }
                                if ("option" === ed && (m.selected && !H.select ? ep.selected = !0 : delete ep.selected), "canvas" === ed && Y) {
                                    if ("2d" === m.__context) ! function(m) {
                                        let _ = m.getContext("2d");
                                        if (!_) return !0;
                                        for (let C = 0; C < m.width; C += 50)
                                            for (let R = 0; R < m.height; R += 50) {
                                                let L = _.getImageData,
                                                    B = tQ in L ? L[tQ] : L,
                                                    F = new Uint32Array(B.call(_, C, R, Math.min(50, m.width - C), Math.min(50, m.height - R)).data.buffer);
                                                if (F.some(m => 0 !== m)) return !1
                                            }
                                        return !0
                                    }(m) && (ep.rr_dataURL = m.toDataURL(X.type, X.quality));
                                    else if (!("__context" in m)) {
                                        let _ = m.toDataURL(X.type, X.quality),
                                            C = R.createElement("canvas");
                                        C.width = m.width, C.height = m.height;
                                        let L = C.toDataURL(X.type, X.quality);
                                        _ !== L && (ep.rr_dataURL = _)
                                    }
                                }
                                if ("img" === ed && K) {
                                    er || (en = (er = R.createElement("canvas")).getContext("2d"));
                                    let _ = m.currentSrc || m.getAttribute("src") || "<unknown-src>",
                                        C = m.crossOrigin,
                                        recordInlineImage = () => {
                                            m.removeEventListener("load", recordInlineImage);
                                            try {
                                                er.width = m.naturalWidth, er.height = m.naturalHeight, en.drawImage(m, 0, 0), ep.rr_dataURL = er.toDataURL(X.type, X.quality)
                                            } catch (C) {
                                                if ("anonymous" !== m.crossOrigin) {
                                                    m.crossOrigin = "anonymous", m.complete && 0 !== m.naturalWidth ? recordInlineImage() : m.addEventListener("load", recordInlineImage);
                                                    return
                                                }
                                                console.warn(`Cannot inline img src=${_}! Error: ${C}`)
                                            }
                                            "anonymous" === m.crossOrigin && (C ? ep.crossOrigin = C : m.removeAttribute("crossorigin"))
                                        };
                                    m.complete && 0 !== m.naturalWidth ? recordInlineImage() : m.addEventListener("load", recordInlineImage)
                                }
                                if (("audio" === ed || "video" === ed) && (ep.rr_mediaState = m.paused ? "paused" : "played", ep.rr_mediaCurrentTime = m.currentTime), !et && (m.scrollLeft && (ep.rr_scrollLeft = m.scrollLeft), m.scrollTop && (ep.rr_scrollTop = m.scrollTop)), eu) {
                                    let {
                                        width: _,
                                        height: C
                                    } = m.getBoundingClientRect();
                                    ep = {
                                        class: ep.class,
                                        rr_width: `${_}px`,
                                        rr_height: `${C}px`
                                    }
                                }
                                "iframe" !== ed || Q(ep.src) || (eu || m.contentDocument || (ep.rr_src = ep.src), delete ep.src);
                                try {
                                    customElements.get(ed) && (C = !0)
                                } catch (m) {}
                                return {
                                    type: em.Element,
                                    tagName: ed,
                                    attributes: ep,
                                    childNodes: [],
                                    isSVG: !!("svg" === m.tagName || m.ownerSVGElement) || void 0,
                                    needBlock: eu,
                                    rootId: ei,
                                    isCustom: C
                                }
                            }(m, {
                                doc: C,
                                blockClass: L,
                                blockSelector: B,
                                unblockSelector: F,
                                inlineStylesheet: Y,
                                maskAttributeFn: H,
                                maskInputOptions: Q,
                                maskInputFn: ei,
                                dataURLOptions: eo,
                                inlineImages: ea,
                                recordCanvas: es,
                                keepIframeSrcFn: ec,
                                newlyAddedElement: el,
                                rootId: eu,
                                maskAllText: U,
                                maskTextClass: q,
                                unmaskTextClass: V,
                                maskTextSelector: X,
                                unmaskTextSelector: K
                            });
                        case m.TEXT_NODE:
                            return function(m, _) {
                                let {
                                    maskAllText: C,
                                    maskTextClass: R,
                                    unmaskTextClass: L,
                                    maskTextSelector: B,
                                    unmaskTextSelector: F,
                                    maskTextFn: U,
                                    maskInputOptions: H,
                                    maskInputFn: q,
                                    rootId: V
                                } = _, X = m.parentNode && m.parentNode.tagName, K = m.textContent, Y = "STYLE" === X || void 0, Q = "SCRIPT" === X || void 0, et = "TEXTAREA" === X || void 0;
                                if (Y && K) {
                                    try {
                                        m.nextSibling || m.previousSibling || _optionalChain$5([m, "access", m => m.parentNode, "access", m => m.sheet, "optionalAccess", m => m.cssRules]) && (K = stringifyStylesheet(m.parentNode.sheet))
                                    } catch (_) {
                                        console.warn(`Cannot get CSS styles from text's parentNode. Error: ${_}`, m)
                                    }
                                    K = absoluteToStylesheet(K, getHref(_.doc))
                                }
                                Q && (K = "SCRIPT_PLACEHOLDER");
                                let er = needMaskingText(m, R, B, L, F, C);
                                if (Y || Q || et || !K || !er || (K = U ? U(K, m.parentElement) : K.replace(/[\S]/g, "*")), et && K && (H.textarea || er) && (K = q ? q(K, m.parentNode) : K.replace(/[\S]/g, "*")), "OPTION" === X && K) {
                                    let _ = shouldMaskInput({
                                        type: null,
                                        tagName: X,
                                        maskInputOptions: H
                                    });
                                    K = maskInputValue({
                                        isMasked: needMaskingText(m, R, B, L, F, _),
                                        element: m,
                                        value: K,
                                        maskInputFn: q
                                    })
                                }
                                return {
                                    type: em.Text,
                                    textContent: K || "",
                                    isStyle: Y,
                                    rootId: V
                                }
                            }(m, {
                                doc: C,
                                maskAllText: U,
                                maskTextClass: q,
                                unmaskTextClass: V,
                                maskTextSelector: X,
                                unmaskTextSelector: K,
                                maskTextFn: et,
                                maskInputOptions: Q,
                                maskInputFn: ei,
                                rootId: eu
                            });
                        case m.CDATA_SECTION_NODE:
                            return {
                                type: em.CDATA,
                                textContent: "",
                                rootId: eu
                            };
                        case m.COMMENT_NODE:
                            return {
                                type: em.Comment,
                                textContent: m.textContent || "",
                                rootId: eu
                            };
                        default:
                            return !1
                    }
                }(m, {
                    doc: R,
                    mirror: L,
                    blockClass: B,
                    blockSelector: F,
                    maskAllText: H,
                    unblockSelector: U,
                    maskTextClass: q,
                    unmaskTextClass: V,
                    maskTextSelector: X,
                    unmaskTextSelector: K,
                    inlineStylesheet: Q,
                    maskInputOptions: et,
                    maskAttributeFn: ei,
                    maskTextFn: eo,
                    maskInputFn: ea,
                    dataURLOptions: ec,
                    inlineImages: el,
                    recordCanvas: eu,
                    keepIframeSrcFn: ey,
                    newlyAddedElement: e_
                });
                if (!eb) return console.warn(m, "not serialized"), null;
                C = L.hasNode(m) ? L.getId(m) : ! function(m, _) {
                    if (_.comment && m.type === em.Comment) return !0;
                    if (m.type === em.Element) {
                        if (_.script && ("script" === m.tagName || "link" === m.tagName && ("preload" === m.attributes.rel || "modulepreload" === m.attributes.rel) && "script" === m.attributes.as || "link" === m.tagName && "prefetch" === m.attributes.rel && "string" == typeof m.attributes.href && "js" === extractFileExtension(m.attributes.href)) || _.headFavicon && ("link" === m.tagName && "shortcut icon" === m.attributes.rel || "meta" === m.tagName && (lowerIfExists(m.attributes.name).match(/^msapplication-tile(image|color)$/) || "application-name" === lowerIfExists(m.attributes.name) || "icon" === lowerIfExists(m.attributes.rel) || "apple-touch-icon" === lowerIfExists(m.attributes.rel) || "shortcut icon" === lowerIfExists(m.attributes.rel)))) return !0;
                        if ("meta" === m.tagName) {
                            if (_.headMetaDescKeywords && lowerIfExists(m.attributes.name).match(/^description|keywords$/) || _.headMetaSocial && (lowerIfExists(m.attributes.property).match(/^(og|twitter|fb):/) || lowerIfExists(m.attributes.name).match(/^(og|twitter):/) || "pinterest" === lowerIfExists(m.attributes.name))) return !0;
                            if (_.headMetaRobots && ("robots" === lowerIfExists(m.attributes.name) || "googlebot" === lowerIfExists(m.attributes.name) || "bingbot" === lowerIfExists(m.attributes.name))) return !0;
                            if (_.headMetaHttpEquiv && void 0 !== m.attributes["http-equiv"]) return !0;
                            else if (_.headMetaAuthorship && ("author" === lowerIfExists(m.attributes.name) || "generator" === lowerIfExists(m.attributes.name) || "framework" === lowerIfExists(m.attributes.name) || "publisher" === lowerIfExists(m.attributes.name) || "progid" === lowerIfExists(m.attributes.name) || lowerIfExists(m.attributes.property).match(/^article:/) || lowerIfExists(m.attributes.property).match(/^product:/))) return !0;
                            else if (_.headMetaVerification && ("google-site-verification" === lowerIfExists(m.attributes.name) || "yandex-verification" === lowerIfExists(m.attributes.name) || "csrf-token" === lowerIfExists(m.attributes.name) || "p:domain_verify" === lowerIfExists(m.attributes.name) || "verify-v1" === lowerIfExists(m.attributes.name) || "verification" === lowerIfExists(m.attributes.name) || "shopify-checkout-api-token" === lowerIfExists(m.attributes.name))) return !0
                        }
                    }
                    return !1
                }(eb, es) && (ev || eb.type !== em.Text || eb.isStyle || eb.textContent.replace(/^\s+|\s+$/gm, "").length) ? genId() : -2;
                let eS = Object.assign(eb, {
                    id: C
                });
                if (L.add(m, eS), -2 === C) return null;
                ed && ed(m);
                let ew = !Y;
                if (eS.type === em.Element) {
                    ew = ew && !eS.needBlock, delete eS.needBlock;
                    let _ = m.shadowRoot;
                    _ && isNativeShadowDom(_) && (eS.isShadowHost = !0)
                }
                if ((eS.type === em.Document || eS.type === em.Element) && ew) {
                    es.headWhitespace && eS.type === em.Element && "head" === eS.tagName && (ev = !1);
                    let _ = {
                        doc: R,
                        mirror: L,
                        blockClass: B,
                        blockSelector: F,
                        maskAllText: H,
                        unblockSelector: U,
                        maskTextClass: q,
                        unmaskTextClass: V,
                        maskTextSelector: X,
                        unmaskTextSelector: K,
                        skipChild: Y,
                        inlineStylesheet: Q,
                        maskInputOptions: et,
                        maskAttributeFn: ei,
                        maskTextFn: eo,
                        maskInputFn: ea,
                        slimDOMOptions: es,
                        dataURLOptions: ec,
                        inlineImages: el,
                        recordCanvas: eu,
                        preserveWhiteSpace: ev,
                        onSerialize: ed,
                        onIframeLoad: ep,
                        iframeLoadTimeout: eh,
                        onStylesheetLoad: ef,
                        stylesheetLoadTimeout: eg,
                        keepIframeSrcFn: ey
                    };
                    for (let C of Array.from(m.childNodes)) {
                        let m = serializeNodeWithId(C, _);
                        m && eS.childNodes.push(m)
                    }
                    if (m.nodeType === m.ELEMENT_NODE && m.shadowRoot)
                        for (let C of Array.from(m.shadowRoot.childNodes)) {
                            let R = serializeNodeWithId(C, _);
                            R && (isNativeShadowDom(m.shadowRoot) && (R.isShadow = !0), eS.childNodes.push(R))
                        }
                }
                return m.parentNode && isShadowRoot(m.parentNode) && isNativeShadowDom(m.parentNode) && (eS.isShadow = !0), eS.type === em.Element && "iframe" === eS.tagName && function(m, _, C) {
                    let R;
                    let L = m.contentWindow;
                    if (!L) return;
                    let B = !1;
                    try {
                        R = L.document.readyState
                    } catch (m) {
                        return
                    }
                    if ("complete" !== R) {
                        let R = setTimeout$2(() => {
                            B || (_(), B = !0)
                        }, C);
                        m.addEventListener("load", () => {
                            clearTimeout$2(R), B = !0, _()
                        });
                        return
                    }
                    let F = "about:blank";
                    if (L.location.href !== F || m.src === F || "" === m.src) return setTimeout$2(_, 0), m.addEventListener("load", _);
                    m.addEventListener("load", _)
                }(m, () => {
                    let _ = m.contentDocument;
                    if (_ && ep) {
                        let C = serializeNodeWithId(_, {
                            doc: _,
                            mirror: L,
                            blockClass: B,
                            blockSelector: F,
                            unblockSelector: U,
                            maskAllText: H,
                            maskTextClass: q,
                            unmaskTextClass: V,
                            maskTextSelector: X,
                            unmaskTextSelector: K,
                            skipChild: !1,
                            inlineStylesheet: Q,
                            maskInputOptions: et,
                            maskAttributeFn: ei,
                            maskTextFn: eo,
                            maskInputFn: ea,
                            slimDOMOptions: es,
                            dataURLOptions: ec,
                            inlineImages: el,
                            recordCanvas: eu,
                            preserveWhiteSpace: ev,
                            onSerialize: ed,
                            onIframeLoad: ep,
                            iframeLoadTimeout: eh,
                            onStylesheetLoad: ef,
                            stylesheetLoadTimeout: eg,
                            keepIframeSrcFn: ey
                        });
                        C && ep(m, C)
                    }
                }, eh), eS.type === em.Element && "link" === eS.tagName && "string" == typeof eS.attributes.rel && ("stylesheet" === eS.attributes.rel || "preload" === eS.attributes.rel && "string" == typeof eS.attributes.href && "css" === extractFileExtension(eS.attributes.href)) && function(m, _, C) {
                    let R, L = !1;
                    try {
                        R = m.sheet
                    } catch (m) {
                        return
                    }
                    if (R) return;
                    let B = setTimeout$2(() => {
                        L || (_(), L = !0)
                    }, C);
                    m.addEventListener("load", () => {
                        clearTimeout$2(B), L = !0, _()
                    })
                }(m, () => {
                    if (ef) {
                        let _ = serializeNodeWithId(m, {
                            doc: R,
                            mirror: L,
                            blockClass: B,
                            blockSelector: F,
                            unblockSelector: U,
                            maskAllText: H,
                            maskTextClass: q,
                            unmaskTextClass: V,
                            maskTextSelector: X,
                            unmaskTextSelector: K,
                            skipChild: !1,
                            inlineStylesheet: Q,
                            maskInputOptions: et,
                            maskAttributeFn: ei,
                            maskTextFn: eo,
                            maskInputFn: ea,
                            slimDOMOptions: es,
                            dataURLOptions: ec,
                            inlineImages: el,
                            recordCanvas: eu,
                            preserveWhiteSpace: ev,
                            onSerialize: ed,
                            onIframeLoad: ep,
                            iframeLoadTimeout: eh,
                            onStylesheetLoad: ef,
                            stylesheetLoadTimeout: eg,
                            keepIframeSrcFn: ey
                        });
                        _ && ef(m, _)
                    }
                }, eg), eS
            }

            function _optionalChain$4(m) {
                let _;
                let C = m[0],
                    R = 1;
                for (; R < m.length;) {
                    let L = m[R],
                        B = m[R + 1];
                    if (R += 2, ("optionalAccess" === L || "optionalCall" === L) && null == C) return;
                    "access" === L || "optionalAccess" === L ? (_ = C, C = B(C)) : ("call" === L || "optionalCall" === L) && (C = B((...m) => C.call(_, ...m)), _ = void 0)
                }
                return C
            }

            function on(m, _, C = document) {
                let R = {
                    capture: !0,
                    passive: !0
                };
                return C.addEventListener(m, _, R), () => C.removeEventListener(m, _, R)
            }
            let re = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording.",
                rt = {
                    map: {},
                    getId: () => (console.error(re), -1),
                    getNode: () => (console.error(re), null),
                    removeNodeFromMap() {
                        console.error(re)
                    },
                    has: () => (console.error(re), !1),
                    reset() {
                        console.error(re)
                    }
                };

            function throttle$1(m, _, C = {}) {
                let R = null,
                    L = 0;
                return function(...B) {
                    let F = Date.now();
                    L || !1 !== C.leading || (L = F);
                    let U = _ - (F - L),
                        H = this;
                    U <= 0 || U > _ ? (R && (function(...m) {
                        getImplementation("clearTimeout")(...m)
                    }(R), R = null), L = F, m.apply(H, B)) : R || !1 === C.trailing || (R = setTimeout$1(() => {
                        L = !1 === C.leading ? 0 : Date.now(), R = null, m.apply(H, B)
                    }, U))
                }
            }

            function patch(m, _, C) {
                try {
                    if (!(_ in m)) return () => {};
                    let R = m[_],
                        L = C(R);
                    return "function" == typeof L && (L.prototype = L.prototype || {}, Object.defineProperties(L, {
                        __rrweb_original__: {
                            enumerable: !1,
                            value: R
                        }
                    })), m[_] = L, () => {
                        m[_] = R
                    }
                } catch (m) {
                    return () => {}
                }
            }
            "undefined" != typeof window && window.Proxy && window.Reflect && (rt = new Proxy(rt, {
                get: (m, _, C) => ("map" === _ && console.error(re), Reflect.get(m, _, C))
            }));
            let rr = Date.now;

            function getWindowScroll(m) {
                let _ = m.document;
                return {
                    left: _.scrollingElement ? _.scrollingElement.scrollLeft : void 0 !== m.pageXOffset ? m.pageXOffset : _optionalChain$4([_, "optionalAccess", m => m.documentElement, "access", m => m.scrollLeft]) || _optionalChain$4([_, "optionalAccess", m => m.body, "optionalAccess", m => m.parentElement, "optionalAccess", m => m.scrollLeft]) || _optionalChain$4([_, "optionalAccess", m => m.body, "optionalAccess", m => m.scrollLeft]) || 0,
                    top: _.scrollingElement ? _.scrollingElement.scrollTop : void 0 !== m.pageYOffset ? m.pageYOffset : _optionalChain$4([_, "optionalAccess", m => m.documentElement, "access", m => m.scrollTop]) || _optionalChain$4([_, "optionalAccess", m => m.body, "optionalAccess", m => m.parentElement, "optionalAccess", m => m.scrollTop]) || _optionalChain$4([_, "optionalAccess", m => m.body, "optionalAccess", m => m.scrollTop]) || 0
                }
            }

            function getWindowHeight() {
                return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight
            }

            function getWindowWidth() {
                return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth
            }

            function closestElementOfNode(m) {
                if (!m) return null;
                let _ = m.nodeType === m.ELEMENT_NODE ? m : m.parentElement;
                return _
            }

            function isBlocked(m, _, C, R, L) {
                if (!m) return !1;
                let B = closestElementOfNode(m);
                if (!B) return !1;
                let F = createMatchPredicate(_, C);
                if (!L) {
                    let m = R && B.matches(R);
                    return F(B) && !m
                }
                let U = distanceToMatch(B, F),
                    H = -1;
                return !(U < 0) && (R && (H = distanceToMatch(B, createMatchPredicate(null, R))), U > -1 && H < 0 || U < H)
            }

            function isIgnored(m, _) {
                return -2 === _.getId(m)
            }

            function legacy_isTouchEvent(m) {
                return !!m.changedTouches
            }

            function isSerializedIframe(m, _) {
                return !!("IFRAME" === m.nodeName && _.getMeta(m))
            }

            function isSerializedStylesheet(m, _) {
                return !!("LINK" === m.nodeName && m.nodeType === m.ELEMENT_NODE && m.getAttribute && "stylesheet" === m.getAttribute("rel") && _.getMeta(m))
            }

            function hasShadowRoot(m) {
                return !!_optionalChain$4([m, "optionalAccess", m => m.shadowRoot])
            }
            /[1-9][0-9]{12}/.test(Date.now().toString()) || (rr = () => new Date().getTime());
            let StyleSheetMirror = class StyleSheetMirror {
                constructor() {
                    this.id = 1, this.styleIDMap = new WeakMap, this.idStyleMap = new Map
                }
                getId(m) {
                    var _;
                    return _ = this.styleIDMap.get(m), null != _ ? _ : -1
                }
                has(m) {
                    return this.styleIDMap.has(m)
                }
                add(m, _) {
                    let C;
                    return this.has(m) ? this.getId(m) : (C = void 0 === _ ? this.id++ : _, this.styleIDMap.set(m, C), this.idStyleMap.set(C, m), C)
                }
                getStyle(m) {
                    return this.idStyleMap.get(m) || null
                }
                reset() {
                    this.styleIDMap = new WeakMap, this.idStyleMap = new Map, this.id = 1
                }
                generateId() {
                    return this.id++
                }
            };

            function getShadowHost(m) {
                let _ = null;
                return _optionalChain$4([m, "access", m => m.getRootNode, "optionalCall", m => m(), "optionalAccess", m => m.nodeType]) === Node.DOCUMENT_FRAGMENT_NODE && m.getRootNode().host && (_ = m.getRootNode().host), _
            }

            function inDom(m) {
                let _ = m.ownerDocument;
                return !!_ && (_.contains(m) || function(m) {
                    let _ = m.ownerDocument;
                    if (!_) return !1;
                    let C = function(m) {
                        let _, C = m;
                        for (; _ = getShadowHost(C);) C = _;
                        return C
                    }(m);
                    return _.contains(C)
                }(m))
            }
            let rn = {};

            function getImplementation(m) {
                let _ = rn[m];
                if (_) return _;
                let C = window.document,
                    R = window[m];
                if (C && "function" == typeof C.createElement) try {
                    let _ = C.createElement("iframe");
                    _.hidden = !0, C.head.appendChild(_);
                    let L = _.contentWindow;
                    L && L[m] && (R = L[m]), C.head.removeChild(_)
                } catch (m) {}
                return rn[m] = R.bind(window)
            }

            function setTimeout$1(...m) {
                return getImplementation("setTimeout")(...m)
            }
            var ri = ((el = ri || {})[el.DomContentLoaded = 0] = "DomContentLoaded", el[el.Load = 1] = "Load", el[el.FullSnapshot = 2] = "FullSnapshot", el[el.IncrementalSnapshot = 3] = "IncrementalSnapshot", el[el.Meta = 4] = "Meta", el[el.Custom = 5] = "Custom", el[el.Plugin = 6] = "Plugin", el),
                ro = ((eu = ro || {})[eu.Mutation = 0] = "Mutation", eu[eu.MouseMove = 1] = "MouseMove", eu[eu.MouseInteraction = 2] = "MouseInteraction", eu[eu.Scroll = 3] = "Scroll", eu[eu.ViewportResize = 4] = "ViewportResize", eu[eu.Input = 5] = "Input", eu[eu.TouchMove = 6] = "TouchMove", eu[eu.MediaInteraction = 7] = "MediaInteraction", eu[eu.StyleSheetRule = 8] = "StyleSheetRule", eu[eu.CanvasMutation = 9] = "CanvasMutation", eu[eu.Font = 10] = "Font", eu[eu.Log = 11] = "Log", eu[eu.Drag = 12] = "Drag", eu[eu.StyleDeclaration = 13] = "StyleDeclaration", eu[eu.Selection = 14] = "Selection", eu[eu.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", eu[eu.CustomElement = 16] = "CustomElement", eu),
                ra = ((ed = ra || {})[ed.MouseUp = 0] = "MouseUp", ed[ed.MouseDown = 1] = "MouseDown", ed[ed.Click = 2] = "Click", ed[ed.ContextMenu = 3] = "ContextMenu", ed[ed.DblClick = 4] = "DblClick", ed[ed.Focus = 5] = "Focus", ed[ed.Blur = 6] = "Blur", ed[ed.TouchStart = 7] = "TouchStart", ed[ed.TouchMove_Departed = 8] = "TouchMove_Departed", ed[ed.TouchEnd = 9] = "TouchEnd", ed[ed.TouchCancel = 10] = "TouchCancel", ed),
                rs = ((ep = rs || {})[ep.Mouse = 0] = "Mouse", ep[ep.Pen = 1] = "Pen", ep[ep.Touch = 2] = "Touch", ep);
            let DoubleLinkedList = class DoubleLinkedList {
                constructor() {
                    this.length = 0, this.head = null, this.tail = null
                }
                get(m) {
                    if (m >= this.length) throw Error("Position outside of list range");
                    let _ = this.head;
                    for (let C = 0; C < m; C++) _ = function(m) {
                        let _;
                        let C = m[0],
                            R = 1;
                        for (; R < m.length;) {
                            let L = m[R],
                                B = m[R + 1];
                            if (R += 2, ("optionalAccess" === L || "optionalCall" === L) && null == C) return;
                            "access" === L || "optionalAccess" === L ? (_ = C, C = B(C)) : ("call" === L || "optionalCall" === L) && (C = B((...m) => C.call(_, ...m)), _ = void 0)
                        }
                        return C
                    }([_, "optionalAccess", m => m.next]) || null;
                    return _
                }
                addNode(m) {
                    let _ = {
                        value: m,
                        previous: null,
                        next: null
                    };
                    if (m.__ln = _, m.previousSibling && "__ln" in m.previousSibling) {
                        let C = m.previousSibling.__ln.next;
                        _.next = C, _.previous = m.previousSibling.__ln, m.previousSibling.__ln.next = _, C && (C.previous = _)
                    } else if (m.nextSibling && "__ln" in m.nextSibling && m.nextSibling.__ln.previous) {
                        let C = m.nextSibling.__ln.previous;
                        _.previous = C, _.next = m.nextSibling.__ln, m.nextSibling.__ln.previous = _, C && (C.next = _)
                    } else this.head && (this.head.previous = _), _.next = this.head, this.head = _;
                    null === _.next && (this.tail = _), this.length++
                }
                removeNode(m) {
                    let _ = m.__ln;
                    this.head && (_.previous ? (_.previous.next = _.next, _.next ? _.next.previous = _.previous : this.tail = _.previous) : (this.head = _.next, this.head ? this.head.previous = null : this.tail = null), m.__ln && delete m.__ln, this.length--)
                }
            };
            let moveKey = (m, _) => `${m}@${_}`;
            let MutationBuffer = class MutationBuffer {
                constructor() {
                    this.frozen = !1, this.locked = !1, this.texts = [], this.attributes = [], this.attributeMap = new WeakMap, this.removes = [], this.mapRemoves = [], this.movedMap = {}, this.addedSet = new Set, this.movedSet = new Set, this.droppedSet = new Set, this.processMutations = m => {
                        m.forEach(this.processMutation), this.emit()
                    }, this.emit = () => {
                        if (this.frozen || this.locked) return;
                        let m = [],
                            _ = new Set,
                            C = new DoubleLinkedList,
                            getNextId = m => {
                                let _ = m,
                                    C = -2;
                                for (; - 2 === C;) C = (_ = _ && _.nextSibling) && this.mirror.getId(_);
                                return C
                            },
                            pushAdd = R => {
                                if (!R.parentNode || !inDom(R)) return;
                                let L = isShadowRoot(R.parentNode) ? this.mirror.getId(getShadowHost(R)) : this.mirror.getId(R.parentNode),
                                    B = getNextId(R);
                                if (-1 === L || -1 === B) return C.addNode(R);
                                let F = serializeNodeWithId(R, {
                                    doc: this.doc,
                                    mirror: this.mirror,
                                    blockClass: this.blockClass,
                                    blockSelector: this.blockSelector,
                                    maskAllText: this.maskAllText,
                                    unblockSelector: this.unblockSelector,
                                    maskTextClass: this.maskTextClass,
                                    unmaskTextClass: this.unmaskTextClass,
                                    maskTextSelector: this.maskTextSelector,
                                    unmaskTextSelector: this.unmaskTextSelector,
                                    skipChild: !0,
                                    newlyAddedElement: !0,
                                    inlineStylesheet: this.inlineStylesheet,
                                    maskInputOptions: this.maskInputOptions,
                                    maskAttributeFn: this.maskAttributeFn,
                                    maskTextFn: this.maskTextFn,
                                    maskInputFn: this.maskInputFn,
                                    slimDOMOptions: this.slimDOMOptions,
                                    dataURLOptions: this.dataURLOptions,
                                    recordCanvas: this.recordCanvas,
                                    inlineImages: this.inlineImages,
                                    onSerialize: m => {
                                        isSerializedIframe(m, this.mirror) && !isBlocked(m, this.blockClass, this.blockSelector, this.unblockSelector, !1) && this.iframeManager.addIframe(m), isSerializedStylesheet(m, this.mirror) && this.stylesheetManager.trackLinkElement(m), hasShadowRoot(R) && this.shadowDomManager.addShadowRoot(R.shadowRoot, this.doc)
                                    },
                                    onIframeLoad: (m, _) => {
                                        isBlocked(m, this.blockClass, this.blockSelector, this.unblockSelector, !1) || (this.iframeManager.attachIframe(m, _), m.contentWindow && this.canvasManager.addWindow(m.contentWindow), this.shadowDomManager.observeAttachShadow(m))
                                    },
                                    onStylesheetLoad: (m, _) => {
                                        this.stylesheetManager.attachLinkElement(m, _)
                                    }
                                });
                                F && (m.push({
                                    parentId: L,
                                    nextId: B,
                                    node: F
                                }), _.add(F.id))
                            };
                        for (; this.mapRemoves.length;) this.mirror.removeNodeFromMap(this.mapRemoves.shift());
                        for (let m of this.movedSet)(!isParentRemoved(this.removes, m, this.mirror) || this.movedSet.has(m.parentNode)) && pushAdd(m);
                        for (let m of this.addedSet) isAncestorInSet(this.droppedSet, m) || isParentRemoved(this.removes, m, this.mirror) ? isAncestorInSet(this.movedSet, m) ? pushAdd(m) : this.droppedSet.add(m) : pushAdd(m);
                        let R = null;
                        for (; C.length;) {
                            let m = null;
                            if (R) {
                                let _ = this.mirror.getId(R.value.parentNode),
                                    C = getNextId(R.value); - 1 !== _ && -1 !== C && (m = R)
                            }
                            if (!m) {
                                let _ = C.tail;
                                for (; _;) {
                                    let C = _;
                                    if (_ = _.previous, C) {
                                        let _ = this.mirror.getId(C.value.parentNode),
                                            R = getNextId(C.value);
                                        if (-1 === R) continue;
                                        if (-1 !== _) {
                                            m = C;
                                            break
                                        } {
                                            let _ = C.value;
                                            if (_.parentNode && _.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                                                let R = _.parentNode.host,
                                                    L = this.mirror.getId(R);
                                                if (-1 !== L) {
                                                    m = C;
                                                    break
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (!m) {
                                for (; C.head;) C.removeNode(C.head.value);
                                break
                            }
                            R = m.previous, C.removeNode(m.value), pushAdd(m.value)
                        }
                        let L = {
                            texts: this.texts.map(m => ({
                                id: this.mirror.getId(m.node),
                                value: m.value
                            })).filter(m => !_.has(m.id)).filter(m => this.mirror.has(m.id)),
                            attributes: this.attributes.map(m => {
                                let {
                                    attributes: _
                                } = m;
                                if ("string" == typeof _.style) {
                                    let C = JSON.stringify(m.styleDiff),
                                        R = JSON.stringify(m._unchangedStyles);
                                    C.length < _.style.length && (C + R).split("var(").length === _.style.split("var(").length && (_.style = m.styleDiff)
                                }
                                return {
                                    id: this.mirror.getId(m.node),
                                    attributes: _
                                }
                            }).filter(m => !_.has(m.id)).filter(m => this.mirror.has(m.id)),
                            removes: this.removes,
                            adds: m
                        };
                        (L.texts.length || L.attributes.length || L.removes.length || L.adds.length) && (this.texts = [], this.attributes = [], this.attributeMap = new WeakMap, this.removes = [], this.addedSet = new Set, this.movedSet = new Set, this.droppedSet = new Set, this.movedMap = {}, this.mutationCb(L))
                    }, this.processMutation = m => {
                        if (!isIgnored(m.target, this.mirror)) switch (m.type) {
                            case "characterData":
                                {
                                    let _ = m.target.textContent;isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || _ === m.oldValue || this.texts.push({
                                        value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, this.maskAllText) && _ ? this.maskTextFn ? this.maskTextFn(_, closestElementOfNode(m.target)) : _.replace(/[\S]/g, "*") : _,
                                        node: m.target
                                    });
                                    break
                                }
                            case "attributes":
                                {
                                    let _ = m.target,
                                        C = m.attributeName,
                                        R = m.target.getAttribute(C);
                                    if ("value" === C) {
                                        let C = getInputType(_),
                                            L = _.tagName;
                                        R = getInputValue(_, L, C);
                                        let B = shouldMaskInput({
                                                maskInputOptions: this.maskInputOptions,
                                                tagName: L,
                                                type: C
                                            }),
                                            F = needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, B);
                                        R = maskInputValue({
                                            isMasked: F,
                                            element: _,
                                            value: R,
                                            maskInputFn: this.maskInputFn
                                        })
                                    }
                                    if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || R === m.oldValue) return;
                                    let L = this.attributeMap.get(m.target);
                                    if ("IFRAME" === _.tagName && "src" === C && !this.keepIframeSrcFn(R)) {
                                        if (_.contentDocument) return;
                                        C = "rr_src"
                                    }
                                    if (L || (L = {
                                            node: m.target,
                                            attributes: {},
                                            styleDiff: {},
                                            _unchangedStyles: {}
                                        }, this.attributes.push(L), this.attributeMap.set(m.target, L)), "type" === C && "INPUT" === _.tagName && "password" === (m.oldValue || "").toLowerCase() && _.setAttribute("data-rr-is-password", "true"), !ignoreAttribute(_.tagName, C) && (L.attributes[C] = transformAttribute(this.doc, toLowerCase(_.tagName), toLowerCase(C), R, _, this.maskAttributeFn), "style" === C)) {
                                        if (!this.unattachedDoc) try {
                                            this.unattachedDoc = document.implementation.createHTMLDocument()
                                        } catch (m) {
                                            this.unattachedDoc = this.doc
                                        }
                                        let C = this.unattachedDoc.createElement("span");
                                        for (let R of (m.oldValue && C.setAttribute("style", m.oldValue), Array.from(_.style))) {
                                            let m = _.style.getPropertyValue(R),
                                                B = _.style.getPropertyPriority(R);
                                            m !== C.style.getPropertyValue(R) || B !== C.style.getPropertyPriority(R) ? "" === B ? L.styleDiff[R] = m : L.styleDiff[R] = [m, B] : L._unchangedStyles[R] = [m, B]
                                        }
                                        for (let m of Array.from(C.style)) "" === _.style.getPropertyValue(m) && (L.styleDiff[m] = !1)
                                    }
                                    break
                                }
                            case "childList":
                                if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, !0)) return;
                                m.addedNodes.forEach(_ => this.genAdds(_, m.target)), m.removedNodes.forEach(_ => {
                                    let C = this.mirror.getId(_),
                                        R = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);
                                    isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || isIgnored(_, this.mirror) || -1 === this.mirror.getId(_) || (this.addedSet.has(_) ? (deepDelete(this.addedSet, _), this.droppedSet.add(_)) : this.addedSet.has(m.target) && -1 === C || function isAncestorRemoved(m, _) {
                                        if (isShadowRoot(m)) return !1;
                                        let C = _.getId(m);
                                        return !_.has(C) || (!m.parentNode || m.parentNode.nodeType !== m.DOCUMENT_NODE) && (!m.parentNode || isAncestorRemoved(m.parentNode, _))
                                    }(m.target, this.mirror) || (this.movedSet.has(_) && this.movedMap[moveKey(C, R)] ? deepDelete(this.movedSet, _) : this.removes.push({
                                        parentId: R,
                                        id: C,
                                        isShadow: !!(isShadowRoot(m.target) && isNativeShadowDom(m.target)) || void 0
                                    })), this.mapRemoves.push(_))
                                })
                        }
                    }, this.genAdds = (m, _) => {
                        if (!this.processedNodeManager.inOtherBuffer(m, this) && !(this.addedSet.has(m) || this.movedSet.has(m))) {
                            if (this.mirror.hasNode(m)) {
                                if (isIgnored(m, this.mirror)) return;
                                this.movedSet.add(m);
                                let C = null;
                                _ && this.mirror.hasNode(_) && (C = this.mirror.getId(_)), C && -1 !== C && (this.movedMap[moveKey(this.mirror.getId(m), C)] = !0)
                            } else this.addedSet.add(m), this.droppedSet.delete(m);
                            !isBlocked(m, this.blockClass, this.blockSelector, this.unblockSelector, !1) && (m.childNodes.forEach(m => this.genAdds(m)), hasShadowRoot(m) && m.shadowRoot.childNodes.forEach(_ => {
                                this.processedNodeManager.add(_, this), this.genAdds(_, m)
                            }))
                        }
                    }
                }
                init(m) {
                    ["mutationCb", "blockClass", "blockSelector", "unblockSelector", "maskAllText", "maskTextClass", "unmaskTextClass", "maskTextSelector", "unmaskTextSelector", "inlineStylesheet", "maskInputOptions", "maskAttributeFn", "maskTextFn", "maskInputFn", "keepIframeSrcFn", "recordCanvas", "inlineImages", "slimDOMOptions", "dataURLOptions", "doc", "mirror", "iframeManager", "stylesheetManager", "shadowDomManager", "canvasManager", "processedNodeManager"].forEach(_ => {
                        this[_] = m[_]
                    })
                }
                freeze() {
                    this.frozen = !0, this.canvasManager.freeze()
                }
                unfreeze() {
                    this.frozen = !1, this.canvasManager.unfreeze(), this.emit()
                }
                isFrozen() {
                    return this.frozen
                }
                lock() {
                    this.locked = !0, this.canvasManager.lock()
                }
                unlock() {
                    this.locked = !1, this.canvasManager.unlock(), this.emit()
                }
                reset() {
                    this.shadowDomManager.reset(), this.canvasManager.reset()
                }
            };

            function deepDelete(m, _) {
                m.delete(_), _.childNodes.forEach(_ => deepDelete(m, _))
            }

            function isParentRemoved(m, _, C) {
                return 0 !== m.length && function(m, _, C) {
                    let R = _.parentNode;
                    for (; R;) {
                        let _ = C.getId(R);
                        if (m.some(m => m.id === _)) return !0;
                        R = R.parentNode
                    }
                    return !1
                }(m, _, C)
            }

            function isAncestorInSet(m, _) {
                return 0 !== m.size && function _isAncestorInSet(m, _) {
                    let {
                        parentNode: C
                    } = _;
                    return !!C && (!!m.has(C) || _isAncestorInSet(m, C))
                }(m, _)
            }
            let callbackWrapper = m => ei ? (..._) => {
                try {
                    return m(..._)
                } catch (m) {
                    if (ei && !0 === ei(m)) return () => {};
                    throw m
                }
            } : m;

            function _optionalChain$2(m) {
                let _;
                let C = m[0],
                    R = 1;
                for (; R < m.length;) {
                    let L = m[R],
                        B = m[R + 1];
                    if (R += 2, ("optionalAccess" === L || "optionalCall" === L) && null == C) return;
                    "access" === L || "optionalAccess" === L ? (_ = C, C = B(C)) : ("call" === L || "optionalCall" === L) && (C = B((...m) => C.call(_, ...m)), _ = void 0)
                }
                return C
            }
            let rc = [];

            function esm_getEventTarget(m) {
                try {
                    if ("composedPath" in m) {
                        let _ = m.composedPath();
                        if (_.length) return _[0]
                    } else if ("path" in m && m.path.length) return m.path[0]
                } catch (m) {}
                return m && m.target
            }

            function initMutationObserver(m, _) {
                let C = new MutationBuffer;
                rc.push(C), C.init(m);
                let R = window.MutationObserver || window.__rrMutationObserver,
                    L = _optionalChain$2([window, "optionalAccess", m => m.Zone, "optionalAccess", m => m.__symbol__, "optionalCall", m => m("MutationObserver")]);
                L && window[L] && (R = window[L]);
                let B = new R(callbackWrapper(_ => {
                    m.onMutation && !1 === m.onMutation(_) || C.processMutations.bind(C)(_)
                }));
                return B.observe(_, {
                    attributes: !0,
                    attributeOldValue: !0,
                    characterData: !0,
                    characterDataOldValue: !0,
                    childList: !0,
                    subtree: !0
                }), B
            }

            function initScrollObserver({
                scrollCb: m,
                doc: _,
                mirror: C,
                blockClass: R,
                blockSelector: L,
                unblockSelector: B,
                sampling: F
            }) {
                let U = callbackWrapper(throttle$1(callbackWrapper(F => {
                    let U = esm_getEventTarget(F);
                    if (!U || isBlocked(U, R, L, B, !0)) return;
                    let H = C.getId(U);
                    if (U === _ && _.defaultView) {
                        let C = getWindowScroll(_.defaultView);
                        m({
                            id: H,
                            x: C.left,
                            y: C.top
                        })
                    } else m({
                        id: H,
                        x: U.scrollLeft,
                        y: U.scrollTop
                    })
                }), F.scroll || 100));
                return on("scroll", U, _)
            }
            let rl = ["INPUT", "TEXTAREA", "SELECT"],
                ru = new WeakMap;

            function getNestedCSSRulePositions(m) {
                return function(m, _) {
                    if (hasNestedCSSRule("CSSGroupingRule") && m.parentRule instanceof CSSGroupingRule || hasNestedCSSRule("CSSMediaRule") && m.parentRule instanceof CSSMediaRule || hasNestedCSSRule("CSSSupportsRule") && m.parentRule instanceof CSSSupportsRule || hasNestedCSSRule("CSSConditionRule") && m.parentRule instanceof CSSConditionRule) {
                        let C = Array.from(m.parentRule.cssRules),
                            R = C.indexOf(m);
                        _.unshift(R)
                    } else if (m.parentStyleSheet) {
                        let C = Array.from(m.parentStyleSheet.cssRules),
                            R = C.indexOf(m);
                        _.unshift(R)
                    }
                    return _
                }(m, [])
            }

            function getIdAndStyleId(m, _, C) {
                let R, L;
                return m ? (m.ownerNode ? R = _.getId(m.ownerNode) : L = C.getId(m), {
                    styleId: L,
                    id: R
                }) : {}
            }

            function initAdoptedStyleSheetObserver({
                mirror: m,
                stylesheetManager: _
            }, C) {
                let R = null;
                R = "#document" === C.nodeName ? m.getId(C) : m.getId(C.host);
                let L = "#document" === C.nodeName ? _optionalChain$2([C, "access", m => m.defaultView, "optionalAccess", m => m.Document]) : _optionalChain$2([C, "access", m => m.ownerDocument, "optionalAccess", m => m.defaultView, "optionalAccess", m => m.ShadowRoot]),
                    B = _optionalChain$2([L, "optionalAccess", m => m.prototype]) ? Object.getOwnPropertyDescriptor(_optionalChain$2([L, "optionalAccess", m => m.prototype]), "adoptedStyleSheets") : void 0;
                return null !== R && -1 !== R && L && B ? (Object.defineProperty(C, "adoptedStyleSheets", {
                    configurable: B.configurable,
                    enumerable: B.enumerable,
                    get() {
                        return _optionalChain$2([B, "access", m => m.get, "optionalAccess", m => m.call, "call", m => m(this)])
                    },
                    set(m) {
                        let C = _optionalChain$2([B, "access", m => m.set, "optionalAccess", m => m.call, "call", _ => _(this, m)]);
                        if (null !== R && -1 !== R) try {
                            _.adoptStyleSheets(m, R)
                        } catch (m) {}
                        return C
                    }
                }), callbackWrapper(() => {
                    Object.defineProperty(C, "adoptedStyleSheets", {
                        configurable: B.configurable,
                        enumerable: B.enumerable,
                        get: B.get,
                        set: B.set
                    })
                })) : () => {}
            }

            function initObservers(m, _ = {}) {
                let C;
                let R = m.doc.defaultView;
                if (!R) return () => {};
                m.recordDOM && (C = initMutationObserver(m, m.doc));
                let L = function({
                        mousemoveCb: m,
                        sampling: _,
                        doc: C,
                        mirror: R
                    }) {
                        let L;
                        if (!1 === _.mousemove) return () => {};
                        let B = "number" == typeof _.mousemove ? _.mousemove : 50,
                            F = "number" == typeof _.mousemoveCallback ? _.mousemoveCallback : 500,
                            U = [],
                            H = throttle$1(callbackWrapper(_ => {
                                let C = Date.now() - L;
                                m(U.map(m => (m.timeOffset -= C, m)), _), U = [], L = null
                            }), F),
                            q = callbackWrapper(throttle$1(callbackWrapper(m => {
                                let _ = esm_getEventTarget(m),
                                    {
                                        clientX: C,
                                        clientY: B
                                    } = legacy_isTouchEvent(m) ? m.changedTouches[0] : m;
                                L || (L = rr()), U.push({
                                    x: C,
                                    y: B,
                                    id: R.getId(_),
                                    timeOffset: rr() - L
                                }), H("undefined" != typeof DragEvent && m instanceof DragEvent ? ro.Drag : m instanceof MouseEvent ? ro.MouseMove : ro.TouchMove)
                            }), B, {
                                trailing: !1
                            })),
                            V = [on("mousemove", q, C), on("touchmove", q, C), on("drag", q, C)];
                        return callbackWrapper(() => {
                            V.forEach(m => m())
                        })
                    }(m),
                    B = function({
                        mouseInteractionCb: m,
                        doc: _,
                        mirror: C,
                        blockClass: R,
                        blockSelector: L,
                        unblockSelector: B,
                        sampling: F
                    }) {
                        if (!1 === F.mouseInteraction) return () => {};
                        let U = !0 === F.mouseInteraction || void 0 === F.mouseInteraction ? {} : F.mouseInteraction,
                            H = [],
                            q = null,
                            getHandler = _ => F => {
                                let U = esm_getEventTarget(F);
                                if (isBlocked(U, R, L, B, !0)) return;
                                let H = null,
                                    V = _;
                                if ("pointerType" in F) {
                                    switch (F.pointerType) {
                                        case "mouse":
                                            H = rs.Mouse;
                                            break;
                                        case "touch":
                                            H = rs.Touch;
                                            break;
                                        case "pen":
                                            H = rs.Pen
                                    }
                                    H === rs.Touch ? ra[_] === ra.MouseDown ? V = "TouchStart" : ra[_] === ra.MouseUp && (V = "TouchEnd") : rs.Pen
                                } else legacy_isTouchEvent(F) && (H = rs.Touch);
                                null !== H ? (q = H, (V.startsWith("Touch") && H === rs.Touch || V.startsWith("Mouse") && H === rs.Mouse) && (H = null)) : ra[_] === ra.Click && (H = q, q = null);
                                let X = legacy_isTouchEvent(F) ? F.changedTouches[0] : F;
                                if (!X) return;
                                let K = C.getId(U),
                                    {
                                        clientX: Y,
                                        clientY: Q
                                    } = X;
                                callbackWrapper(m)({
                                    type: ra[V],
                                    id: K,
                                    x: Y,
                                    y: Q,
                                    ...null !== H && {
                                        pointerType: H
                                    }
                                })
                            };
                        return Object.keys(ra).filter(m => Number.isNaN(Number(m)) && !m.endsWith("_Departed") && !1 !== U[m]).forEach(m => {
                            let C = toLowerCase(m),
                                R = getHandler(m);
                            if (window.PointerEvent) switch (ra[m]) {
                                case ra.MouseDown:
                                case ra.MouseUp:
                                    C = C.replace("mouse", "pointer");
                                    break;
                                case ra.TouchStart:
                                case ra.TouchEnd:
                                    return
                            }
                            H.push(on(C, R, _))
                        }), callbackWrapper(() => {
                            H.forEach(m => m())
                        })
                    }(m),
                    F = initScrollObserver(m),
                    U = function({
                        viewportResizeCb: m
                    }, {
                        win: _
                    }) {
                        let C = -1,
                            R = -1,
                            L = callbackWrapper(throttle$1(callbackWrapper(() => {
                                let _ = getWindowHeight(),
                                    L = getWindowWidth();
                                (C !== _ || R !== L) && (m({
                                    width: Number(L),
                                    height: Number(_)
                                }), C = _, R = L)
                            }), 200));
                        return on("resize", L, _)
                    }(m, {
                        win: R
                    }),
                    H = function({
                        inputCb: m,
                        doc: _,
                        mirror: C,
                        blockClass: R,
                        blockSelector: L,
                        unblockSelector: B,
                        ignoreClass: F,
                        ignoreSelector: U,
                        maskInputOptions: H,
                        maskInputFn: q,
                        sampling: V,
                        userTriggeredOnInput: X,
                        maskTextClass: K,
                        unmaskTextClass: Y,
                        maskTextSelector: Q,
                        unmaskTextSelector: et
                    }) {
                        function eventHandler(m) {
                            let C = esm_getEventTarget(m),
                                V = m.isTrusted,
                                er = C && toUpperCase(C.tagName);
                            if ("OPTION" === er && (C = C.parentElement), !C || !er || 0 > rl.indexOf(er) || isBlocked(C, R, L, B, !0)) return;
                            let en = C;
                            if (en.classList.contains(F) || U && en.matches(U)) return;
                            let ei = getInputType(C),
                                eo = getInputValue(en, er, ei),
                                ea = !1,
                                es = shouldMaskInput({
                                    maskInputOptions: H,
                                    tagName: er,
                                    type: ei
                                }),
                                ec = needMaskingText(C, K, Q, Y, et, es);
                            ("radio" === ei || "checkbox" === ei) && (ea = C.checked), eo = maskInputValue({
                                isMasked: ec,
                                element: C,
                                value: eo,
                                maskInputFn: q
                            }), cbWithDedup(C, X ? {
                                text: eo,
                                isChecked: ea,
                                userTriggered: V
                            } : {
                                text: eo,
                                isChecked: ea
                            });
                            let el = C.name;
                            "radio" === ei && el && ea && _.querySelectorAll(`input[type="radio"][name="${el}"]`).forEach(m => {
                                if (m !== C) {
                                    let _ = maskInputValue({
                                        isMasked: ec,
                                        element: m,
                                        value: getInputValue(m, er, ei),
                                        maskInputFn: q
                                    });
                                    cbWithDedup(m, X ? {
                                        text: _,
                                        isChecked: !ea,
                                        userTriggered: !1
                                    } : {
                                        text: _,
                                        isChecked: !ea
                                    })
                                }
                            })
                        }

                        function cbWithDedup(_, R) {
                            let L = ru.get(_);
                            if (!L || L.text !== R.text || L.isChecked !== R.isChecked) {
                                ru.set(_, R);
                                let L = C.getId(_);
                                callbackWrapper(m)({ ...R,
                                    id: L
                                })
                            }
                        }
                        let er = "last" === V.input ? ["change"] : ["input", "change"],
                            en = er.map(m => on(m, callbackWrapper(eventHandler), _)),
                            ei = _.defaultView;
                        if (!ei) return () => {
                            en.forEach(m => m())
                        };
                        let eo = ei.Object.getOwnPropertyDescriptor(ei.HTMLInputElement.prototype, "value"),
                            ea = [
                                [ei.HTMLInputElement.prototype, "value"],
                                [ei.HTMLInputElement.prototype, "checked"],
                                [ei.HTMLSelectElement.prototype, "value"],
                                [ei.HTMLTextAreaElement.prototype, "value"],
                                [ei.HTMLSelectElement.prototype, "selectedIndex"],
                                [ei.HTMLOptionElement.prototype, "selected"]
                            ];
                        return eo && eo.set && en.push(...ea.map(m => (function hookSetter(m, _, C, R, L = window) {
                            let B = L.Object.getOwnPropertyDescriptor(m, _);
                            return L.Object.defineProperty(m, _, R ? C : {
                                set(m) {
                                    setTimeout$1(() => {
                                        C.set.call(this, m)
                                    }, 0), B && B.set && B.set.call(this, m)
                                }
                            }), () => hookSetter(m, _, B || {}, !0)
                        })(m[0], m[1], {
                            set() {
                                callbackWrapper(eventHandler)({
                                    target: this,
                                    isTrusted: !1
                                })
                            }
                        }, !1, ei))), callbackWrapper(() => {
                            en.forEach(m => m())
                        })
                    }(m),
                    q = function({
                        mediaInteractionCb: m,
                        blockClass: _,
                        blockSelector: C,
                        unblockSelector: R,
                        mirror: L,
                        sampling: B,
                        doc: F
                    }) {
                        let U = callbackWrapper(F => throttle$1(callbackWrapper(B => {
                                let U = esm_getEventTarget(B);
                                if (!U || isBlocked(U, _, C, R, !0)) return;
                                let {
                                    currentTime: H,
                                    volume: q,
                                    muted: V,
                                    playbackRate: X
                                } = U;
                                m({
                                    type: F,
                                    id: L.getId(U),
                                    currentTime: H,
                                    volume: q,
                                    muted: V,
                                    playbackRate: X
                                })
                            }), B.media || 500)),
                            H = [on("play", U(0), F), on("pause", U(1), F), on("seeked", U(2), F), on("volumechange", U(3), F), on("ratechange", U(4), F)];
                        return callbackWrapper(() => {
                            H.forEach(m => m())
                        })
                    }(m),
                    styleSheetObserver = () => {},
                    adoptedStyleSheetObserver = () => {},
                    styleDeclarationObserver = () => {},
                    fontObserver = () => {};
                m.recordDOM && (styleSheetObserver = function({
                    styleSheetRuleCb: m,
                    mirror: _,
                    stylesheetManager: C
                }, {
                    win: R
                }) {
                    let L, B;
                    if (!R.CSSStyleSheet || !R.CSSStyleSheet.prototype) return () => {};
                    let F = R.CSSStyleSheet.prototype.insertRule;
                    R.CSSStyleSheet.prototype.insertRule = new Proxy(F, {
                        apply: callbackWrapper((R, L, B) => {
                            let [F, U] = B, {
                                id: H,
                                styleId: q
                            } = getIdAndStyleId(L, _, C.styleMirror);
                            return (H && -1 !== H || q && -1 !== q) && m({
                                id: H,
                                styleId: q,
                                adds: [{
                                    rule: F,
                                    index: U
                                }]
                            }), R.apply(L, B)
                        })
                    });
                    let U = R.CSSStyleSheet.prototype.deleteRule;
                    R.CSSStyleSheet.prototype.deleteRule = new Proxy(U, {
                        apply: callbackWrapper((R, L, B) => {
                            let [F] = B, {
                                id: U,
                                styleId: H
                            } = getIdAndStyleId(L, _, C.styleMirror);
                            return (U && -1 !== U || H && -1 !== H) && m({
                                id: U,
                                styleId: H,
                                removes: [{
                                    index: F
                                }]
                            }), R.apply(L, B)
                        })
                    }), R.CSSStyleSheet.prototype.replace && (L = R.CSSStyleSheet.prototype.replace, R.CSSStyleSheet.prototype.replace = new Proxy(L, {
                        apply: callbackWrapper((R, L, B) => {
                            let [F] = B, {
                                id: U,
                                styleId: H
                            } = getIdAndStyleId(L, _, C.styleMirror);
                            return (U && -1 !== U || H && -1 !== H) && m({
                                id: U,
                                styleId: H,
                                replace: F
                            }), R.apply(L, B)
                        })
                    })), R.CSSStyleSheet.prototype.replaceSync && (B = R.CSSStyleSheet.prototype.replaceSync, R.CSSStyleSheet.prototype.replaceSync = new Proxy(B, {
                        apply: callbackWrapper((R, L, B) => {
                            let [F] = B, {
                                id: U,
                                styleId: H
                            } = getIdAndStyleId(L, _, C.styleMirror);
                            return (U && -1 !== U || H && -1 !== H) && m({
                                id: U,
                                styleId: H,
                                replaceSync: F
                            }), R.apply(L, B)
                        })
                    }));
                    let H = {};
                    canMonkeyPatchNestedCSSRule("CSSGroupingRule") ? H.CSSGroupingRule = R.CSSGroupingRule : (canMonkeyPatchNestedCSSRule("CSSMediaRule") && (H.CSSMediaRule = R.CSSMediaRule), canMonkeyPatchNestedCSSRule("CSSConditionRule") && (H.CSSConditionRule = R.CSSConditionRule), canMonkeyPatchNestedCSSRule("CSSSupportsRule") && (H.CSSSupportsRule = R.CSSSupportsRule));
                    let q = {};
                    return Object.entries(H).forEach(([R, L]) => {
                        q[R] = {
                            insertRule: L.prototype.insertRule,
                            deleteRule: L.prototype.deleteRule
                        }, L.prototype.insertRule = new Proxy(q[R].insertRule, {
                            apply: callbackWrapper((R, L, B) => {
                                let [F, U] = B, {
                                    id: H,
                                    styleId: q
                                } = getIdAndStyleId(L.parentStyleSheet, _, C.styleMirror);
                                return (H && -1 !== H || q && -1 !== q) && m({
                                    id: H,
                                    styleId: q,
                                    adds: [{
                                        rule: F,
                                        index: [...getNestedCSSRulePositions(L), U || 0]
                                    }]
                                }), R.apply(L, B)
                            })
                        }), L.prototype.deleteRule = new Proxy(q[R].deleteRule, {
                            apply: callbackWrapper((R, L, B) => {
                                let [F] = B, {
                                    id: U,
                                    styleId: H
                                } = getIdAndStyleId(L.parentStyleSheet, _, C.styleMirror);
                                return (U && -1 !== U || H && -1 !== H) && m({
                                    id: U,
                                    styleId: H,
                                    removes: [{
                                        index: [...getNestedCSSRulePositions(L), F]
                                    }]
                                }), R.apply(L, B)
                            })
                        })
                    }), callbackWrapper(() => {
                        R.CSSStyleSheet.prototype.insertRule = F, R.CSSStyleSheet.prototype.deleteRule = U, L && (R.CSSStyleSheet.prototype.replace = L), B && (R.CSSStyleSheet.prototype.replaceSync = B), Object.entries(H).forEach(([m, _]) => {
                            _.prototype.insertRule = q[m].insertRule, _.prototype.deleteRule = q[m].deleteRule
                        })
                    })
                }(m, {
                    win: R
                }), adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(m, m.doc), styleDeclarationObserver = function({
                    styleDeclarationCb: m,
                    mirror: _,
                    ignoreCSSAttributes: C,
                    stylesheetManager: R
                }, {
                    win: L
                }) {
                    let B = L.CSSStyleDeclaration.prototype.setProperty;
                    L.CSSStyleDeclaration.prototype.setProperty = new Proxy(B, {
                        apply: callbackWrapper((L, F, U) => {
                            let [H, q, V] = U;
                            if (C.has(H)) return B.apply(F, [H, q, V]);
                            let {
                                id: X,
                                styleId: K
                            } = getIdAndStyleId(_optionalChain$2([F, "access", m => m.parentRule, "optionalAccess", m => m.parentStyleSheet]), _, R.styleMirror);
                            return (X && -1 !== X || K && -1 !== K) && m({
                                id: X,
                                styleId: K,
                                set: {
                                    property: H,
                                    value: q,
                                    priority: V
                                },
                                index: getNestedCSSRulePositions(F.parentRule)
                            }), L.apply(F, U)
                        })
                    });
                    let F = L.CSSStyleDeclaration.prototype.removeProperty;
                    return L.CSSStyleDeclaration.prototype.removeProperty = new Proxy(F, {
                        apply: callbackWrapper((L, B, U) => {
                            let [H] = U;
                            if (C.has(H)) return F.apply(B, [H]);
                            let {
                                id: q,
                                styleId: V
                            } = getIdAndStyleId(_optionalChain$2([B, "access", m => m.parentRule, "optionalAccess", m => m.parentStyleSheet]), _, R.styleMirror);
                            return (q && -1 !== q || V && -1 !== V) && m({
                                id: q,
                                styleId: V,
                                remove: {
                                    property: H
                                },
                                index: getNestedCSSRulePositions(B.parentRule)
                            }), L.apply(B, U)
                        })
                    }), callbackWrapper(() => {
                        L.CSSStyleDeclaration.prototype.setProperty = B, L.CSSStyleDeclaration.prototype.removeProperty = F
                    })
                }(m, {
                    win: R
                }), m.collectFonts && (fontObserver = function({
                    fontCb: m,
                    doc: _
                }) {
                    let C = _.defaultView;
                    if (!C) return () => {};
                    let R = [],
                        L = new WeakMap,
                        B = C.FontFace;
                    C.FontFace = function(m, _, C) {
                        let R = new B(m, _, C);
                        return L.set(R, {
                            family: m,
                            buffer: "string" != typeof _,
                            descriptors: C,
                            fontSource: "string" == typeof _ ? _ : JSON.stringify(Array.from(new Uint8Array(_)))
                        }), R
                    };
                    let F = patch(_.fonts, "add", function(_) {
                        return function(C) {
                            return setTimeout$1(callbackWrapper(() => {
                                let _ = L.get(C);
                                _ && (m(_), L.delete(C))
                            }), 0), _.apply(this, [C])
                        }
                    });
                    return R.push(() => {
                        C.FontFace = B
                    }), R.push(F), callbackWrapper(() => {
                        R.forEach(m => m())
                    })
                }(m)));
                let V = function(m) {
                        let {
                            doc: _,
                            mirror: C,
                            blockClass: R,
                            blockSelector: L,
                            unblockSelector: B,
                            selectionCb: F
                        } = m, U = !0, H = callbackWrapper(() => {
                            let m = _.getSelection();
                            if (!m || U && _optionalChain$2([m, "optionalAccess", m => m.isCollapsed])) return;
                            U = m.isCollapsed || !1;
                            let H = [],
                                q = m.rangeCount || 0;
                            for (let _ = 0; _ < q; _++) {
                                let F = m.getRangeAt(_),
                                    {
                                        startContainer: U,
                                        startOffset: q,
                                        endContainer: V,
                                        endOffset: X
                                    } = F,
                                    K = isBlocked(U, R, L, B, !0) || isBlocked(V, R, L, B, !0);
                                K || H.push({
                                    start: C.getId(U),
                                    startOffset: q,
                                    end: C.getId(V),
                                    endOffset: X
                                })
                            }
                            F({
                                ranges: H
                            })
                        });
                        return H(), on("selectionchange", H)
                    }(m),
                    X = function({
                        doc: m,
                        customElementCb: _
                    }) {
                        let C = m.defaultView;
                        if (!C || !C.customElements) return () => {};
                        let R = patch(C.customElements, "define", function(m) {
                            return function(C, R, L) {
                                try {
                                    _({
                                        define: {
                                            name: C
                                        }
                                    })
                                } catch (m) {}
                                return m.apply(this, [C, R, L])
                            }
                        });
                        return R
                    }(m),
                    K = [];
                for (let _ of m.plugins) K.push(_.observer(_.callback, R, _.options));
                return callbackWrapper(() => {
                    rc.forEach(m => m.reset()), _optionalChain$2([C, "optionalAccess", m => m.disconnect, "call", m => m()]), L(), B(), F(), U(), H(), q(), styleSheetObserver(), adoptedStyleSheetObserver(), styleDeclarationObserver(), fontObserver(), V(), X(), K.forEach(m => m())
                })
            }

            function hasNestedCSSRule(m) {
                return void 0 !== window[m]
            }

            function canMonkeyPatchNestedCSSRule(m) {
                return !!(void 0 !== window[m] && window[m].prototype && "insertRule" in window[m].prototype && "deleteRule" in window[m].prototype)
            }
            let CrossOriginIframeMirror = class CrossOriginIframeMirror {
                constructor(m) {
                    this.generateIdFn = m, this.iframeIdToRemoteIdMap = new WeakMap, this.iframeRemoteIdToIdMap = new WeakMap
                }
                getId(m, _, C, R) {
                    let L = C || this.getIdToRemoteIdMap(m),
                        B = R || this.getRemoteIdToIdMap(m),
                        F = L.get(_);
                    return F || (F = this.generateIdFn(), L.set(_, F), B.set(F, _)), F
                }
                getIds(m, _) {
                    let C = this.getIdToRemoteIdMap(m),
                        R = this.getRemoteIdToIdMap(m);
                    return _.map(_ => this.getId(m, _, C, R))
                }
                getRemoteId(m, _, C) {
                    let R = C || this.getRemoteIdToIdMap(m);
                    if ("number" != typeof _) return _;
                    let L = R.get(_);
                    return L || -1
                }
                getRemoteIds(m, _) {
                    let C = this.getRemoteIdToIdMap(m);
                    return _.map(_ => this.getRemoteId(m, _, C))
                }
                reset(m) {
                    if (!m) {
                        this.iframeIdToRemoteIdMap = new WeakMap, this.iframeRemoteIdToIdMap = new WeakMap;
                        return
                    }
                    this.iframeIdToRemoteIdMap.delete(m), this.iframeRemoteIdToIdMap.delete(m)
                }
                getIdToRemoteIdMap(m) {
                    let _ = this.iframeIdToRemoteIdMap.get(m);
                    return _ || (_ = new Map, this.iframeIdToRemoteIdMap.set(m, _)), _
                }
                getRemoteIdToIdMap(m) {
                    let _ = this.iframeRemoteIdToIdMap.get(m);
                    return _ || (_ = new Map, this.iframeRemoteIdToIdMap.set(m, _)), _
                }
            };

            function _optionalChain$1(m) {
                let _;
                let C = m[0],
                    R = 1;
                for (; R < m.length;) {
                    let L = m[R],
                        B = m[R + 1];
                    if (R += 2, ("optionalAccess" === L || "optionalCall" === L) && null == C) return;
                    "access" === L || "optionalAccess" === L ? (_ = C, C = B(C)) : ("call" === L || "optionalCall" === L) && (C = B((...m) => C.call(_, ...m)), _ = void 0)
                }
                return C
            }
            let IframeManagerNoop = class IframeManagerNoop {
                constructor() {
                    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId), this.crossOriginIframeRootIdMap = new WeakMap
                }
                addIframe() {}
                addLoadListener() {}
                attachIframe() {}
            };
            let IframeManager = class IframeManager {
                constructor(m) {
                    this.iframes = new WeakMap, this.crossOriginIframeMap = new WeakMap, this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId), this.crossOriginIframeRootIdMap = new WeakMap, this.mutationCb = m.mutationCb, this.wrappedEmit = m.wrappedEmit, this.stylesheetManager = m.stylesheetManager, this.recordCrossOriginIframes = m.recordCrossOriginIframes, this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror)), this.mirror = m.mirror, this.recordCrossOriginIframes && window.addEventListener("message", this.handleMessage.bind(this))
                }
                addIframe(m) {
                    this.iframes.set(m, !0), m.contentWindow && this.crossOriginIframeMap.set(m.contentWindow, m)
                }
                addLoadListener(m) {
                    this.loadListener = m
                }
                attachIframe(m, _) {
                    this.mutationCb({
                        adds: [{
                            parentId: this.mirror.getId(m),
                            nextId: null,
                            node: _
                        }],
                        removes: [],
                        texts: [],
                        attributes: [],
                        isAttachIframe: !0
                    }), _optionalChain$1([this, "access", m => m.loadListener, "optionalCall", _ => _(m)]), m.contentDocument && m.contentDocument.adoptedStyleSheets && m.contentDocument.adoptedStyleSheets.length > 0 && this.stylesheetManager.adoptStyleSheets(m.contentDocument.adoptedStyleSheets, this.mirror.getId(m.contentDocument))
                }
                handleMessage(m) {
                    if ("rrweb" !== m.data.type || m.origin !== m.data.origin) return;
                    let _ = m.source;
                    if (!_) return;
                    let C = this.crossOriginIframeMap.get(m.source);
                    if (!C) return;
                    let R = this.transformCrossOriginEvent(C, m.data.event);
                    R && this.wrappedEmit(R, m.data.isCheckout)
                }
                transformCrossOriginEvent(m, _) {
                    switch (_.type) {
                        case ri.FullSnapshot:
                            {
                                this.crossOriginIframeMirror.reset(m),
                                this.crossOriginIframeStyleMirror.reset(m),
                                this.replaceIdOnNode(_.data.node, m);
                                let C = _.data.node.id;
                                return this.crossOriginIframeRootIdMap.set(m, C),
                                this.patchRootIdOnNode(_.data.node, C),
                                {
                                    timestamp: _.timestamp,
                                    type: ri.IncrementalSnapshot,
                                    data: {
                                        source: ro.Mutation,
                                        adds: [{
                                            parentId: this.mirror.getId(m),
                                            nextId: null,
                                            node: _.data.node
                                        }],
                                        removes: [],
                                        texts: [],
                                        attributes: [],
                                        isAttachIframe: !0
                                    }
                                }
                            }
                        case ri.Meta:
                        case ri.Load:
                        case ri.DomContentLoaded:
                            break;
                        case ri.Plugin:
                            return _;
                        case ri.Custom:
                            return this.replaceIds(_.data.payload, m, ["id", "parentId", "previousId", "nextId"]), _;
                        case ri.IncrementalSnapshot:
                            switch (_.data.source) {
                                case ro.Mutation:
                                    return _.data.adds.forEach(_ => {
                                        this.replaceIds(_, m, ["parentId", "nextId", "previousId"]), this.replaceIdOnNode(_.node, m);
                                        let C = this.crossOriginIframeRootIdMap.get(m);
                                        C && this.patchRootIdOnNode(_.node, C)
                                    }), _.data.removes.forEach(_ => {
                                        this.replaceIds(_, m, ["parentId", "id"])
                                    }), _.data.attributes.forEach(_ => {
                                        this.replaceIds(_, m, ["id"])
                                    }), _.data.texts.forEach(_ => {
                                        this.replaceIds(_, m, ["id"])
                                    }), _;
                                case ro.Drag:
                                case ro.TouchMove:
                                case ro.MouseMove:
                                    return _.data.positions.forEach(_ => {
                                        this.replaceIds(_, m, ["id"])
                                    }), _;
                                case ro.ViewportResize:
                                    return !1;
                                case ro.MediaInteraction:
                                case ro.MouseInteraction:
                                case ro.Scroll:
                                case ro.CanvasMutation:
                                case ro.Input:
                                    return this.replaceIds(_.data, m, ["id"]), _;
                                case ro.StyleSheetRule:
                                case ro.StyleDeclaration:
                                    return this.replaceIds(_.data, m, ["id"]), this.replaceStyleIds(_.data, m, ["styleId"]), _;
                                case ro.Font:
                                    return _;
                                case ro.Selection:
                                    return _.data.ranges.forEach(_ => {
                                        this.replaceIds(_, m, ["start", "end"])
                                    }), _;
                                case ro.AdoptedStyleSheet:
                                    return this.replaceIds(_.data, m, ["id"]), this.replaceStyleIds(_.data, m, ["styleIds"]), _optionalChain$1([_, "access", m => m.data, "access", m => m.styles, "optionalAccess", m => m.forEach, "call", _ => _(_ => {
                                        this.replaceStyleIds(_, m, ["styleId"])
                                    })]), _
                            }
                    }
                    return !1
                }
                replace(m, _, C, R) {
                    for (let L of R)(Array.isArray(_[L]) || "number" == typeof _[L]) && (Array.isArray(_[L]) ? _[L] = m.getIds(C, _[L]) : _[L] = m.getId(C, _[L]));
                    return _
                }
                replaceIds(m, _, C) {
                    return this.replace(this.crossOriginIframeMirror, m, _, C)
                }
                replaceStyleIds(m, _, C) {
                    return this.replace(this.crossOriginIframeStyleMirror, m, _, C)
                }
                replaceIdOnNode(m, _) {
                    this.replaceIds(m, _, ["id", "rootId"]), "childNodes" in m && m.childNodes.forEach(m => {
                        this.replaceIdOnNode(m, _)
                    })
                }
                patchRootIdOnNode(m, _) {
                    m.type === em.Document || m.rootId || (m.rootId = _), "childNodes" in m && m.childNodes.forEach(m => {
                        this.patchRootIdOnNode(m, _)
                    })
                }
            };
            let ShadowDomManagerNoop = class ShadowDomManagerNoop {
                init() {}
                addShadowRoot() {}
                observeAttachShadow() {}
                reset() {}
            };
            let ShadowDomManager = class ShadowDomManager {
                constructor(m) {
                    this.shadowDoms = new WeakSet, this.restoreHandlers = [], this.mutationCb = m.mutationCb, this.scrollCb = m.scrollCb, this.bypassOptions = m.bypassOptions, this.mirror = m.mirror, this.init()
                }
                init() {
                    this.reset(), this.patchAttachShadow(Element, document)
                }
                addShadowRoot(m, _) {
                    if (!isNativeShadowDom(m) || this.shadowDoms.has(m)) return;
                    this.shadowDoms.add(m), this.bypassOptions.canvasManager.addShadowRoot(m);
                    let C = initMutationObserver({ ...this.bypassOptions,
                        doc: _,
                        mutationCb: this.mutationCb,
                        mirror: this.mirror,
                        shadowDomManager: this
                    }, m);
                    this.restoreHandlers.push(() => C.disconnect()), this.restoreHandlers.push(initScrollObserver({ ...this.bypassOptions,
                        scrollCb: this.scrollCb,
                        doc: m,
                        mirror: this.mirror
                    })), setTimeout$1(() => {
                        m.adoptedStyleSheets && m.adoptedStyleSheets.length > 0 && this.bypassOptions.stylesheetManager.adoptStyleSheets(m.adoptedStyleSheets, this.mirror.getId(m.host)), this.restoreHandlers.push(initAdoptedStyleSheetObserver({
                            mirror: this.mirror,
                            stylesheetManager: this.bypassOptions.stylesheetManager
                        }, m))
                    }, 0)
                }
                observeAttachShadow(m) {
                    m.contentWindow && m.contentDocument && this.patchAttachShadow(m.contentWindow.Element, m.contentDocument)
                }
                patchAttachShadow(m, _) {
                    let C = this;
                    this.restoreHandlers.push(patch(m.prototype, "attachShadow", function(m) {
                        return function(R) {
                            let L = m.call(this, R);
                            return this.shadowRoot && inDom(this) && C.addShadowRoot(this.shadowRoot, _), L
                        }
                    }))
                }
                reset() {
                    this.restoreHandlers.forEach(m => {
                        try {
                            m()
                        } catch (m) {}
                    }), this.restoreHandlers = [], this.shadowDoms = new WeakSet, this.bypassOptions.canvasManager.resetShadowRoots()
                }
            };
            let CanvasManagerNoop = class CanvasManagerNoop {
                reset() {}
                freeze() {}
                unfreeze() {}
                lock() {}
                unlock() {}
                snapshot() {}
                addWindow() {}
                addShadowRoot() {}
                resetShadowRoots() {}
            };
            let StylesheetManager = class StylesheetManager {
                constructor(m) {
                    this.trackedLinkElements = new WeakSet, this.styleMirror = new StyleSheetMirror, this.mutationCb = m.mutationCb, this.adoptedStyleSheetCb = m.adoptedStyleSheetCb
                }
                attachLinkElement(m, _) {
                    "_cssText" in _.attributes && this.mutationCb({
                        adds: [],
                        removes: [],
                        texts: [],
                        attributes: [{
                            id: _.id,
                            attributes: _.attributes
                        }]
                    }), this.trackLinkElement(m)
                }
                trackLinkElement(m) {
                    this.trackedLinkElements.has(m) || (this.trackedLinkElements.add(m), this.trackStylesheetInLinkElement(m))
                }
                adoptStyleSheets(m, _) {
                    if (0 === m.length) return;
                    let C = {
                            id: _,
                            styleIds: []
                        },
                        R = [];
                    for (let _ of m) {
                        let m;
                        this.styleMirror.has(_) ? m = this.styleMirror.getId(_) : (m = this.styleMirror.add(_), R.push({
                            styleId: m,
                            rules: Array.from(_.rules || CSSRule, (m, _) => ({
                                rule: stringifyRule(m),
                                index: _
                            }))
                        })), C.styleIds.push(m)
                    }
                    R.length > 0 && (C.styles = R), this.adoptedStyleSheetCb(C)
                }
                reset() {
                    this.styleMirror.reset(), this.trackedLinkElements = new WeakSet
                }
                trackStylesheetInLinkElement(m) {}
            };
            let ProcessedNodeManager = class ProcessedNodeManager {
                constructor() {
                    this.nodeMap = new WeakMap, this.active = !1
                }
                inOtherBuffer(m, _) {
                    let C = this.nodeMap.get(m);
                    return C && Array.from(C).some(m => m !== _)
                }
                add(m, _) {
                    this.active || (this.active = !0, function(...m) {
                        getImplementation("requestAnimationFrame")(...m)
                    }(() => {
                        this.nodeMap = new WeakMap, this.active = !1
                    })), this.nodeMap.set(m, (this.nodeMap.get(m) || new Set).add(_))
                }
                destroy() {}
            };
            try {
                if (2 !== Array.from([1], m => 2 * m)[0]) {
                    let m = document.createElement("iframe");
                    document.body.appendChild(m), Array.from = _optionalChain([m, "access", m => m.contentWindow, "optionalAccess", m => m.Array, "access", m => m.from]) || Array.from, document.body.removeChild(m)
                }
            } catch (m) {
                console.debug("Unable to override Array.from", m)
            }
            let rd = new Mirror;

            function record(m = {}) {
                let _;
                let {
                    emit: C,
                    checkoutEveryNms: R,
                    checkoutEveryNth: L,
                    blockClass: B = "rr-block",
                    blockSelector: F = null,
                    unblockSelector: U = null,
                    ignoreClass: H = "rr-ignore",
                    ignoreSelector: q = null,
                    maskAllText: V = !1,
                    maskTextClass: X = "rr-mask",
                    unmaskTextClass: K = null,
                    maskTextSelector: Y = null,
                    unmaskTextSelector: Q = null,
                    inlineStylesheet: et = !0,
                    maskAllInputs: er,
                    maskInputOptions: en,
                    slimDOMOptions: es,
                    maskAttributeFn: ec,
                    maskInputFn: el,
                    maskTextFn: eu,
                    maxCanvasSize: ed = null,
                    packFn: ep,
                    sampling: eh = {},
                    dataURLOptions: ef = {},
                    mousemoveWait: em,
                    recordDOM: eg = !0,
                    recordCanvas: ey = !1,
                    recordCrossOriginIframes: e_ = !1,
                    recordAfter: ev = "DOMContentLoaded" === m.recordAfter ? m.recordAfter : "load",
                    userTriggeredOnInput: eb = !1,
                    collectFonts: eS = !1,
                    inlineImages: ew = !1,
                    plugins: eE,
                    keepIframeSrcFn: ek = () => !1,
                    ignoreCSSAttributes: ex = new Set([]),
                    errorHandler: eI,
                    onMutation: eO,
                    getCanvasManager: eC
                } = m;
                ei = eI;
                let eM = !e_ || window.parent === window,
                    eT = !1;
                if (!eM) try {
                    window.parent.document && (eT = !1)
                } catch (m) {
                    eT = !0
                }
                if (eM && !C) throw Error("emit function is required");
                if (!eM && !eT) return () => {};
                void 0 !== em && void 0 === eh.mousemove && (eh.mousemove = em), rd.reset();
                let eA = !0 === er ? {
                        color: !0,
                        date: !0,
                        "datetime-local": !0,
                        email: !0,
                        month: !0,
                        number: !0,
                        range: !0,
                        search: !0,
                        tel: !0,
                        text: !0,
                        time: !0,
                        url: !0,
                        week: !0,
                        textarea: !0,
                        select: !0,
                        radio: !0,
                        checkbox: !0
                    } : void 0 !== en ? en : {},
                    eR = !0 === es || "all" === es ? {
                        script: !0,
                        comment: !0,
                        headFavicon: !0,
                        headWhitespace: !0,
                        headMetaSocial: !0,
                        headMetaRobots: !0,
                        headMetaHttpEquiv: !0,
                        headMetaVerification: !0,
                        headMetaAuthorship: "all" === es,
                        headMetaDescKeywords: "all" === es
                    } : es || {};
                ! function(m = window) {
                    "NodeList" in m && !m.NodeList.prototype.forEach && (m.NodeList.prototype.forEach = Array.prototype.forEach), "DOMTokenList" in m && !m.DOMTokenList.prototype.forEach && (m.DOMTokenList.prototype.forEach = Array.prototype.forEach), Node.prototype.contains || (Node.prototype.contains = (...m) => {
                        let _ = m[0];
                        if (!(0 in m)) throw TypeError("1 argument is required");
                        do
                            if (this === _) return !0; while (_ = _ && _.parentNode);
                        return !1
                    })
                }();
                let eP = 0,
                    eventProcessor = m => {
                        for (let _ of eE || []) _.eventProcessor && (m = _.eventProcessor(m));
                        return ep && !eT && (m = ep(m)), m
                    };
                eo = (m, B) => {
                    if (m.timestamp = rr(), _optionalChain([rc, "access", m => m[0], "optionalAccess", m => m.isFrozen, "call", m => m()]) && m.type !== ri.FullSnapshot && !(m.type === ri.IncrementalSnapshot && m.data.source === ro.Mutation) && rc.forEach(m => m.unfreeze()), eM) _optionalChain([C, "optionalCall", _ => _(eventProcessor(m), B)]);
                    else if (eT) {
                        let _ = {
                            type: "rrweb",
                            event: eventProcessor(m),
                            origin: window.location.origin,
                            isCheckout: B
                        };
                        window.parent.postMessage(_, "*")
                    }
                    if (m.type === ri.FullSnapshot) _ = m, eP = 0;
                    else if (m.type === ri.IncrementalSnapshot) {
                        if (m.data.source === ro.Mutation && m.data.isAttachIframe) return;
                        eP++;
                        let C = L && eP >= L,
                            B = R && _ && m.timestamp - _.timestamp > R;
                        (C || B) && takeFullSnapshot(!0)
                    }
                };
                let wrappedMutationEmit = m => {
                        eo({
                            type: ri.IncrementalSnapshot,
                            data: {
                                source: ro.Mutation,
                                ...m
                            }
                        })
                    },
                    wrappedScrollEmit = m => eo({
                        type: ri.IncrementalSnapshot,
                        data: {
                            source: ro.Scroll,
                            ...m
                        }
                    }),
                    wrappedCanvasMutationEmit = m => eo({
                        type: ri.IncrementalSnapshot,
                        data: {
                            source: ro.CanvasMutation,
                            ...m
                        }
                    }),
                    eD = new StylesheetManager({
                        mutationCb: wrappedMutationEmit,
                        adoptedStyleSheetCb: m => eo({
                            type: ri.IncrementalSnapshot,
                            data: {
                                source: ro.AdoptedStyleSheet,
                                ...m
                            }
                        })
                    }),
                    eL = "boolean" == typeof __RRWEB_EXCLUDE_IFRAME__ && __RRWEB_EXCLUDE_IFRAME__ ? new IframeManagerNoop : new IframeManager({
                        mirror: rd,
                        mutationCb: wrappedMutationEmit,
                        stylesheetManager: eD,
                        recordCrossOriginIframes: e_,
                        wrappedEmit: eo
                    });
                for (let m of eE || []) m.getMirror && m.getMirror({
                    nodeMirror: rd,
                    crossOriginIframeMirror: eL.crossOriginIframeMirror,
                    crossOriginIframeStyleMirror: eL.crossOriginIframeStyleMirror
                });
                let eN = new ProcessedNodeManager,
                    eB = function(m, _) {
                        try {
                            return m ? m(_) : new CanvasManagerNoop
                        } catch (m) {
                            return console.warn("Unable to initialize CanvasManager"), new CanvasManagerNoop
                        }
                    }(eC, {
                        mirror: rd,
                        win: window,
                        mutationCb: m => eo({
                            type: ri.IncrementalSnapshot,
                            data: {
                                source: ro.CanvasMutation,
                                ...m
                            }
                        }),
                        recordCanvas: ey,
                        blockClass: B,
                        blockSelector: F,
                        unblockSelector: U,
                        maxCanvasSize: ed,
                        sampling: eh.canvas,
                        dataURLOptions: ef,
                        errorHandler: eI
                    }),
                    ej = "boolean" == typeof __RRWEB_EXCLUDE_SHADOW_DOM__ && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new ShadowDomManagerNoop : new ShadowDomManager({
                        mutationCb: wrappedMutationEmit,
                        scrollCb: wrappedScrollEmit,
                        bypassOptions: {
                            onMutation: eO,
                            blockClass: B,
                            blockSelector: F,
                            unblockSelector: U,
                            maskAllText: V,
                            maskTextClass: X,
                            unmaskTextClass: K,
                            maskTextSelector: Y,
                            unmaskTextSelector: Q,
                            inlineStylesheet: et,
                            maskInputOptions: eA,
                            dataURLOptions: ef,
                            maskAttributeFn: ec,
                            maskTextFn: eu,
                            maskInputFn: el,
                            recordCanvas: ey,
                            inlineImages: ew,
                            sampling: eh,
                            slimDOMOptions: eR,
                            iframeManager: eL,
                            stylesheetManager: eD,
                            canvasManager: eB,
                            keepIframeSrcFn: ek,
                            processedNodeManager: eN
                        },
                        mirror: rd
                    }),
                    takeFullSnapshot = (m = !1) => {
                        if (!eg) return;
                        eo({
                            type: ri.Meta,
                            data: {
                                href: window.location.href,
                                width: getWindowWidth(),
                                height: getWindowHeight()
                            }
                        }, m), eD.reset(), ej.init(), rc.forEach(m => m.lock());
                        let _ = function(m, _) {
                            let {
                                mirror: C = new Mirror,
                                blockClass: R = "rr-block",
                                blockSelector: L = null,
                                unblockSelector: B = null,
                                maskAllText: F = !1,
                                maskTextClass: U = "rr-mask",
                                unmaskTextClass: H = null,
                                maskTextSelector: q = null,
                                unmaskTextSelector: V = null,
                                inlineStylesheet: X = !0,
                                inlineImages: K = !1,
                                recordCanvas: Y = !1,
                                maskAllInputs: Q = !1,
                                maskAttributeFn: et,
                                maskTextFn: er,
                                maskInputFn: en,
                                slimDOM: ei = !1,
                                dataURLOptions: eo,
                                preserveWhiteSpace: ea,
                                onSerialize: es,
                                onIframeLoad: ec,
                                iframeLoadTimeout: el,
                                onStylesheetLoad: eu,
                                stylesheetLoadTimeout: ed,
                                keepIframeSrcFn: ep = () => !1
                            } = _ || {}, eh = !0 === Q ? {
                                color: !0,
                                date: !0,
                                "datetime-local": !0,
                                email: !0,
                                month: !0,
                                number: !0,
                                range: !0,
                                search: !0,
                                tel: !0,
                                text: !0,
                                time: !0,
                                url: !0,
                                week: !0,
                                textarea: !0,
                                select: !0
                            } : !1 === Q ? {} : Q, ef = !0 === ei || "all" === ei ? {
                                script: !0,
                                comment: !0,
                                headFavicon: !0,
                                headWhitespace: !0,
                                headMetaDescKeywords: "all" === ei,
                                headMetaSocial: !0,
                                headMetaRobots: !0,
                                headMetaHttpEquiv: !0,
                                headMetaAuthorship: !0,
                                headMetaVerification: !0
                            } : !1 === ei ? {} : ei;
                            return serializeNodeWithId(m, {
                                doc: m,
                                mirror: C,
                                blockClass: R,
                                blockSelector: L,
                                unblockSelector: B,
                                maskAllText: F,
                                maskTextClass: U,
                                unmaskTextClass: H,
                                maskTextSelector: q,
                                unmaskTextSelector: V,
                                skipChild: !1,
                                inlineStylesheet: X,
                                maskInputOptions: eh,
                                maskAttributeFn: et,
                                maskTextFn: er,
                                maskInputFn: en,
                                slimDOMOptions: ef,
                                dataURLOptions: eo,
                                inlineImages: K,
                                recordCanvas: Y,
                                preserveWhiteSpace: ea,
                                onSerialize: es,
                                onIframeLoad: ec,
                                iframeLoadTimeout: el,
                                onStylesheetLoad: eu,
                                stylesheetLoadTimeout: ed,
                                keepIframeSrcFn: ep,
                                newlyAddedElement: !1
                            })
                        }(document, {
                            mirror: rd,
                            blockClass: B,
                            blockSelector: F,
                            unblockSelector: U,
                            maskAllText: V,
                            maskTextClass: X,
                            unmaskTextClass: K,
                            maskTextSelector: Y,
                            unmaskTextSelector: Q,
                            inlineStylesheet: et,
                            maskAllInputs: eA,
                            maskAttributeFn: ec,
                            maskInputFn: el,
                            maskTextFn: eu,
                            slimDOM: eR,
                            dataURLOptions: ef,
                            recordCanvas: ey,
                            inlineImages: ew,
                            onSerialize: m => {
                                isSerializedIframe(m, rd) && eL.addIframe(m), isSerializedStylesheet(m, rd) && eD.trackLinkElement(m), hasShadowRoot(m) && ej.addShadowRoot(m.shadowRoot, document)
                            },
                            onIframeLoad: (m, _) => {
                                eL.attachIframe(m, _), m.contentWindow && eB.addWindow(m.contentWindow), ej.observeAttachShadow(m)
                            },
                            onStylesheetLoad: (m, _) => {
                                eD.attachLinkElement(m, _)
                            },
                            keepIframeSrcFn: ek
                        });
                        if (!_) return console.warn("Failed to snapshot the document");
                        eo({
                            type: ri.FullSnapshot,
                            data: {
                                node: _,
                                initialOffset: getWindowScroll(window)
                            }
                        }), rc.forEach(m => m.unlock()), document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0 && eD.adoptStyleSheets(document.adoptedStyleSheets, rd.getId(document))
                    };
                ea = takeFullSnapshot;
                try {
                    let m = [],
                        observe = m => callbackWrapper(initObservers)({
                            onMutation: eO,
                            mutationCb: wrappedMutationEmit,
                            mousemoveCb: (m, _) => eo({
                                type: ri.IncrementalSnapshot,
                                data: {
                                    source: _,
                                    positions: m
                                }
                            }),
                            mouseInteractionCb: m => eo({
                                type: ri.IncrementalSnapshot,
                                data: {
                                    source: ro.MouseInteraction,
                                    ...m
                                }
                            }),
                            scrollCb: wrappedScrollEmit,
                            viewportResizeCb: m => eo({
                                type: ri.IncrementalSnapshot,
                                data: {
                                    source: ro.ViewportResize,
                                    ...m
                                }
                            }),
                            inputCb: m => eo({
                                type: ri.IncrementalSnapshot,
                                data: {
                                    source: ro.Input,
                                    ...m
                                }
                            }),
                            mediaInteractionCb: m => eo({
                                type: ri.IncrementalSnapshot,
                                data: {
                                    source: ro.MediaInteraction,
                                    ...m
                                }
                            }),
                            styleSheetRuleCb: m => eo({
                                type: ri.IncrementalSnapshot,
                                data: {
                                    source: ro.StyleSheetRule,
                                    ...m
                                }
                            }),
                            styleDeclarationCb: m => eo({
                                type: ri.IncrementalSnapshot,
                                data: {
                                    source: ro.StyleDeclaration,
                                    ...m
                                }
                            }),
                            canvasMutationCb: wrappedCanvasMutationEmit,
                            fontCb: m => eo({
                                type: ri.IncrementalSnapshot,
                                data: {
                                    source: ro.Font,
                                    ...m
                                }
                            }),
                            selectionCb: m => {
                                eo({
                                    type: ri.IncrementalSnapshot,
                                    data: {
                                        source: ro.Selection,
                                        ...m
                                    }
                                })
                            },
                            customElementCb: m => {
                                eo({
                                    type: ri.IncrementalSnapshot,
                                    data: {
                                        source: ro.CustomElement,
                                        ...m
                                    }
                                })
                            },
                            blockClass: B,
                            ignoreClass: H,
                            ignoreSelector: q,
                            maskAllText: V,
                            maskTextClass: X,
                            unmaskTextClass: K,
                            maskTextSelector: Y,
                            unmaskTextSelector: Q,
                            maskInputOptions: eA,
                            inlineStylesheet: et,
                            sampling: eh,
                            recordDOM: eg,
                            recordCanvas: ey,
                            inlineImages: ew,
                            userTriggeredOnInput: eb,
                            collectFonts: eS,
                            doc: m,
                            maskAttributeFn: ec,
                            maskInputFn: el,
                            maskTextFn: eu,
                            keepIframeSrcFn: ek,
                            blockSelector: F,
                            unblockSelector: U,
                            slimDOMOptions: eR,
                            dataURLOptions: ef,
                            mirror: rd,
                            iframeManager: eL,
                            stylesheetManager: eD,
                            shadowDomManager: ej,
                            processedNodeManager: eN,
                            canvasManager: eB,
                            ignoreCSSAttributes: ex,
                            plugins: _optionalChain([eE, "optionalAccess", m => m.filter, "call", m => m(m => m.observer), "optionalAccess", m => m.map, "call", m => m(m => ({
                                observer: m.observer,
                                options: m.options,
                                callback: _ => eo({
                                    type: ri.Plugin,
                                    data: {
                                        plugin: m.name,
                                        payload: _
                                    }
                                })
                            }))]) || []
                        }, {});
                    eL.addLoadListener(_ => {
                        try {
                            m.push(observe(_.contentDocument))
                        } catch (m) {
                            console.warn(m)
                        }
                    });
                    let init = () => {
                        takeFullSnapshot(), m.push(observe(document))
                    };
                    return "interactive" === document.readyState || "complete" === document.readyState ? init() : (m.push(on("DOMContentLoaded", () => {
                        eo({
                            type: ri.DomContentLoaded,
                            data: {}
                        }), "DOMContentLoaded" === ev && init()
                    })), m.push(on("load", () => {
                        eo({
                            type: ri.Load,
                            data: {}
                        }), "load" === ev && init()
                    }, window))), () => {
                        m.forEach(m => m()), eN.destroy(), ea = void 0, ei = void 0
                    }
                } catch (m) {
                    console.warn(m)
                }
            }
            record.mirror = rd, record.takeFullSnapshot = function(m) {
                if (!ea) throw Error("please take full snapshot after start recording");
                ea(m)
            };
            let rp = ["info", "warn", "error", "log"];

            function timestampToMs(m) {
                return m > 9999999999 ? m : 1e3 * m
            }

            function timestampToS(m) {
                return m > 9999999999 ? m / 1e3 : m
            }

            function addBreadcrumbEvent(m, _) {
                "sentry.transaction" !== _.category && (["ui.click", "ui.input"].includes(_.category) ? m.triggerUserActivity() : m.checkAndHandleExpiredSession(), m.addUpdate(() => (m.throttledAddEvent({
                    type: ri.Custom,
                    timestamp: 1e3 * (_.timestamp || 0),
                    data: {
                        tag: "breadcrumb",
                        payload: (0, eV.Fv)(_, 10, 1e3)
                    }
                }), "console" === _.category)))
            }

            function getClosestInteractive(m) {
                let _ = m.closest("button,a");
                return _ || m
            }

            function getClickTargetNode(m) {
                let _ = getTargetNode(m);
                return _ && _ instanceof Element ? getClosestInteractive(_) : _
            }

            function getTargetNode(m) {
                return "object" == typeof m && m && "target" in m ? m.target : m
            }(function() {
                let m = {
                    exception: () => void 0,
                    infoTick: () => void 0,
                    setConfig: m => {
                        m.captureExceptions, m.traceInternals
                    }
                };
                rp.forEach(_ => {
                    m[_] = () => void 0
                })
            })();
            let rh = new Set([ro.Mutation, ro.StyleSheetRule, ro.StyleDeclaration, ro.AdoptedStyleSheet, ro.CanvasMutation, ro.Selection, ro.MediaInteraction]);
            let ClickDetector = class ClickDetector {
                constructor(m, _, C = addBreadcrumbEvent) {
                    this._lastMutation = 0, this._lastScroll = 0, this._clicks = [], this._timeout = _.timeout / 1e3, this._threshold = _.threshold / 1e3, this._scollTimeout = _.scrollTimeout / 1e3, this._replay = m, this._ignoreSelector = _.ignoreSelector, this._addBreadcrumbEvent = C
                }
                addListeners() {
                    var m;
                    let _ = (m = () => {
                        this._lastMutation = nowInSeconds()
                    }, es || (es = [], (0, ex.hl)(tK, "open", function(m) {
                        return function(..._) {
                            if (es) try {
                                es.forEach(m => m())
                            } catch (m) {}
                            return m.apply(tK, _)
                        }
                    })), es.push(m), () => {
                        let _ = es ? es.indexOf(m) : -1;
                        _ > -1 && es.splice(_, 1)
                    });
                    this._teardown = () => {
                        _(), this._clicks = [], this._lastMutation = 0, this._lastScroll = 0
                    }
                }
                removeListeners() {
                    this._teardown && this._teardown(), this._checkClickTimeout && clearTimeout(this._checkClickTimeout)
                }
                handleClick(m, _) {
                    var C;
                    if (C = this._ignoreSelector, !rf.includes(_.tagName) || "INPUT" === _.tagName && !["submit", "button"].includes(_.getAttribute("type") || "") || "A" === _.tagName && (_.hasAttribute("download") || _.hasAttribute("target") && "_self" !== _.getAttribute("target")) || C && _.matches(C) || !(m.data && "number" == typeof m.data.nodeId && m.timestamp)) return;
                    let R = {
                        timestamp: timestampToS(m.timestamp),
                        clickBreadcrumb: m,
                        clickCount: 0,
                        node: _
                    };
                    this._clicks.some(m => m.node === R.node && 1 > Math.abs(m.timestamp - R.timestamp)) || (this._clicks.push(R), 1 === this._clicks.length && this._scheduleCheckClicks())
                }
                registerMutation(m = Date.now()) {
                    this._lastMutation = timestampToS(m)
                }
                registerScroll(m = Date.now()) {
                    this._lastScroll = timestampToS(m)
                }
                registerClick(m) {
                    let _ = getClosestInteractive(m);
                    this._handleMultiClick(_)
                }
                _handleMultiClick(m) {
                    this._getClicks(m).forEach(m => {
                        m.clickCount++
                    })
                }
                _getClicks(m) {
                    return this._clicks.filter(_ => _.node === m)
                }
                _checkClicks() {
                    let m = [],
                        _ = nowInSeconds();
                    for (let C of (this._clicks.forEach(C => {
                            !C.mutationAfter && this._lastMutation && (C.mutationAfter = C.timestamp <= this._lastMutation ? this._lastMutation - C.timestamp : void 0), !C.scrollAfter && this._lastScroll && (C.scrollAfter = C.timestamp <= this._lastScroll ? this._lastScroll - C.timestamp : void 0), C.timestamp + this._timeout <= _ && m.push(C)
                        }), m)) {
                        let m = this._clicks.indexOf(C);
                        m > -1 && (this._generateBreadcrumbs(C), this._clicks.splice(m, 1))
                    }
                    this._clicks.length && this._scheduleCheckClicks()
                }
                _generateBreadcrumbs(m) {
                    let _ = this._replay,
                        C = m.scrollAfter && m.scrollAfter <= this._scollTimeout,
                        R = m.mutationAfter && m.mutationAfter <= this._threshold,
                        {
                            clickCount: L,
                            clickBreadcrumb: B
                        } = m;
                    if (!C && !R) {
                        let C = 1e3 * Math.min(m.mutationAfter || this._timeout, this._timeout),
                            R = C < 1e3 * this._timeout ? "mutation" : "timeout",
                            F = {
                                type: "default",
                                message: B.message,
                                timestamp: B.timestamp,
                                category: "ui.slowClickDetected",
                                data: { ...B.data,
                                    url: tK.location.href,
                                    route: _.getCurrentRoute(),
                                    timeAfterClickMs: C,
                                    endReason: R,
                                    clickCount: L || 1
                                }
                            };
                        this._addBreadcrumbEvent(_, F);
                        return
                    }
                    if (L > 1) {
                        let m = {
                            type: "default",
                            message: B.message,
                            timestamp: B.timestamp,
                            category: "ui.multiClick",
                            data: { ...B.data,
                                url: tK.location.href,
                                route: _.getCurrentRoute(),
                                clickCount: L,
                                metric: !0
                            }
                        };
                        this._addBreadcrumbEvent(_, m)
                    }
                }
                _scheduleCheckClicks() {
                    this._checkClickTimeout && clearTimeout(this._checkClickTimeout), this._checkClickTimeout = getNativeImplementation_setTimeout(() => this._checkClicks(), 1e3)
                }
            };
            let rf = ["A", "BUTTON", "INPUT"];

            function nowInSeconds() {
                return Date.now() / 1e3
            }

            function createBreadcrumb(m) {
                return {
                    timestamp: Date.now() / 1e3,
                    type: "default",
                    ...m
                }
            }(eh = eg || (eg = {}))[eh.Document = 0] = "Document", eh[eh.DocumentType = 1] = "DocumentType", eh[eh.Element = 2] = "Element", eh[eh.Text = 3] = "Text", eh[eh.CDATA = 4] = "CDATA", eh[eh.Comment = 5] = "Comment";
            let rm = new Set(["id", "class", "aria-label", "role", "name", "alt", "title", "data-test-id", "data-testid", "disabled", "aria-disabled", "data-sentry-component"]),
                handleDomListener = m => _ => {
                    if (!m.isEnabled()) return;
                    let C = function(m) {
                        let {
                            target: _,
                            message: C
                        } = function(m) {
                            let _;
                            let C = "click" === m.name,
                                R = null;
                            try {
                                R = C ? getClickTargetNode(m.event) : getTargetNode(m.event), _ = (0, eY.Rt)(R, {
                                    maxStringLength: 200
                                }) || "<unknown>"
                            } catch (m) {
                                _ = "<unknown>"
                            }
                            return {
                                target: R,
                                message: _
                            }
                        }(m);
                        return createBreadcrumb({
                            category: `ui.${m.name}`,
                            ...getBaseDomBreadcrumb(_, C)
                        })
                    }(_);
                    if (!C) return;
                    let R = "click" === _.name,
                        L = R ? _.event : void 0;
                    R && m.clickDetector && L && L.target && !L.altKey && !L.metaKey && !L.ctrlKey && !L.shiftKey && function(m, _, C) {
                        m.handleClick(_, C)
                    }(m.clickDetector, C, getClickTargetNode(_.event)), addBreadcrumbEvent(m, C)
                };

            function getBaseDomBreadcrumb(m, _) {
                let C = record.mirror.getId(m),
                    R = C && record.mirror.getNode(C),
                    L = R && record.mirror.getMeta(R),
                    B = L && L.type === eg.Element ? L : null;
                return {
                    message: _,
                    data: B ? {
                        nodeId: C,
                        node: {
                            id: C,
                            tagName: B.tagName,
                            textContent: Array.from(B.childNodes).map(m => m.type === eg.Text && m.textContent).filter(Boolean).map(m => m.trim()).join(""),
                            attributes: function(m) {
                                let _ = {};
                                for (let C in !m["data-sentry-component"] && m["data-sentry-element"] && (m["data-sentry-component"] = m["data-sentry-element"]), m)
                                    if (rm.has(C)) {
                                        let R = C;
                                        ("data-testid" === C || "data-test-id" === C) && (R = "testId"), _[R] = m[C]
                                    }
                                return _
                            }(B.attributes)
                        }
                    } : {}
                }
            }
            let rg = {
                resource: function(m) {
                    let {
                        entryType: _,
                        initiatorType: C,
                        name: R,
                        responseEnd: L,
                        startTime: B,
                        decodedBodySize: F,
                        encodedBodySize: U,
                        responseStatus: H,
                        transferSize: q
                    } = m;
                    return ["fetch", "xmlhttprequest"].includes(C) ? null : {
                        type: `${_}.${C}`,
                        start: esm_getAbsoluteTime(B),
                        end: esm_getAbsoluteTime(L),
                        name: R,
                        data: {
                            size: q,
                            statusCode: H,
                            decodedBodySize: F,
                            encodedBodySize: U
                        }
                    }
                },
                paint: function(m) {
                    let {
                        duration: _,
                        entryType: C,
                        name: R,
                        startTime: L
                    } = m, B = esm_getAbsoluteTime(L);
                    return {
                        type: C,
                        name: R,
                        start: B,
                        end: B + _,
                        data: void 0
                    }
                },
                navigation: function(m) {
                    let {
                        entryType: _,
                        name: C,
                        decodedBodySize: R,
                        duration: L,
                        domComplete: B,
                        encodedBodySize: F,
                        domContentLoadedEventStart: U,
                        domContentLoadedEventEnd: H,
                        domInteractive: q,
                        loadEventStart: V,
                        loadEventEnd: X,
                        redirectCount: K,
                        startTime: Y,
                        transferSize: Q,
                        type: et
                    } = m;
                    return 0 === L ? null : {
                        type: `${_}.${et}`,
                        start: esm_getAbsoluteTime(Y),
                        end: esm_getAbsoluteTime(B),
                        name: C,
                        data: {
                            size: Q,
                            decodedBodySize: R,
                            encodedBodySize: F,
                            duration: L,
                            domInteractive: q,
                            domContentLoadedEventStart: U,
                            domContentLoadedEventEnd: H,
                            loadEventStart: V,
                            loadEventEnd: X,
                            domComplete: B,
                            redirectCount: K
                        }
                    }
                }
            };

            function webVitalHandler(m, _) {
                return ({
                    metric: C
                }) => void _.replayPerformanceEntries.push(m(C))
            }

            function createPerformanceEntry(m) {
                let _ = rg[m.entryType];
                return _ ? _(m) : null
            }

            function esm_getAbsoluteTime(m) {
                return ((eU.Z1 || tK.performance.timeOrigin) + m) / 1e3
            }

            function getLargestContentfulPaint(m) {
                let _ = m.entries[m.entries.length - 1],
                    C = _ && _.element ? [_.element] : void 0;
                return getWebVital(m, "largest-contentful-paint", C)
            }

            function getCumulativeLayoutShift(m) {
                let _ = [],
                    C = [];
                for (let R of m.entries)
                    if (void 0 !== R.sources) {
                        let m = [];
                        for (let _ of R.sources)
                            if (_.node) {
                                C.push(_.node);
                                let R = record.mirror.getId(_.node);
                                R && m.push(R)
                            }
                        _.push({
                            value: R.value,
                            nodeIds: m.length ? m : void 0
                        })
                    }
                return getWebVital(m, "cumulative-layout-shift", C, _)
            }

            function getFirstInputDelay(m) {
                let _ = m.entries[m.entries.length - 1],
                    C = _ && _.target ? [_.target] : void 0;
                return getWebVital(m, "first-input-delay", C)
            }

            function getInteractionToNextPaint(m) {
                let _ = m.entries[m.entries.length - 1],
                    C = _ && _.target ? [_.target] : void 0;
                return getWebVital(m, "interaction-to-next-paint", C)
            }

            function getWebVital(m, _, C, R) {
                let L = m.value,
                    B = m.rating,
                    F = esm_getAbsoluteTime(L);
                return {
                    type: "web-vital",
                    name: _,
                    start: F,
                    end: F,
                    data: {
                        value: L,
                        size: L,
                        rating: B,
                        nodeIds: C ? C.map(m => record.mirror.getId(m)) : void 0,
                        attributions: R
                    }
                }
            }
            let EventBufferSizeExceededError = class EventBufferSizeExceededError extends Error {
                constructor() {
                    super("Event buffer exceeded maximum size of 20000000.")
                }
            };
            let EventBufferArray = class EventBufferArray {
                constructor() {
                    this.events = [], this._totalSize = 0, this.hasCheckout = !1
                }
                get hasEvents() {
                    return this.events.length > 0
                }
                get type() {
                    return "sync"
                }
                destroy() {
                    this.events = []
                }
                async addEvent(m) {
                    let _ = JSON.stringify(m).length;
                    if (this._totalSize += _, this._totalSize > 2e7) throw new EventBufferSizeExceededError;
                    this.events.push(m)
                }
                finish() {
                    return new Promise(m => {
                        let _ = this.events;
                        this.clear(), m(JSON.stringify(_))
                    })
                }
                clear() {
                    this.events = [], this._totalSize = 0, this.hasCheckout = !1
                }
                getEarliestTimestamp() {
                    let m = this.events.map(m => m.timestamp).sort()[0];
                    return m ? timestampToMs(m) : null
                }
            };
            let WorkerHandler = class WorkerHandler {
                constructor(m) {
                    this._worker = m, this._id = 0
                }
                ensureReady() {
                    return this._ensureReadyPromise || (this._ensureReadyPromise = new Promise((m, _) => {
                        this._worker.addEventListener("message", ({
                            data: C
                        }) => {
                            C.success ? m() : _()
                        }, {
                            once: !0
                        }), this._worker.addEventListener("error", m => {
                            _(m)
                        }, {
                            once: !0
                        })
                    })), this._ensureReadyPromise
                }
                destroy() {
                    this._worker.terminate()
                }
                postMessage(m, _) {
                    let C = this._getAndIncrementId();
                    return new Promise((R, L) => {
                        let listener = ({
                            data: _
                        }) => {
                            if (_.method === m && _.id === C) {
                                if (this._worker.removeEventListener("message", listener), !_.success) {
                                    L(Error("Error in compression worker"));
                                    return
                                }
                                R(_.response)
                            }
                        };
                        this._worker.addEventListener("message", listener), this._worker.postMessage({
                            id: C,
                            method: m,
                            arg: _
                        })
                    })
                }
                _getAndIncrementId() {
                    return this._id++
                }
            };
            let EventBufferCompressionWorker = class EventBufferCompressionWorker {
                constructor(m) {
                    this._worker = new WorkerHandler(m), this._earliestTimestamp = null, this._totalSize = 0, this.hasCheckout = !1
                }
                get hasEvents() {
                    return !!this._earliestTimestamp
                }
                get type() {
                    return "worker"
                }
                ensureReady() {
                    return this._worker.ensureReady()
                }
                destroy() {
                    this._worker.destroy()
                }
                addEvent(m) {
                    let _ = timestampToMs(m.timestamp);
                    (!this._earliestTimestamp || _ < this._earliestTimestamp) && (this._earliestTimestamp = _);
                    let C = JSON.stringify(m);
                    return (this._totalSize += C.length, this._totalSize > 2e7) ? Promise.reject(new EventBufferSizeExceededError) : this._sendEventToWorker(C)
                }
                finish() {
                    return this._finishRequest()
                }
                clear() {
                    this._earliestTimestamp = null, this._totalSize = 0, this.hasCheckout = !1, this._worker.postMessage("clear").then(null, m => {})
                }
                getEarliestTimestamp() {
                    return this._earliestTimestamp
                }
                _sendEventToWorker(m) {
                    return this._worker.postMessage("addEvent", m)
                }
                async _finishRequest() {
                    let m = await this._worker.postMessage("finish");
                    return this._earliestTimestamp = null, this._totalSize = 0, m
                }
            };
            let EventBufferProxy = class EventBufferProxy {
                constructor(m) {
                    this._fallback = new EventBufferArray, this._compression = new EventBufferCompressionWorker(m), this._used = this._fallback, this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded()
                }
                get type() {
                    return this._used.type
                }
                get hasEvents() {
                    return this._used.hasEvents
                }
                get hasCheckout() {
                    return this._used.hasCheckout
                }
                set hasCheckout(m) {
                    this._used.hasCheckout = m
                }
                destroy() {
                    this._fallback.destroy(), this._compression.destroy()
                }
                clear() {
                    return this._used.clear()
                }
                getEarliestTimestamp() {
                    return this._used.getEarliestTimestamp()
                }
                addEvent(m) {
                    return this._used.addEvent(m)
                }
                async finish() {
                    return await this.ensureWorkerIsLoaded(), this._used.finish()
                }
                ensureWorkerIsLoaded() {
                    return this._ensureWorkerIsLoadedPromise
                }
                async _ensureWorkerIsLoaded() {
                    try {
                        await this._compression.ensureReady()
                    } catch (m) {
                        return
                    }
                    await this._switchToCompressionWorker()
                }
                async _switchToCompressionWorker() {
                    let {
                        events: m,
                        hasCheckout: _
                    } = this._fallback, C = [];
                    for (let _ of m) C.push(this._compression.addEvent(_));
                    this._compression.hasCheckout = _, this._used = this._compression;
                    try {
                        await Promise.all(C), this._fallback.clear()
                    } catch (m) {}
                }
            };

            function hasSessionStorage() {
                try {
                    return "sessionStorage" in tK && !!tK.sessionStorage
                } catch (m) {
                    return !1
                }
            }

            function isSampled(m) {
                return void 0 !== m && Math.random() < m
            }

            function makeSession(m) {
                let _ = Date.now(),
                    C = m.id || (0, eb.DM)(),
                    R = m.started || _,
                    L = m.lastActivity || _,
                    B = m.segmentId || 0,
                    F = m.sampled,
                    U = m.previousSessionId;
                return {
                    id: C,
                    started: R,
                    lastActivity: L,
                    segmentId: B,
                    sampled: F,
                    previousSessionId: U
                }
            }

            function saveSession(m) {
                if (hasSessionStorage()) try {
                    tK.sessionStorage.setItem(tZ, JSON.stringify(m))
                } catch (m) {}
            }

            function createSession({
                sessionSampleRate: m,
                allowBuffering: _,
                stickySession: C = !1
            }, {
                previousSessionId: R
            } = {}) {
                let L = isSampled(m) ? "session" : !!_ && "buffer",
                    B = makeSession({
                        sampled: L,
                        previousSessionId: R
                    });
                return C && saveSession(B), B
            }

            function isExpired(m, _, C = +new Date) {
                return null === m || void 0 === _ || _ < 0 || 0 !== _ && m + _ <= C
            }

            function isSessionExpired(m, {
                maxReplayDuration: _,
                sessionIdleExpire: C,
                targetTime: R = Date.now()
            }) {
                return isExpired(m.started, _, R) || isExpired(m.lastActivity, C, R)
            }

            function shouldRefreshSession(m, {
                sessionIdleExpire: _,
                maxReplayDuration: C
            }) {
                return !!isSessionExpired(m, {
                    sessionIdleExpire: _,
                    maxReplayDuration: C
                }) && ("buffer" !== m.sampled || 0 !== m.segmentId)
            }

            function loadOrCreateSession({
                sessionIdleExpire: m,
                maxReplayDuration: _,
                previousSessionId: C
            }, R) {
                let L = R.stickySession && function() {
                    if (!hasSessionStorage()) return null;
                    try {
                        let m = tK.sessionStorage.getItem(tZ);
                        if (!m) return null;
                        let _ = JSON.parse(m);
                        return makeSession(_)
                    } catch (m) {
                        return null
                    }
                }();
                return L ? shouldRefreshSession(L, {
                    sessionIdleExpire: m,
                    maxReplayDuration: _
                }) ? createSession(R, {
                    previousSessionId: L.id
                }) : L : createSession(R, {
                    previousSessionId: C
                })
            }

            function addEventSync(m, _, C) {
                return !!shouldAddEvent(m, _) && (_addEvent(m, _, C), !0)
            }
            async function _addEvent(m, _, C) {
                if (!m.eventBuffer) return null;
                try {
                    C && "buffer" === m.recordingMode && m.eventBuffer.clear(), C && (m.eventBuffer.hasCheckout = !0);
                    let R = m.getOptions(),
                        L = function(m, _) {
                            try {
                                if ("function" == typeof _ && m.type === ri.Custom) return _(m)
                            } catch (m) {
                                return null
                            }
                            return m
                        }(_, R.beforeAddRecordingEvent);
                    if (!L) return;
                    return await m.eventBuffer.addEvent(L)
                } catch (R) {
                    let _ = R && R instanceof EventBufferSizeExceededError ? "addEventSizeExceeded" : "addEvent";
                    m.handleException(R), await m.stop({
                        reason: _
                    });
                    let C = (0, eI.s3)();
                    C && C.recordDroppedEvent("internal_sdk_error", "replay")
                }
            }

            function shouldAddEvent(m, _) {
                if (!m.eventBuffer || m.isPaused() || !m.isEnabled()) return !1;
                let C = timestampToMs(_.timestamp);
                return !(C + m.timeouts.sessionIdlePause < Date.now()) && !(C > m.getContext().initialTimestamp + m.getOptions().maxReplayDuration)
            }

            function esm_isTransactionEvent(m) {
                return "transaction" === m.type
            }

            function isFeedbackEvent(m) {
                return "feedback" === m.type
            }

            function isBreadcrumbWithCategory(m) {
                return !!m.category
            }

            function createPerformanceSpans(m, _) {
                return _.map(({
                    type: _,
                    start: C,
                    end: R,
                    name: L,
                    data: B
                }) => {
                    let F = m.throttledAddEvent({
                        type: ri.Custom,
                        timestamp: C,
                        data: {
                            tag: "performanceSpan",
                            payload: {
                                op: _,
                                description: L,
                                startTimestamp: C,
                                endTimestamp: R,
                                data: B
                            }
                        }
                    });
                    return "string" == typeof F ? Promise.resolve(null) : F
                })
            }

            function addNetworkBreadcrumb(m, _) {
                m.isEnabled() && null !== _ && ! function(m, _) {
                    let C = _ && _.getDsn(),
                        R = _ && _.getOptions().tunnel;
                    return !!C && m.includes(C.host) || !!R && removeTrailingSlash(m) === removeTrailingSlash(R)
                }(_.name, (0, eI.s3)()) && m.addUpdate(() => (createPerformanceSpans(m, [_]), !0))
            }

            function getBodySize(m) {
                if (!m) return;
                let _ = new TextEncoder;
                try {
                    if ("string" == typeof m) return _.encode(m).length;
                    if (m instanceof URLSearchParams) return _.encode(m.toString()).length;
                    if (m instanceof FormData) {
                        let C = _serializeFormData(m);
                        return _.encode(C).length
                    }
                    if (m instanceof Blob) return m.size;
                    if (m instanceof ArrayBuffer) return m.byteLength
                } catch (m) {}
            }

            function parseContentLengthHeader(m) {
                if (!m) return;
                let _ = parseInt(m, 10);
                return isNaN(_) ? void 0 : _
            }

            function getBodyString(m) {
                try {
                    if ("string" == typeof m) return [m];
                    if (m instanceof URLSearchParams) return [m.toString()];
                    if (m instanceof FormData) return [_serializeFormData(m)];
                    if (!m) return [void 0]
                } catch (m) {
                    return [void 0, "BODY_PARSE_ERROR"]
                }
                return [void 0, "UNPARSEABLE_BODY_TYPE"]
            }

            function mergeWarning(m, _) {
                if (!m) return {
                    headers: {},
                    size: void 0,
                    _meta: {
                        warnings: [_]
                    }
                };
                let C = { ...m._meta
                    },
                    R = C.warnings || [];
                return C.warnings = [...R, _], m._meta = C, m
            }

            function makeNetworkReplayBreadcrumb(m, _) {
                if (!_) return null;
                let {
                    startTimestamp: C,
                    endTimestamp: R,
                    url: L,
                    method: B,
                    statusCode: F,
                    request: U,
                    response: H
                } = _, q = {
                    type: m,
                    start: C / 1e3,
                    end: R / 1e3,
                    name: L,
                    data: (0, ex.Jr)({
                        method: B,
                        statusCode: F,
                        request: U,
                        response: H
                    })
                };
                return q
            }

            function buildSkippedNetworkRequestOrResponse(m) {
                return {
                    headers: {},
                    size: m,
                    _meta: {
                        warnings: ["URL_SKIPPED"]
                    }
                }
            }

            function buildNetworkRequestOrResponse(m, _, C) {
                if (!_ && 0 === Object.keys(m).length) return;
                if (!_) return {
                    headers: m
                };
                if (!C) return {
                    headers: m,
                    size: _
                };
                let R = {
                        headers: m,
                        size: _
                    },
                    {
                        body: L,
                        warnings: B
                    } = function(m) {
                        if (!m || "string" != typeof m) return {
                            body: m
                        };
                        let _ = m.length > 15e4,
                            C = function(m) {
                                let _ = m[0],
                                    C = m[m.length - 1];
                                return "[" === _ && "]" === C || "{" === _ && "}" === C
                            }(m);
                        if (_) {
                            let _ = m.slice(0, 15e4);
                            return C ? {
                                body: _,
                                warnings: ["MAYBE_JSON_TRUNCATED"]
                            } : {
                                body: `${_}…`,
                                warnings: ["TEXT_TRUNCATED"]
                            }
                        }
                        if (C) try {
                            let _ = JSON.parse(m);
                            return {
                                body: _
                            }
                        } catch (m) {}
                        return {
                            body: m
                        }
                    }(C);
                return R.body = L, B && B.length > 0 && (R._meta = {
                    warnings: B
                }), R
            }

            function getAllowedHeaders(m, _) {
                return Object.entries(m).reduce((C, [R, L]) => {
                    let B = R.toLowerCase();
                    return _.includes(B) && m[R] && (C[B] = L), C
                }, {})
            }

            function _serializeFormData(m) {
                return new URLSearchParams(m).toString()
            }

            function urlMatches(m, _) {
                let C = function(m, _ = tK.document.baseURI) {
                    if (m.startsWith("http://") || m.startsWith("https://") || m.startsWith(tK.location.origin)) return m;
                    let C = new URL(m, _);
                    if (C.origin !== new URL(_).origin) return m;
                    let R = C.href;
                    return !m.endsWith("/") && R.endsWith("/") ? R.slice(0, -1) : R
                }(m);
                return (0, eS.U0)(C, _)
            }
            async function captureFetchBreadcrumbToReplay(m, _, C) {
                try {
                    let R = await _prepareFetchData(m, _, C),
                        L = makeNetworkReplayBreadcrumb("resource.fetch", R);
                    addNetworkBreadcrumb(C.replay, L)
                } catch (m) {}
            }
            async function _prepareFetchData(m, _, C) {
                let R = Date.now(),
                    {
                        startTimestamp: L = R,
                        endTimestamp: B = R
                    } = _,
                    {
                        url: F,
                        method: U,
                        status_code: H = 0,
                        request_body_size: q,
                        response_body_size: V
                    } = m.data,
                    X = urlMatches(F, C.networkDetailAllowUrls) && !urlMatches(F, C.networkDetailDenyUrls),
                    K = X ? function({
                        networkCaptureBodies: m,
                        networkRequestHeaders: _
                    }, C, R) {
                        let L = C ? 1 === C.length && "string" != typeof C[0] ? getHeadersFromOptions(C[0], _) : 2 === C.length ? getHeadersFromOptions(C[1], _) : {} : {};
                        if (!m) return buildNetworkRequestOrResponse(L, R, void 0);
                        let B = _getFetchRequestArgBody(C),
                            [F, U] = getBodyString(B),
                            H = buildNetworkRequestOrResponse(L, R, F);
                        return U ? mergeWarning(H, U) : H
                    }(C, _.input, q) : buildSkippedNetworkRequestOrResponse(q),
                    Y = await _getResponseInfo(X, C, _.response, V);
                return {
                    startTimestamp: L,
                    endTimestamp: B,
                    url: F,
                    method: U,
                    statusCode: H,
                    request: K,
                    response: Y
                }
            }
            async function _getResponseInfo(m, {
                networkCaptureBodies: _,
                networkResponseHeaders: C
            }, R, L) {
                if (!m && void 0 !== L) return buildSkippedNetworkRequestOrResponse(L);
                let B = R ? getAllHeaders(R.headers, C) : {};
                if (!R || !_ && void 0 !== L) return buildNetworkRequestOrResponse(B, L, void 0);
                let [F, U] = await _parseFetchResponseBody(R), H = function(m, {
                    networkCaptureBodies: _,
                    responseBodySize: C,
                    captureDetails: R,
                    headers: L
                }) {
                    try {
                        let B = m && m.length && void 0 === C ? getBodySize(m) : C;
                        if (!R) return buildSkippedNetworkRequestOrResponse(B);
                        if (_) return buildNetworkRequestOrResponse(L, B, m);
                        return buildNetworkRequestOrResponse(L, B, void 0)
                    } catch (m) {
                        return buildNetworkRequestOrResponse(L, C, void 0)
                    }
                }(F, {
                    networkCaptureBodies: _,
                    responseBodySize: L,
                    captureDetails: m,
                    headers: B
                });
                return U ? mergeWarning(H, U) : H
            }
            async function _parseFetchResponseBody(m) {
                let _ = function(m) {
                    try {
                        return m.clone()
                    } catch (m) {}
                }(m);
                if (!_) return [void 0, "BODY_PARSE_ERROR"];
                try {
                    let m = await new Promise((m, C) => {
                        let R = getNativeImplementation_setTimeout(() => C(Error("Timeout while trying to read response body")), 500);
                        _getResponseText(_).then(_ => m(_), m => C(m)).finally(() => clearTimeout(R))
                    });
                    return [m]
                } catch (m) {
                    return [void 0, "BODY_PARSE_ERROR"]
                }
            }

            function _getFetchRequestArgBody(m = []) {
                if (2 === m.length && "object" == typeof m[1]) return m[1].body
            }

            function getAllHeaders(m, _) {
                let C = {};
                return _.forEach(_ => {
                    m.get(_) && (C[_] = m.get(_))
                }), C
            }

            function getHeadersFromOptions(m, _) {
                if (!m) return {};
                let C = m.headers;
                return C ? C instanceof Headers ? getAllHeaders(C, _) : Array.isArray(C) ? {} : getAllowedHeaders(C, _) : {}
            }
            async function _getResponseText(m) {
                return await m.text()
            }
            async function captureXhrBreadcrumbToReplay(m, _, C) {
                try {
                    let R = function(m, _, C) {
                            let R = Date.now(),
                                {
                                    startTimestamp: L = R,
                                    endTimestamp: B = R,
                                    input: F,
                                    xhr: U
                                } = _,
                                {
                                    url: H,
                                    method: q,
                                    status_code: V = 0,
                                    request_body_size: X,
                                    response_body_size: K
                                } = m.data;
                            if (!H) return null;
                            if (!U || !urlMatches(H, C.networkDetailAllowUrls) || urlMatches(H, C.networkDetailDenyUrls)) {
                                let m = buildSkippedNetworkRequestOrResponse(X),
                                    _ = buildSkippedNetworkRequestOrResponse(K);
                                return {
                                    startTimestamp: L,
                                    endTimestamp: B,
                                    url: H,
                                    method: q,
                                    statusCode: V,
                                    request: m,
                                    response: _
                                }
                            }
                            let Y = U[eZ],
                                Q = Y ? getAllowedHeaders(Y.request_headers, C.networkRequestHeaders) : {},
                                et = getAllowedHeaders(function(m) {
                                    let _ = m.getAllResponseHeaders();
                                    return _ ? _.split("\r\n").reduce((m, _) => {
                                        let [C, R] = _.split(": ");
                                        return R && (m[C.toLowerCase()] = R), m
                                    }, {}) : {}
                                }(U), C.networkResponseHeaders),
                                [er, en] = C.networkCaptureBodies ? getBodyString(F) : [void 0],
                                [ei, eo] = C.networkCaptureBodies ? function(m) {
                                    let _ = [];
                                    try {
                                        return [m.responseText]
                                    } catch (m) {
                                        _.push(m)
                                    }
                                    try {
                                        return function(m, _) {
                                            try {
                                                if ("string" == typeof m) return [m];
                                                if (m instanceof Document) return [m.body.outerHTML];
                                                if ("json" === _ && m && "object" == typeof m) return [JSON.stringify(m)];
                                                if (!m) return [void 0]
                                            } catch (m) {
                                                return [void 0, "BODY_PARSE_ERROR"]
                                            }
                                            return [void 0, "UNPARSEABLE_BODY_TYPE"]
                                        }(m.response, m.responseType)
                                    } catch (m) {
                                        _.push(m)
                                    }
                                    return [void 0]
                                }(U) : [void 0],
                                ea = buildNetworkRequestOrResponse(Q, X, er),
                                es = buildNetworkRequestOrResponse(et, K, ei);
                            return {
                                startTimestamp: L,
                                endTimestamp: B,
                                url: H,
                                method: q,
                                statusCode: V,
                                request: en ? mergeWarning(ea, en) : ea,
                                response: eo ? mergeWarning(es, eo) : es
                            }
                        }(m, _, C),
                        L = makeNetworkReplayBreadcrumb("resource.xhr", R);
                    addNetworkBreadcrumb(C.replay, L)
                } catch (m) {}
            }
            async function addMemoryEntry(m) {
                try {
                    return Promise.all(createPerformanceSpans(m, [function(m) {
                        let {
                            jsHeapSizeLimit: _,
                            totalJSHeapSize: C,
                            usedJSHeapSize: R
                        } = m, L = Date.now() / 1e3;
                        return {
                            type: "memory",
                            name: "memory",
                            start: L,
                            end: L,
                            data: {
                                memory: {
                                    jsHeapSizeLimit: _,
                                    totalJSHeapSize: C,
                                    usedJSHeapSize: R
                                }
                            }
                        }
                    }(tK.performance.memory)]))
                } catch (m) {
                    return []
                }
            }
            async function prepareReplayEvent({
                client: m,
                scope: _,
                replayId: C,
                event: R
            }) {
                let L = "object" != typeof m._integrations || null === m._integrations || Array.isArray(m._integrations) ? void 0 : Object.keys(m._integrations),
                    B = {
                        event_id: C,
                        integrations: L
                    };
                m.emit("preprocessEvent", R, B);
                let F = await (0, eG.R)(m.getOptions(), R, B, _, m, (0, eI.aF)());
                if (!F) return null;
                F.platform = F.platform || "javascript";
                let U = m.getSdkMetadata(),
                    {
                        name: H,
                        version: q
                    } = U && U.sdk || {};
                return F.sdk = { ...F.sdk,
                    name: H || "sentry.javascript.unknown",
                    version: q || "0.0.0"
                }, F
            }
            async function sendReplayRequest({
                recordingData: m,
                replayId: _,
                segmentId: C,
                eventContext: R,
                timestamp: L,
                session: B
            }) {
                var F;
                let U;
                let H = function({
                        recordingData: m,
                        headers: _
                    }) {
                        let C;
                        let R = `${JSON.stringify(_)}
`;
                        if ("string" == typeof m) C = `${R}${m}`;
                        else {
                            let _ = new TextEncoder,
                                L = _.encode(R);
                            (C = new Uint8Array(L.length + m.length)).set(L), C.set(m, L.length)
                        }
                        return C
                    }({
                        recordingData: m,
                        headers: {
                            segment_id: C
                        }
                    }),
                    {
                        urls: q,
                        errorIds: V,
                        traceIds: X,
                        initialTimestamp: K
                    } = R,
                    Y = (0, eI.s3)(),
                    Q = (0, eI.nZ)(),
                    et = Y && Y.getTransport(),
                    er = Y && Y.getDsn();
                if (!Y || !et || !er || !B.sampled) return (0, ej.WD)({});
                let en = {
                        type: "replay_event",
                        replay_start_timestamp: K / 1e3,
                        timestamp: L / 1e3,
                        error_ids: V,
                        trace_ids: X,
                        urls: q,
                        replay_id: _,
                        segment_id: C,
                        replay_type: B.sampled
                    },
                    ei = await prepareReplayEvent({
                        scope: Q,
                        client: Y,
                        replayId: _,
                        event: en
                    });
                if (!ei) return Y.recordDroppedEvent("event_processor", "replay", en), (0, ej.WD)({});
                delete ei.sdkProcessingMetadata;
                let eo = (F = Y.getOptions().tunnel, (0, eF.Jd)((0, eF.Cd)(ei, (0, eF.HY)(ei), F, er), [
                    [{
                        type: "replay_event"
                    }, ei],
                    [{
                        type: "replay_recording",
                        length: "string" == typeof H ? new TextEncoder().encode(H).length : H.length
                    }, H]
                ]));
                try {
                    U = await et.send(eo)
                } catch (_) {
                    let m = Error(tY);
                    try {
                        m.cause = _
                    } catch (m) {}
                    throw m
                }
                if ("number" == typeof U.statusCode && (U.statusCode < 200 || U.statusCode >= 300)) throw new TransportStatusCodeError(U.statusCode);
                let ea = updateRateLimits({}, U);
                if (isRateLimited(ea, "replay")) throw new RateLimitError(ea);
                return U
            }
            let TransportStatusCodeError = class TransportStatusCodeError extends Error {
                constructor(m) {
                    super(`Transport returned status code ${m}`)
                }
            };
            let RateLimitError = class RateLimitError extends Error {
                constructor(m) {
                    super("Rate limit hit"), this.rateLimits = m
                }
            };
            async function sendReplay(m, _ = {
                count: 0,
                interval: 5e3
            }) {
                let {
                    recordingData: C,
                    onError: R
                } = m;
                if (C.length) try {
                    return await sendReplayRequest(m), !0
                } catch (C) {
                    if (C instanceof TransportStatusCodeError || C instanceof RateLimitError) throw C;
                    if ((0, e_.v)("Replays", {
                            _retryCount: _.count
                        }), R && R(C), _.count >= 3) {
                        let m = Error(`${tY} - max retries exceeded`);
                        try {
                            m.cause = C
                        } catch (m) {}
                        throw m
                    }
                    return _.interval *= ++_.count, new Promise((C, R) => {
                        getNativeImplementation_setTimeout(async () => {
                            try {
                                await sendReplay(m, _), C(!0)
                            } catch (m) {
                                R(m)
                            }
                        }, _.interval)
                    })
                }
            }
            let ry = "__THROTTLED";
            let ReplayContainer = class ReplayContainer {
                constructor({
                    options: m,
                    recordingOptions: _
                }) {
                    ReplayContainer.prototype.__init.call(this), ReplayContainer.prototype.__init2.call(this), ReplayContainer.prototype.__init3.call(this), ReplayContainer.prototype.__init4.call(this), ReplayContainer.prototype.__init5.call(this), ReplayContainer.prototype.__init6.call(this), this.eventBuffer = null, this.performanceEntries = [], this.replayPerformanceEntries = [], this.recordingMode = "session", this.timeouts = {
                        sessionIdlePause: 3e5,
                        sessionIdleExpire: 9e5
                    }, this._lastActivity = Date.now(), this._isEnabled = !1, this._isPaused = !1, this._requiresManualStart = !1, this._hasInitializedCoreListeners = !1, this._context = {
                        errorIds: new Set,
                        traceIds: new Set,
                        urls: [],
                        initialTimestamp: Date.now(),
                        initialUrl: ""
                    }, this._recordingOptions = _, this._options = m, this._debouncedFlush = function(m, _, C) {
                        let R, L, B;
                        let F = C && C.maxWait ? Math.max(C.maxWait, _) : 0;

                        function invokeFunc() {
                            return cancelTimers(), R = m()
                        }

                        function cancelTimers() {
                            void 0 !== L && clearTimeout(L), void 0 !== B && clearTimeout(B), L = B = void 0
                        }

                        function debounced() {
                            return L && clearTimeout(L), L = getNativeImplementation_setTimeout(invokeFunc, _), F && void 0 === B && (B = getNativeImplementation_setTimeout(invokeFunc, F)), R
                        }
                        return debounced.cancel = cancelTimers, debounced.flush = function() {
                            return void 0 !== L || void 0 !== B ? invokeFunc() : R
                        }, debounced
                    }(() => this._flush(), this._options.flushMinDelay, {
                        maxWait: this._options.flushMaxDelay
                    }), this._throttledAddEvent = function(m, _, C) {
                        let R = new Map,
                            _cleanup = m => {
                                let _ = m - 5;
                                R.forEach((m, C) => {
                                    C < _ && R.delete(C)
                                })
                            },
                            _getTotalCount = () => [...R.values()].reduce((m, _) => m + _, 0),
                            L = !1;
                        return (..._) => {
                            let C = Math.floor(Date.now() / 1e3);
                            if (_cleanup(C), _getTotalCount() >= 300) {
                                let m = L;
                                return L = !0, m ? "__SKIPPED" : ry
                            }
                            L = !1;
                            let B = R.get(C) || 0;
                            return R.set(C, B + 1), m(..._)
                        }
                    }((m, _) => shouldAddEvent(this, m) ? _addEvent(this, m, _) : Promise.resolve(null), 0, 0);
                    let {
                        slowClickTimeout: C,
                        slowClickIgnoreSelectors: R
                    } = this.getOptions(), L = C ? {
                        threshold: Math.min(3e3, C),
                        timeout: C,
                        scrollTimeout: 300,
                        ignoreSelector: R ? R.join(",") : ""
                    } : void 0;
                    L && (this.clickDetector = new ClickDetector(this, L))
                }
                getContext() {
                    return this._context
                }
                isEnabled() {
                    return this._isEnabled
                }
                isPaused() {
                    return this._isPaused
                }
                isRecordingCanvas() {
                    return !!this._canvas
                }
                getOptions() {
                    return this._options
                }
                handleException(m) {
                    this._options.onError && this._options.onError(m)
                }
                initializeSampling(m) {
                    let {
                        errorSampleRate: _,
                        sessionSampleRate: C
                    } = this._options, R = _ <= 0 && C <= 0;
                    this._requiresManualStart = R, !R && (this._initializeSessionForSampling(m), this.session) && !1 !== this.session.sampled && (this.recordingMode = "buffer" === this.session.sampled && 0 === this.session.segmentId ? "buffer" : "session", this._initializeRecording())
                }
                start() {
                    if (this._isEnabled && "session" === this.recordingMode || this._isEnabled && "buffer" === this.recordingMode) return;
                    this._updateUserActivity();
                    let m = loadOrCreateSession({
                        maxReplayDuration: this._options.maxReplayDuration,
                        sessionIdleExpire: this.timeouts.sessionIdleExpire
                    }, {
                        stickySession: this._options.stickySession,
                        sessionSampleRate: 1,
                        allowBuffering: !1
                    });
                    this.session = m, this._initializeRecording()
                }
                startBuffering() {
                    if (this._isEnabled) return;
                    let m = loadOrCreateSession({
                        sessionIdleExpire: this.timeouts.sessionIdleExpire,
                        maxReplayDuration: this._options.maxReplayDuration
                    }, {
                        stickySession: this._options.stickySession,
                        sessionSampleRate: 0,
                        allowBuffering: !0
                    });
                    this.session = m, this.recordingMode = "buffer", this._initializeRecording()
                }
                startRecording() {
                    try {
                        var m;
                        let _;
                        let C = this._canvas;
                        this._stopRecording = record({ ...this._recordingOptions,
                            ..."buffer" === this.recordingMode ? {
                                checkoutEveryNms: 6e4
                            } : this._options._experiments.continuousCheckout && {
                                checkoutEveryNms: Math.max(36e4, this._options._experiments.continuousCheckout)
                            },
                            emit: (m = this, _ = !1, (C, R) => {
                                if (!m.checkAndHandleExpiredSession()) return;
                                let L = R || !_;
                                _ = !0, m.clickDetector && function(m, _) {
                                    try {
                                        if (3 !== _.type) return;
                                        let {
                                            source: C
                                        } = _.data;
                                        if (rh.has(C) && m.registerMutation(_.timestamp), C === ro.Scroll && m.registerScroll(_.timestamp), _.data.source === ro.MouseInteraction) {
                                            let {
                                                type: C,
                                                id: R
                                            } = _.data, L = record.mirror.getNode(R);
                                            L instanceof HTMLElement && C === ra.Click && m.registerClick(L)
                                        }
                                    } catch (m) {}
                                }(m.clickDetector, C), m.addUpdate(() => {
                                    if ("buffer" === m.recordingMode && L && m.setInitialState(), !addEventSync(m, C, L)) return !0;
                                    if (!L) return !1;
                                    let _ = m.session;
                                    if (L && m.session && 0 === m.session.segmentId && addEventSync(m, function(m) {
                                            let _ = m.getOptions();
                                            return {
                                                type: ri.Custom,
                                                timestamp: Date.now(),
                                                data: {
                                                    tag: "options",
                                                    payload: {
                                                        shouldRecordCanvas: m.isRecordingCanvas(),
                                                        sessionSampleRate: _.sessionSampleRate,
                                                        errorSampleRate: _.errorSampleRate,
                                                        useCompressionOption: _.useCompression,
                                                        blockAllMedia: _.blockAllMedia,
                                                        maskAllText: _.maskAllText,
                                                        maskAllInputs: _.maskAllInputs,
                                                        useCompression: !!m.eventBuffer && "worker" === m.eventBuffer.type,
                                                        networkDetailHasUrls: _.networkDetailAllowUrls.length > 0,
                                                        networkCaptureBodies: _.networkCaptureBodies,
                                                        networkRequestHasHeaders: _.networkRequestHeaders.length > 0,
                                                        networkResponseHasHeaders: _.networkResponseHeaders.length > 0
                                                    }
                                                }
                                            }
                                        }(m), !1), _ && _.previousSessionId) return !0;
                                    if ("buffer" === m.recordingMode && _ && m.eventBuffer) {
                                        let C = m.eventBuffer.getEarliestTimestamp();
                                        C && (_.started = C, m.getOptions().stickySession && saveSession(_))
                                    }
                                    return "session" === m.recordingMode && m.flush(), !0
                                })
                            }),
                            onMutation: this._onMutationHandler,
                            ...C ? {
                                recordCanvas: C.recordCanvas,
                                getCanvasManager: C.getCanvasManager,
                                sampling: C.sampling,
                                dataURLOptions: C.dataURLOptions
                            } : {}
                        })
                    } catch (m) {
                        this.handleException(m)
                    }
                }
                stopRecording() {
                    try {
                        return this._stopRecording && (this._stopRecording(), this._stopRecording = void 0), !0
                    } catch (m) {
                        return this.handleException(m), !1
                    }
                }
                async stop({
                    forceFlush: m = !1,
                    reason: _
                } = {}) {
                    if (this._isEnabled) {
                        this._isEnabled = !1;
                        try {
                            (function() {
                                let m = (0, eI.nZ)().getPropagationContext().dsc;
                                m && delete m.replay_id;
                                let _ = (0, ti.HN)();
                                if (_) {
                                    let m = (0, e$.jC)(_);
                                    delete m.replay_id
                                }
                            })(), this._removeListeners(), this.stopRecording(), this._debouncedFlush.cancel(), m && await this._flush({
                                    force: !0
                                }), this.eventBuffer && this.eventBuffer.destroy(), this.eventBuffer = null,
                                function() {
                                    if (hasSessionStorage()) try {
                                        tK.sessionStorage.removeItem(tZ)
                                    } catch (m) {}
                                }(), this.session = void 0
                        } catch (m) {
                            this.handleException(m)
                        }
                    }
                }
                pause() {
                    this._isPaused || (this._isPaused = !0, this.stopRecording())
                }
                resume() {
                    this._isPaused && this._checkSession() && (this._isPaused = !1, this.startRecording())
                }
                async sendBufferedReplayOrFlush({
                    continueRecording: m = !0
                } = {}) {
                    if ("session" === this.recordingMode) return this.flushImmediate();
                    let _ = Date.now();
                    await this.flushImmediate();
                    let C = this.stopRecording();
                    m && C && "session" !== this.recordingMode && (this.recordingMode = "session", this.session && (this._updateUserActivity(_), this._updateSessionActivity(_), this._maybeSaveSession()), this.startRecording())
                }
                addUpdate(m) {
                    let _ = m();
                    "buffer" !== this.recordingMode && !0 !== _ && this._debouncedFlush()
                }
                triggerUserActivity() {
                    if (this._updateUserActivity(), !this._stopRecording) {
                        if (!this._checkSession()) return;
                        this.resume();
                        return
                    }
                    this.checkAndHandleExpiredSession(), this._updateSessionActivity()
                }
                updateUserActivity() {
                    this._updateUserActivity(), this._updateSessionActivity()
                }
                conditionalFlush() {
                    return "buffer" === this.recordingMode ? Promise.resolve() : this.flushImmediate()
                }
                flush() {
                    return this._debouncedFlush()
                }
                flushImmediate() {
                    return this._debouncedFlush(), this._debouncedFlush.flush()
                }
                cancelFlush() {
                    this._debouncedFlush.cancel()
                }
                getSessionId() {
                    return this.session && this.session.id
                }
                checkAndHandleExpiredSession() {
                    if (this._lastActivity && isExpired(this._lastActivity, this.timeouts.sessionIdlePause) && this.session && "session" === this.session.sampled) {
                        this.pause();
                        return
                    }
                    return !!this._checkSession()
                }
                setInitialState() {
                    let m = `${tK.location.pathname}${tK.location.hash}${tK.location.search}`,
                        _ = `${tK.location.origin}${m}`;
                    this.performanceEntries = [], this.replayPerformanceEntries = [], this._clearContext(), this._context.initialUrl = _, this._context.initialTimestamp = Date.now(), this._context.urls.push(_)
                }
                throttledAddEvent(m, _) {
                    let C = this._throttledAddEvent(m, _);
                    if (C === ry) {
                        let m = createBreadcrumb({
                            category: "replay.throttled"
                        });
                        this.addUpdate(() => !addEventSync(this, {
                            type: 5,
                            timestamp: m.timestamp || 0,
                            data: {
                                tag: "breadcrumb",
                                payload: m,
                                metric: !0
                            }
                        }))
                    }
                    return C
                }
                getCurrentRoute() {
                    let m = this.lastActiveSpan || (0, ti.HN)(),
                        _ = m && (0, ti.Gx)(m),
                        C = _ && (0, ti.XU)(_).data || {},
                        R = C[ta.Zj];
                    if (_ && R && ["route", "custom"].includes(R)) return (0, ti.XU)(_).description
                }
                _initializeRecording() {
                    this.setInitialState(), this._updateSessionActivity(), this.eventBuffer = function({
                        useCompression: m,
                        workerUrl: _
                    }) {
                        if (m && window.Worker) {
                            let m = function(m) {
                                try {
                                    let _ = m || ("undefined" != typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ && __SENTRY_EXCLUDE_REPLAY_WORKER__ ? "" : function() {
                                        let m = new Blob(['var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),a=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=function(t,e){for(var i=new n(31),a=0;a<31;++a)i[a]=e+=1<<t[a-1];var s=new r(i[30]);for(a=1;a<30;++a)for(var o=i[a];o<i[a+1];++o)s[o]=o-i[a]<<5|a;return{b:i,r:s}},o=s(e,2),f=o.b,h=o.r;f[28]=258,h[258]=28;for(var l=s(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,a=0,s=new n(r);a<i;++a)t[a]&&++s[t[a]-1];var o,f=new n(r);for(a=1;a<r;++a)f[a]=f[a-1]+s[a-1]<<1;if(e){o=new n(1<<r);var h=15-r;for(a=0;a<i;++a)if(t[a])for(var l=a<<4|t[a],c=r-t[a],v=f[t[a]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>h]=l}else for(o=new n(i),a=0;a<i;++a)t[a]&&(o[a]=u[f[t[a]-1]++]>>15-t[a]);return o},g=new t(288);for(c=0;c<144;++c)g[c]=8;for(c=144;c<256;++c)g[c]=9;for(c=256;c<280;++c)g[c]=7;for(c=280;c<288;++c)g[c]=8;var w=new t(32);for(c=0;c<32;++c)w[c]=5;var p=d(g,9,0),y=d(w,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==r||r<0)&&(r=0),(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},A=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},_=function(r,e){for(var i=[],a=0;a<r.length;++a)r[a]&&i.push({s:a,f:r[a]});var s=i.length,o=i.slice();if(!s)return{t:F,l:0};if(1==s){var f=new t(i[0].s+1);return f[i[0].s]=1,{t:f,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var h=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:h.f+l.f,l:h,r:l};c!=s-1;)h=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:h.f+l.f,l:h,r:l};var d=o[0].s;for(a=1;a<s;++a)o[a].s>d&&(d=o[a].s);var g=new n(d+1),w=x(i[c-1],g,0);if(w>e){a=0;var p=0,y=w-e,m=1<<y;for(o.sort((function(t,n){return g[n.s]-g[t.s]||t.f-n.f}));a<s;++a){var b=o[a].s;if(!(g[b]>e))break;p+=m-(1<<w-g[b]),g[b]=e}for(p>>=y;p>0;){var M=o[a].s;g[M]<e?p-=1<<e-g[M]++-1:++a}for(;a>=0&&p;--a){var E=o[a].s;g[E]==e&&(--g[E],++p)}w=e}return{t:new t(g),l:w}},x=function(t,n,r){return-1==t.s?Math.max(x(t.l,n,r+1),x(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,a=t[0],s=1,o=function(t){e[i++]=t},f=1;f<=r;++f)if(t[f]==a&&f!=r)++s;else{if(!a&&s>2){for(;s>138;s-=138)o(32754);s>2&&(o(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(o(a),--s;s>6;s-=6)o(8304);s>2&&(o(s-3<<5|8208),s=0)}for(;s--;)o(a);s=1,a=t[f]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var a=0;a<e;++a)t[i+a+4]=r[a];return 8*(i+4+e)},C=function(t,r,s,o,f,h,l,u,c,v,m){z(r,m++,s),++f[256];for(var b=_(f,15),M=b.t,E=b.l,x=_(h,15),C=x.t,U=x.l,F=D(M),I=F.c,S=F.n,L=D(C),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=_(q,7),H=G.t,J=G.l,K=19;K>4&&!H[a[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(f,g)+T(h,w)+l,X=T(f,M)+T(h,C)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(C,U,0),R=C;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[a[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=p,P=g,Q=y,R=w;for(B=0;B<u;++B){var rt=o[B];if(rt>255){A(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;A(r,m,Q[et]),m+=R[et],et>3&&(A(r,m,rt>>5&8191),m+=i[et])}else A(r,m,N[rt]),m+=P[rt]}return A(r,m,N[256]),m+P[256]},U=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}},L=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,a=0|r.length,s=0;s!=a;){for(var o=Math.min(s+2655,a);s<o;++s)i+=e+=r[s];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},O=function(a,s,o,f,u){if(!u&&(u={l:1},s.dictionary)){var c=s.dictionary.subarray(-32768),v=new t(c.length+a.length);v.set(c),v.set(a,c.length),a=v,u.w=c.length}return function(a,s,o,f,u,c){var v=c.z||a.length,d=new t(f+v+5*(1+Math.ceil(v/7e3))+u),g=d.subarray(f,d.length-u),w=c.l,p=7&(c.r||0);if(s){p&&(g[0]=c.r>>3);for(var y=U[s-1],M=y>>13,E=8191&y,z=(1<<o)-1,A=c.p||new n(32768),_=c.h||new n(z+1),x=Math.ceil(o/3),D=2*x,T=function(t){return(a[t]^a[t+1]<<x^a[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=_[H];if(A[J]=K,_[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!w)){p=C(a,g,0,F,I,S,O,q,G,j-G,p),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(a[j+Q]==a[j+Q-W]){for(var $=0;$<Z&&a[j+$]==a[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-A[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=A[J])&32767}if(R){F[q++]=268435456|h[Q]<<18|l[R];var it=31&h[Q],at=31&l[R];O+=e[it]+i[at],++I[257+it],++S[at],B=j+Q,++L}else F[q++]=a[j],++I[a[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=a[j],++I[a[j]];p=C(a,g,w,F,I,S,O,q,G,j-G,p),w||(c.r=7&p|g[p/8|0]<<3,p-=7,c.h=_,c.p=A,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+w;j+=65535){var st=j+65535;st>=v&&(g[p/8|0]=w,st=v),p=k(g,p+1,a.subarray(j,st))}c.i=v}return b(d,0,f+m(p)+u)}(a,null==s.level?6:s.level,null==s.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(a.length)))):12+s.mem,o,f,u)},j=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},q=function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&j(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}},B=function(t){return 10+(t.filename?t.filename.length+1:0)},G=function(){function n(n,r){if("function"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(O(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var a=this.b.length-this.s.z;a&&(this.b.set(n.subarray(0,a),this.s.z),this.s.z=this.b.length,this.p(this.b,!1)),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(a),32768),this.s.z=n.length-a+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n}();var H=function(){function t(t,n){this.c=L(),this.v=1,G.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),G.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=O(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=L();i.p(n.dictionary),j(t,2,i.d())}}(r,this.o),this.v=0),n&&j(r,r.length-4,this.c.d()),this.ondata(r,n)},t}(),J="undefined"!=typeof TextEncoder&&new TextEncoder,K="undefined"!=typeof TextDecoder&&new TextDecoder;try{K.decode(F,{stream:!0})}catch(t){}var N=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(P(t),this.d=n||!1)},t}();function P(n,r){if(r){for(var e=new t(n.length),i=0;i<n.length;++i)e[i]=n.charCodeAt(i);return e}if(J)return J.encode(n);var a=n.length,s=new t(n.length+(n.length>>1)),o=0,f=function(t){s[o++]=t};for(i=0;i<a;++i){if(o+5>s.length){var h=new t(o+8+(a-i<<1));h.set(s),s=h}var l=n.charCodeAt(i);l<128||r?f(l):l<2048?(f(192|l>>6),f(128|63&l)):l>55295&&l<57344?(f(240|(l=65536+(1047552&l)|1023&n.charCodeAt(++i))>>18),f(128|l>>12&63),f(128|l>>6&63),f(128|63&l)):(f(224|l>>12),f(128|l>>6&63),f(128|63&l))}return b(s,0,o)}function Q(t){return function(t,n){n||(n={});var r=S(),e=t.length;r.p(t);var i=O(t,n,B(n),8),a=i.length;return q(i,n),j(i,a-8,r.d()),j(i,a-4,e),i}(P(t))}const R=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error("Adding invalid event");const n=this._hasEvents?",":"";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push("]",!0);const t=function(t){let n=0;for(const r of t)n+=r.length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new H,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new N(((t,n)=>{this.deflate.push(t,n)})),this.stream.push("[")}},V={clear:()=>{R.clear()},addEvent:t=>R.addEvent(t),finish:()=>R.finish(),compress:t=>Q(t)};addEventListener("message",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in V&&"function"==typeof V[n])try{const t=V[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:"init",success:!0,response:void 0});']);
                                        return URL.createObjectURL(m)
                                    }());
                                    if (!_) return;
                                    let C = new Worker(_);
                                    return new EventBufferProxy(C)
                                } catch (m) {}
                            }(_);
                            if (m) return m
                        }
                        return new EventBufferArray
                    }({
                        useCompression: this._options.useCompression,
                        workerUrl: this._options.workerUrl
                    }), this._removeListeners(), this._addListeners(), this._isEnabled = !0, this._isPaused = !1, this.startRecording()
                }
                _initializeSessionForSampling(m) {
                    let _ = this._options.errorSampleRate > 0,
                        C = loadOrCreateSession({
                            sessionIdleExpire: this.timeouts.sessionIdleExpire,
                            maxReplayDuration: this._options.maxReplayDuration,
                            previousSessionId: m
                        }, {
                            stickySession: this._options.stickySession,
                            sessionSampleRate: this._options.sessionSampleRate,
                            allowBuffering: _
                        });
                    this.session = C
                }
                _checkSession() {
                    if (!this.session) return !1;
                    let m = this.session;
                    return !shouldRefreshSession(m, {
                        sessionIdleExpire: this.timeouts.sessionIdleExpire,
                        maxReplayDuration: this._options.maxReplayDuration
                    }) || (this._refreshSession(m), !1)
                }
                async _refreshSession(m) {
                    this._isEnabled && (await this.stop({
                        reason: "refresh session"
                    }), this.initializeSampling(m.id))
                }
                _addListeners() {
                    try {
                        tK.document.addEventListener("visibilitychange", this._handleVisibilityChange), tK.addEventListener("blur", this._handleWindowBlur), tK.addEventListener("focus", this._handleWindowFocus), tK.addEventListener("keydown", this._handleKeyboardEvent), this.clickDetector && this.clickDetector.addListeners(), this._hasInitializedCoreListeners || (function(m) {
                            let _ = (0, eI.s3)();
                            addClickKeypressInstrumentationHandler(handleDomListener(m)), addHistoryInstrumentationHandler(_ => {
                                    if (!m.isEnabled()) return;
                                    let C = function(m) {
                                        let {
                                            from: _,
                                            to: C
                                        } = m, R = Date.now() / 1e3;
                                        return {
                                            type: "navigation.push",
                                            start: R,
                                            end: R,
                                            name: C,
                                            data: {
                                                previous: _
                                            }
                                        }
                                    }(_);
                                    null !== C && (m.getContext().urls.push(C.name), m.triggerUserActivity(), m.addUpdate(() => (createPerformanceSpans(m, [C]), !1)))
                                }),
                                function(m) {
                                    let _ = (0, eI.s3)();
                                    _ && _.on("beforeAddBreadcrumb", _ => (function(m, _) {
                                        if (!m.isEnabled() || !isBreadcrumbWithCategory(_)) return;
                                        let C = !isBreadcrumbWithCategory(_) || ["fetch", "xhr", "sentry.event", "sentry.transaction"].includes(_.category) || _.category.startsWith("ui.") ? null : "console" === _.category ? function(m) {
                                            let _ = m.data && m.data.arguments;
                                            if (!Array.isArray(_) || 0 === _.length) return createBreadcrumb(m);
                                            let C = !1,
                                                R = _.map(m => {
                                                    if (!m) return m;
                                                    if ("string" == typeof m) return m.length > 5e3 ? (C = !0, `${m.slice(0,5e3)}…`) : m;
                                                    if ("object" == typeof m) try {
                                                        let _ = (0, eV.Fv)(m, 7),
                                                            R = JSON.stringify(_);
                                                        if (R.length > 5e3) return C = !0, `${JSON.stringify(_,null,2).slice(0,5e3)}…`;
                                                        return _
                                                    } catch (m) {}
                                                    return m
                                                });
                                            return createBreadcrumb({ ...m,
                                                data: { ...m.data,
                                                    arguments: R,
                                                    ...C ? {
                                                        _meta: {
                                                            warnings: ["CONSOLE_ARG_TRUNCATED"]
                                                        }
                                                    } : {}
                                                }
                                            })
                                        }(_) : createBreadcrumb(_);
                                        C && addBreadcrumbEvent(m, C)
                                    })(m, _))
                                }(m),
                                function(m) {
                                    let _ = (0, eI.s3)();
                                    try {
                                        let {
                                            networkDetailAllowUrls: C,
                                            networkDetailDenyUrls: R,
                                            networkCaptureBodies: L,
                                            networkRequestHeaders: B,
                                            networkResponseHeaders: F
                                        } = m.getOptions(), U = {
                                            replay: m,
                                            networkDetailAllowUrls: C,
                                            networkDetailDenyUrls: R,
                                            networkCaptureBodies: L,
                                            networkRequestHeaders: B,
                                            networkResponseHeaders: F
                                        };
                                        _ && _.on("beforeAddBreadcrumb", (m, _) => (function(m, _, C) {
                                            if (_.data) try {
                                                var R, L;
                                                "xhr" === _.category && (R = C) && R.xhr && (function(m, _) {
                                                    let {
                                                        xhr: C,
                                                        input: R
                                                    } = _;
                                                    if (!C) return;
                                                    let L = getBodySize(R),
                                                        B = C.getResponseHeader("content-length") ? parseContentLengthHeader(C.getResponseHeader("content-length")) : function(m, _) {
                                                            try {
                                                                let C = "json" === _ && m && "object" == typeof m ? JSON.stringify(m) : m;
                                                                return getBodySize(C)
                                                            } catch (m) {
                                                                return
                                                            }
                                                        }(C.response, C.responseType);
                                                    void 0 !== L && (m.data.request_body_size = L), void 0 !== B && (m.data.response_body_size = B)
                                                }(_, C), captureXhrBreadcrumbToReplay(_, C, m)), "fetch" === _.category && (L = C) && L.response && (function(m, _) {
                                                    let {
                                                        input: C,
                                                        response: R
                                                    } = _, L = C ? _getFetchRequestArgBody(C) : void 0, B = getBodySize(L), F = R ? parseContentLengthHeader(R.headers.get("content-length")) : void 0;
                                                    void 0 !== B && (m.data.request_body_size = B), void 0 !== F && (m.data.response_body_size = F)
                                                }(_, C), captureFetchBreadcrumbToReplay(_, C, m))
                                            } catch (m) {}
                                        })(U, m, _))
                                    } catch (m) {}
                                }(m);
                            let C = Object.assign((_, C) => {
                                if (!m.isEnabled() || m.isPaused()) return _;
                                if ("replay_event" === _.type) return delete _.breadcrumbs, _;
                                if (_.type && !esm_isTransactionEvent(_) && !isFeedbackEvent(_)) return _;
                                let R = m.checkAndHandleExpiredSession();
                                if (!R) return _;
                                if (isFeedbackEvent(_)) return m.flush(), _.contexts.feedback.replay_id = m.getSessionId(), m.triggerUserActivity(), m.addUpdate(() => !_.timestamp || (m.throttledAddEvent({
                                    type: ri.Custom,
                                    timestamp: 1e3 * _.timestamp,
                                    data: {
                                        tag: "breadcrumb",
                                        payload: {
                                            timestamp: _.timestamp,
                                            type: "default",
                                            category: "sentry.feedback",
                                            data: {
                                                feedbackId: _.event_id
                                            }
                                        }
                                    }
                                }), !1)), _;
                                if (!_.type && _.exception && _.exception.values && _.exception.values.length && C.originalException && C.originalException.__rrweb__ && !m.getOptions()._experiments.captureExceptions) return null;
                                let L = "buffer" === m.recordingMode && _.message !== tY && !!_.exception && !_.type && isSampled(m.getOptions().errorSampleRate),
                                    B = L || "session" === m.recordingMode;
                                return B && (_.tags = { ..._.tags,
                                    replayId: m.getSessionId()
                                }), _
                            }, {
                                id: "Replay"
                            });
                            (0, e_.Qy)(C), _ && (_.on("beforeSendEvent", _ => {
                                m.isEnabled() && !_.type && function(m, _) {
                                    let C = _.exception && _.exception.values && _.exception.values[0] && _.exception.values[0].value;
                                    if ("string" == typeof C && (C.match(/(reactjs\.org\/docs\/error-decoder\.html\?invariant=|react\.dev\/errors\/)(418|419|422|423|425)/) || C.match(/(does not match server-rendered HTML|Hydration failed because)/i))) {
                                        let _ = createBreadcrumb({
                                            category: "replay.hydrate-error",
                                            data: {
                                                url: (0, eY.l4)()
                                            }
                                        });
                                        addBreadcrumbEvent(m, _)
                                    }
                                }(m, _)
                            }), _.on("afterSendEvent", (_, C) => {
                                if (!m.isEnabled() || _.type && !esm_isTransactionEvent(_)) return;
                                let R = C && C.statusCode;
                                if (R && !(R < 200) && !(R >= 300)) {
                                    if (esm_isTransactionEvent(_)) {
                                        (function(m, _) {
                                            let C = m.getContext();
                                            _.contexts && _.contexts.trace && _.contexts.trace.trace_id && C.traceIds.size < 100 && C.traceIds.add(_.contexts.trace.trace_id)
                                        })(m, _);
                                        return
                                    }(function(m, _) {
                                        let C = m.getContext();
                                        if (_.event_id && C.errorIds.size < 100 && C.errorIds.add(_.event_id), "buffer" !== m.recordingMode || !_.tags || !_.tags.replayId) return;
                                        let {
                                            beforeErrorSampling: R
                                        } = m.getOptions();
                                        ("function" != typeof R || R(_)) && getNativeImplementation_setTimeout(async () => {
                                            try {
                                                await m.sendBufferedReplayOrFlush()
                                            } catch (_) {
                                                m.handleException(_)
                                            }
                                        })
                                    })(m, _)
                                }
                            }), _.on("createDsc", _ => {
                                let C = m.getSessionId();
                                if (C && m.isEnabled() && "session" === m.recordingMode) {
                                    let R = m.checkAndHandleExpiredSession();
                                    R && (_.replay_id = C)
                                }
                            }), _.on("spanStart", _ => {
                                m.lastActiveSpan = _
                            }), _.on("spanEnd", _ => {
                                m.lastActiveSpan = _
                            }), _.on("beforeSendFeedback", (_, C) => {
                                let R = m.getSessionId();
                                C && C.includeReplay && m.isEnabled() && R && _.contexts && _.contexts.feedback && (_.contexts.feedback.replay_id = R)
                            }))
                        }(this), this._hasInitializedCoreListeners = !0)
                    } catch (m) {
                        this.handleException(m)
                    }
                    this._performanceCleanupCallback = function(m) {
                        function addPerformanceEntry(_) {
                            m.performanceEntries.includes(_) || m.performanceEntries.push(_)
                        }

                        function onEntries({
                            entries: m
                        }) {
                            m.forEach(addPerformanceEntry)
                        }
                        let _ = [];
                        return ["navigation", "paint", "resource"].forEach(m => {
                            _.push(addPerformanceInstrumentationHandler(m, onEntries))
                        }), _.push(addLcpInstrumentationHandler(webVitalHandler(getLargestContentfulPaint, m)), addClsInstrumentationHandler(webVitalHandler(getCumulativeLayoutShift, m)), addFidInstrumentationHandler(webVitalHandler(getFirstInputDelay, m)), addInpInstrumentationHandler(webVitalHandler(getInteractionToNextPaint, m))), () => {
                            _.forEach(m => m())
                        }
                    }(this)
                }
                _removeListeners() {
                    try {
                        tK.document.removeEventListener("visibilitychange", this._handleVisibilityChange), tK.removeEventListener("blur", this._handleWindowBlur), tK.removeEventListener("focus", this._handleWindowFocus), tK.removeEventListener("keydown", this._handleKeyboardEvent), this.clickDetector && this.clickDetector.removeListeners(), this._performanceCleanupCallback && this._performanceCleanupCallback()
                    } catch (m) {
                        this.handleException(m)
                    }
                }
                __init() {
                    this._handleVisibilityChange = () => {
                        "visible" === tK.document.visibilityState ? this._doChangeToForegroundTasks() : this._doChangeToBackgroundTasks()
                    }
                }
                __init2() {
                    this._handleWindowBlur = () => {
                        let m = createBreadcrumb({
                            category: "ui.blur"
                        });
                        this._doChangeToBackgroundTasks(m)
                    }
                }
                __init3() {
                    this._handleWindowFocus = () => {
                        let m = createBreadcrumb({
                            category: "ui.focus"
                        });
                        this._doChangeToForegroundTasks(m)
                    }
                }
                __init4() {
                    this._handleKeyboardEvent = m => {
                        ! function(m, _) {
                            if (!m.isEnabled()) return;
                            m.updateUserActivity();
                            let C = function(m) {
                                var _;
                                let {
                                    metaKey: C,
                                    shiftKey: R,
                                    ctrlKey: L,
                                    altKey: B,
                                    key: F,
                                    target: U
                                } = m;
                                if (!U || "INPUT" === (_ = U).tagName || "TEXTAREA" === _.tagName || _.isContentEditable || !F) return null;
                                let H = 1 === F.length;
                                if (!(C || L || B) && H) return null;
                                let q = (0, eY.Rt)(U, {
                                        maxStringLength: 200
                                    }) || "<unknown>",
                                    V = getBaseDomBreadcrumb(U, q);
                                return createBreadcrumb({
                                    category: "ui.keyDown",
                                    message: q,
                                    data: { ...V.data,
                                        metaKey: C,
                                        shiftKey: R,
                                        ctrlKey: L,
                                        altKey: B,
                                        key: F
                                    }
                                })
                            }(_);
                            C && addBreadcrumbEvent(m, C)
                        }(this, m)
                    }
                }
                _doChangeToBackgroundTasks(m) {
                    if (!this.session) return;
                    let _ = isSessionExpired(this.session, {
                        maxReplayDuration: this._options.maxReplayDuration,
                        sessionIdleExpire: this.timeouts.sessionIdleExpire
                    });
                    _ || (m && this._createCustomBreadcrumb(m), this.conditionalFlush())
                }
                _doChangeToForegroundTasks(m) {
                    if (!this.session) return;
                    let _ = this.checkAndHandleExpiredSession();
                    _ && m && this._createCustomBreadcrumb(m)
                }
                _updateUserActivity(m = Date.now()) {
                    this._lastActivity = m
                }
                _updateSessionActivity(m = Date.now()) {
                    this.session && (this.session.lastActivity = m, this._maybeSaveSession())
                }
                _createCustomBreadcrumb(m) {
                    this.addUpdate(() => {
                        this.throttledAddEvent({
                            type: ri.Custom,
                            timestamp: m.timestamp || 0,
                            data: {
                                tag: "breadcrumb",
                                payload: m
                            }
                        })
                    })
                }
                _addPerformanceEntries() {
                    let m = this.performanceEntries.map(createPerformanceEntry).filter(Boolean).concat(this.replayPerformanceEntries);
                    return this.performanceEntries = [], this.replayPerformanceEntries = [], Promise.all(createPerformanceSpans(this, m))
                }
                _clearContext() {
                    this._context.errorIds.clear(), this._context.traceIds.clear(), this._context.urls = []
                }
                _updateInitialTimestampFromEventBuffer() {
                    let {
                        session: m,
                        eventBuffer: _
                    } = this;
                    if (!m || !_ || this._requiresManualStart || m.segmentId) return;
                    let C = _.getEarliestTimestamp();
                    C && C < this._context.initialTimestamp && (this._context.initialTimestamp = C)
                }
                _popEventContext() {
                    let m = {
                        initialTimestamp: this._context.initialTimestamp,
                        initialUrl: this._context.initialUrl,
                        errorIds: Array.from(this._context.errorIds),
                        traceIds: Array.from(this._context.traceIds),
                        urls: this._context.urls
                    };
                    return this._clearContext(), m
                }
                async _runFlush() {
                    let m = this.getSessionId();
                    if (this.session && this.eventBuffer && m && (await this._addPerformanceEntries(), this.eventBuffer && this.eventBuffer.hasEvents) && (await addMemoryEntry(this), this.eventBuffer && m === this.getSessionId())) try {
                        this._updateInitialTimestampFromEventBuffer();
                        let _ = Date.now();
                        if (_ - this._context.initialTimestamp > this._options.maxReplayDuration + 3e4) throw Error("Session is too long, not sending replay");
                        let C = this._popEventContext(),
                            R = this.session.segmentId++;
                        this._maybeSaveSession();
                        let L = await this.eventBuffer.finish();
                        await sendReplay({
                            replayId: m,
                            recordingData: L,
                            segmentId: R,
                            eventContext: C,
                            session: this.session,
                            timestamp: _,
                            onError: m => this.handleException(m)
                        })
                    } catch (_) {
                        this.handleException(_), this.stop({
                            reason: "sendReplay"
                        });
                        let m = (0, eI.s3)();
                        if (m) {
                            let C = _ instanceof RateLimitError ? "ratelimit_backoff" : "send_error";
                            m.recordDroppedEvent(C, "replay")
                        }
                    }
                }
                __init5() {
                    this._flush = async ({
                        force: m = !1
                    } = {}) => {
                        if (!this._isEnabled && !m || !this.checkAndHandleExpiredSession() || !this.session) return;
                        let _ = this.session.started,
                            C = Date.now(),
                            R = C - _;
                        this._debouncedFlush.cancel();
                        let L = R < this._options.minReplayDuration,
                            B = R > this._options.maxReplayDuration + 5e3;
                        if (L || B) {
                            L && this._debouncedFlush();
                            return
                        }
                        let F = this.eventBuffer;
                        F && 0 === this.session.segmentId && F.hasCheckout;
                        let U = !!this._flushLock;
                        this._flushLock || (this._flushLock = this._runFlush());
                        try {
                            await this._flushLock
                        } catch (m) {
                            this.handleException(m)
                        } finally {
                            this._flushLock = void 0, U && this._debouncedFlush()
                        }
                    }
                }
                _maybeSaveSession() {
                    this.session && this._options.stickySession && saveSession(this.session)
                }
                __init6() {
                    this._onMutationHandler = m => {
                        let _ = m.length,
                            C = this._options.mutationLimit,
                            R = this._options.mutationBreadcrumbLimit,
                            L = C && _ > C;
                        if (_ > R || L) {
                            let m = createBreadcrumb({
                                category: "replay.mutations",
                                data: {
                                    count: _,
                                    limit: L
                                }
                            });
                            this._createCustomBreadcrumb(m)
                        }
                        return !L || (this.stop({
                            reason: "mutationLimit",
                            forceFlush: "session" === this.recordingMode
                        }), !1)
                    }
                }
            };

            function getOption(m, _) {
                return [...m, ..._].join(",")
            }
            let r_ = 'img,image,svg,video,object,picture,embed,map,audio,link[rel="icon"],link[rel="apple-touch-icon"]',
                rv = ["content-length", "content-type", "accept"],
                rb = !1;
            let Replay = class Replay {
                static __initStatic() {
                    this.id = "Replay"
                }
                constructor({
                    flushMinDelay: m = 5e3,
                    flushMaxDelay: _ = 5500,
                    minReplayDuration: C = 4999,
                    maxReplayDuration: R = 36e5,
                    stickySession: L = !0,
                    useCompression: B = !0,
                    workerUrl: F,
                    _experiments: U = {},
                    maskAllText: H = !0,
                    maskAllInputs: q = !0,
                    blockAllMedia: V = !0,
                    mutationBreadcrumbLimit: X = 750,
                    mutationLimit: K = 1e4,
                    slowClickTimeout: Y = 7e3,
                    slowClickIgnoreSelectors: Q = [],
                    networkDetailAllowUrls: et = [],
                    networkDetailDenyUrls: er = [],
                    networkCaptureBodies: en = !0,
                    networkRequestHeaders: ei = [],
                    networkResponseHeaders: eo = [],
                    mask: ea = [],
                    maskAttributes: es = ["title", "placeholder"],
                    unmask: ec = [],
                    block: el = [],
                    unblock: eu = [],
                    ignore: ed = [],
                    maskFn: ep,
                    beforeAddRecordingEvent: eh,
                    beforeErrorSampling: ef
                } = {}) {
                    this.name = Replay.id;
                    let em = function({
                        mask: m,
                        unmask: _,
                        block: C,
                        unblock: R,
                        ignore: L
                    }) {
                        let B = getOption(m, [".sentry-mask", "[data-sentry-mask]"]),
                            F = getOption(_, []),
                            U = {
                                maskTextSelector: B,
                                unmaskTextSelector: F,
                                blockSelector: getOption(C, [".sentry-block", "[data-sentry-block]", 'base[href="/"]']),
                                unblockSelector: getOption(R, []),
                                ignoreSelector: getOption(L, [".sentry-ignore", "[data-sentry-ignore]", 'input[type="file"]'])
                            };
                        return U
                    }({
                        mask: ea,
                        unmask: ec,
                        block: el,
                        unblock: eu,
                        ignore: ed
                    });
                    if (this._recordingOptions = {
                            maskAllInputs: q,
                            maskAllText: H,
                            maskInputOptions: {
                                password: !0
                            },
                            maskTextFn: ep,
                            maskInputFn: ep,
                            maskAttributeFn: (m, _, C) => (function({
                                el: m,
                                key: _,
                                maskAttributes: C,
                                maskAllText: R,
                                privacyOptions: L,
                                value: B
                            }) {
                                return !R || L.unmaskTextSelector && m.matches(L.unmaskTextSelector) ? B : C.includes(_) || "value" === _ && "INPUT" === m.tagName && ["submit", "button"].includes(m.getAttribute("type") || "") ? B.replace(/[\S]/g, "*") : B
                            })({
                                maskAttributes: es,
                                maskAllText: H,
                                privacyOptions: em,
                                key: m,
                                value: _,
                                el: C
                            }),
                            ...em,
                            slimDOMOptions: "all",
                            inlineStylesheet: !0,
                            inlineImages: !1,
                            collectFonts: !0,
                            errorHandler: m => {
                                try {
                                    m.__rrweb__ = !0
                                } catch (m) {}
                            }
                        }, this._initialOptions = {
                            flushMinDelay: m,
                            flushMaxDelay: _,
                            minReplayDuration: Math.min(C, 15e3),
                            maxReplayDuration: Math.min(R, 36e5),
                            stickySession: L,
                            useCompression: B,
                            workerUrl: F,
                            blockAllMedia: V,
                            maskAllInputs: q,
                            maskAllText: H,
                            mutationBreadcrumbLimit: X,
                            mutationLimit: K,
                            slowClickTimeout: Y,
                            slowClickIgnoreSelectors: Q,
                            networkDetailAllowUrls: et,
                            networkDetailDenyUrls: er,
                            networkCaptureBodies: en,
                            networkRequestHeaders: _getMergedNetworkHeaders(ei),
                            networkResponseHeaders: _getMergedNetworkHeaders(eo),
                            beforeAddRecordingEvent: eh,
                            beforeErrorSampling: ef,
                            _experiments: U
                        }, this._initialOptions.blockAllMedia && (this._recordingOptions.blockSelector = this._recordingOptions.blockSelector ? `${this._recordingOptions.blockSelector},${r_}` : r_), this._isInitialized && isBrowser()) throw Error("Multiple Sentry Session Replay instances are not supported");
                    this._isInitialized = !0
                }
                get _isInitialized() {
                    return rb
                }
                set _isInitialized(m) {
                    rb = m
                }
                afterAllSetup(m) {
                    isBrowser() && !this._replay && (this._setup(m), this._initialize(m))
                }
                start() {
                    this._replay && this._replay.start()
                }
                startBuffering() {
                    this._replay && this._replay.startBuffering()
                }
                stop() {
                    return this._replay ? this._replay.stop({
                        forceFlush: "session" === this._replay.recordingMode
                    }) : Promise.resolve()
                }
                flush(m) {
                    return this._replay ? this._replay.isEnabled() ? this._replay.sendBufferedReplayOrFlush(m) : (this._replay.start(), Promise.resolve()) : Promise.resolve()
                }
                getReplayId() {
                    if (this._replay && this._replay.isEnabled()) return this._replay.getSessionId()
                }
                _initialize(m) {
                    this._replay && (this._maybeLoadFromReplayCanvasIntegration(m), this._replay.initializeSampling())
                }
                _setup(m) {
                    let _ = function(m, _) {
                        let C = _.getOptions(),
                            R = {
                                sessionSampleRate: 0,
                                errorSampleRate: 0,
                                ...(0, ex.Jr)(m)
                            },
                            L = (0, eq.o)(C.replaysSessionSampleRate),
                            B = (0, eq.o)(C.replaysOnErrorSampleRate);
                        return null == L && null == B && (0, ev.Cf)(() => {
                            console.warn("Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set.")
                        }), null != L && (R.sessionSampleRate = L), null != B && (R.errorSampleRate = B), R
                    }(this._initialOptions, m);
                    this._replay = new ReplayContainer({
                        options: _,
                        recordingOptions: this._recordingOptions
                    })
                }
                _maybeLoadFromReplayCanvasIntegration(m) {
                    try {
                        let _ = m.getIntegrationByName("ReplayCanvas");
                        if (!_) return;
                        this._replay._canvas = _.getOptions()
                    } catch (m) {}
                }
            };

            function _getMergedNetworkHeaders(m) {
                return [...rv, ...m.map(m => m.toLowerCase())]
            }
            Replay.__initStatic(), globalThis.__sentryRewritesTunnelPath__ = "/monitoring", globalThis.SENTRY_RELEASE = {
                    id: "d5f40a48738db6c0a07f12bbb3c7893b0ecba616"
                }, globalThis.__sentryBasePath = void 0, globalThis.__rewriteFramesAssetPrefixPath__ = "",
                function(m) {
                    let _ = {
                        environment: function(m) {
                            let _ = m ? tn.env.NEXT_PUBLIC_VERCEL_ENV : tn.env.VERCEL_ENV;
                            return _ ? `vercel-${_}` : void 0
                        }(!0) || "production",
                        defaultIntegrations: function(m) {
                            let _ = getDefaultIntegrations(m);
                            ("undefined" == typeof __SENTRY_TRACING__ || __SENTRY_TRACING__) && _.push(function(m = {}) {
                                let _ = browserTracingIntegration({ ...m,
                                        instrumentNavigation: !1,
                                        instrumentPageLoad: !1
                                    }),
                                    {
                                        instrumentPageLoad: C = !0,
                                        instrumentNavigation: R = !0
                                    } = m;
                                return { ..._,
                                    afterAllSetup(m) {
                                        R && function(m) {
                                            let _ = !eX.document.getElementById("__NEXT_DATA__");
                                            _ ? ! function(m) {
                                                let _;
                                                eX.addEventListener("popstate", () => {
                                                    _ && _.isRecording() ? _.updateName(eX.location.pathname) : _ = startBrowserTracingNavigationSpan(m, {
                                                        name: eX.location.pathname,
                                                        attributes: {
                                                            [ta.$J]: "navigation",
                                                            [ta.S3]: "auto.navigation.nextjs.app_router_instrumentation",
                                                            [ta.Zj]: "url",
                                                            "navigation.type": "browser.popstate"
                                                        }
                                                    })
                                                });
                                                let C = !1,
                                                    R = 0,
                                                    L = setInterval(() => {
                                                        var B;
                                                        R++;
                                                        let F = null != (B = _optionalChain([tW, "optionalAccess", m => m.next, "optionalAccess", m => m.router])) ? B : _optionalChain([tW, "optionalAccess", m => m.nd, "optionalAccess", m => m.router]);
                                                        C || R > 500 ? clearInterval(L) : F && (clearInterval(L), C = !0, ["back", "forward", "push", "replace"].forEach(C => {
                                                            _optionalChain([F, "optionalAccess", m => m[C]]) && (F[C] = new Proxy(F[C], {
                                                                apply(R, L, B) {
                                                                    let F = startBrowserTracingNavigationSpan(m, {
                                                                        name: tH,
                                                                        attributes: {
                                                                            [ta.$J]: "navigation",
                                                                            [ta.S3]: "auto.navigation.nextjs.app_router_instrumentation",
                                                                            [ta.Zj]: "url"
                                                                        }
                                                                    });
                                                                    return _ = F, "push" === C ? (_optionalChain([F, "optionalAccess", m => m.updateName, "call", m => m(transactionNameifyRouterArgument(B[0]))]), _optionalChain([F, "optionalAccess", m => m.setAttribute, "call", m => m("navigation.type", "router.push")])) : "replace" === C ? (_optionalChain([F, "optionalAccess", m => m.updateName, "call", m => m(transactionNameifyRouterArgument(B[0]))]), _optionalChain([F, "optionalAccess", m => m.setAttribute, "call", m => m("navigation.type", "router.replace")])) : "back" === C ? _optionalChain([F, "optionalAccess", m => m.setAttribute, "call", m => m("navigation.type", "router.back")]) : "forward" === C && _optionalChain([F, "optionalAccess", m => m.setAttribute, "call", m => m("navigation.type", "router.forward")]), R.apply(L, B)
                                                                }
                                                            }))
                                                        }))
                                                    }, 20)
                                            }(m) : tG.events.on("routeChangeStart", _ => {
                                                let C, R;
                                                let L = _.split(/[?#]/, 1)[0],
                                                    B = function(m) {
                                                        let _ = (eX.__BUILD_MANIFEST || {}).sortedPages;
                                                        if (_) return _.find(_ => {
                                                            let C = function(m) {
                                                                let _ = m.split("/"),
                                                                    C = "";
                                                                _optionalChain([_, "access", m => m[_.length - 1], "optionalAccess", m => m.match, "call", m => m(/^\[\[\.\.\..+\]\]$/)]) && (_.pop(), C = "(?:/(.+?))?");
                                                                let R = _.map(m => m.replace(/^\[\.\.\..+\]$/, "(.+?)").replace(/^\[.*\]$/, "([^/]+?)")).join("/");
                                                                return RegExp(`^${R}${C}(?:/)?$`)
                                                            }(_);
                                                            return m.match(C)
                                                        })
                                                    }(L);
                                                B ? (C = B, R = "route") : (C = L, R = "url"), startBrowserTracingNavigationSpan(m, {
                                                    name: C,
                                                    attributes: {
                                                        [ta.$J]: "navigation",
                                                        [ta.S3]: "auto.navigation.nextjs.pages_router_instrumentation",
                                                        [ta.Zj]: R
                                                    }
                                                })
                                            })
                                        }(m), _.afterAllSetup(m), C && function(m) {
                                            let _ = !eX.document.getElementById("__NEXT_DATA__");
                                            _ ? startBrowserTracingPageLoadSpan(m, {
                                                name: eX.location.pathname,
                                                startTime: eU.Z1 ? eU.Z1 / 1e3 : void 0,
                                                attributes: {
                                                    [ta.$J]: "pageload",
                                                    [ta.S3]: "auto.pageload.nextjs.app_router_instrumentation",
                                                    [ta.Zj]: "url"
                                                }
                                            }) : function(m) {
                                                let {
                                                    route: _,
                                                    params: C,
                                                    sentryTrace: R,
                                                    baggage: L
                                                } = function() {
                                                    let m;
                                                    let _ = eX.document.getElementById("__NEXT_DATA__");
                                                    if (_ && _.innerHTML) try {
                                                        m = JSON.parse(_.innerHTML)
                                                    } catch (m) {
                                                        tq.X && ev.kg.warn("Could not extract __NEXT_DATA__")
                                                    }
                                                    if (!m) return {};
                                                    let C = {},
                                                        {
                                                            page: R,
                                                            query: L,
                                                            props: B
                                                        } = m;
                                                    return C.route = R, C.params = L, B && B.pageProps && (C.sentryTrace = B.pageProps._sentryTraceData, C.baggage = B.pageProps._sentryBaggage), C
                                                }(), B = _ || eX.location.pathname;
                                                startBrowserTracingPageLoadSpan(m, {
                                                    name: B,
                                                    startTime: eU.Z1 ? eU.Z1 / 1e3 : void 0,
                                                    attributes: {
                                                        [ta.$J]: "pageload",
                                                        [ta.S3]: "auto.pageload.nextjs.pages_router_instrumentation",
                                                        [ta.Zj]: _ ? "route" : "url",
                                                        ...C && m.getOptions().sendDefaultPii && { ...C
                                                        }
                                                    }
                                                }, {
                                                    sentryTrace: R,
                                                    baggage: L
                                                })
                                            }(m)
                                        }(m)
                                    }
                                }
                            }());
                            let C = tJ.__rewriteFramesAssetPrefixPath__ || "";
                            return _.push(nextjsClientStackFrameNormalizationIntegration({
                                assetPrefixPath: C
                            })), _
                        }(m),
                        ...m
                    };
                    (function(m) {
                        let _ = tV.__sentryRewritesTunnelPath__;
                        if (_ && m.dsn) {
                            let C = (0, eN.U4)(m.dsn);
                            if (!C) return;
                            let R = C.host.match(/^o(\d+)\.ingest(?:\.([a-z]{2}))?\.sentry\.io$/);
                            if (R) {
                                let L = R[1],
                                    B = R[2],
                                    F = `${_}?o=${L}&p=${C.projectId}`;
                                B && (F += `&r=${B}`), m.tunnel = F, tq.X && ev.kg.info(`Tunneling events to "${F}"`)
                            } else tq.X && ev.kg.warn("Provided DSN is not a Sentry SaaS DSN. Will not tunnel events.")
                        }
                    })(_), applySdkMetadata(_, "nextjs", ["nextjs", "react"]),
                        function(m) {
                            let _ = { ...m
                            };
                            applySdkMetadata(_, "react"), (0, e_.v)("react", {
                                    version: tr.version
                                }),
                                function(m = {}) {
                                    let _ = function(m = {}) {
                                        let _ = {
                                            defaultIntegrations: getDefaultIntegrations(),
                                            release: "string" == typeof __SENTRY_RELEASE__ ? __SENTRY_RELEASE__ : eX.SENTRY_RELEASE && eX.SENTRY_RELEASE.id ? eX.SENTRY_RELEASE.id : void 0,
                                            autoSessionTracking: !0,
                                            sendClientReports: !0
                                        };
                                        return null == m.defaultIntegrations && delete m.defaultIntegrations, { ..._,
                                            ...m
                                        }
                                    }(m);
                                    if (function() {
                                            let m = void 0 !== eX.window && eX;
                                            if (!m) return !1;
                                            let _ = m.chrome ? "chrome" : "browser",
                                                C = m[_],
                                                R = C && C.runtime && C.runtime.id,
                                                L = eX.location && eX.location.href || "",
                                                B = !!R && eX === eX.top && ["chrome-extension:", "moz-extension:", "ms-browser-extension:", "safari-web-extension:"].some(m => L.startsWith(`${m}//`)),
                                                F = void 0 !== m.nw;
                                            return !!R && !B && !F
                                        }()) {
                                        (0, ev.Cf)(() => {
                                            console.error("[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/")
                                        });
                                        return
                                    }
                                    let C = { ..._,
                                        stackParser: (0, eC.Sq)(_.stackParser || te),
                                        integrations: function(m) {
                                            let _;
                                            let C = m.defaultIntegrations || [],
                                                R = m.integrations;
                                            C.forEach(m => {
                                                m.isDefaultInstance = !0
                                            }), _ = Array.isArray(R) ? [...C, ...R] : "function" == typeof R ? (0, eb.lE)(R(C)) : C;
                                            let L = function(m) {
                                                    let _ = {};
                                                    return m.forEach(m => {
                                                        let {
                                                            name: C
                                                        } = m, R = _[C];
                                                        R && !R.isDefaultInstance && m.isDefaultInstance || (_[C] = m)
                                                    }), Object.values(_)
                                                }(_),
                                                B = L.findIndex(m => "Debug" === m.name);
                                            if (B > -1) {
                                                let [m] = L.splice(B, 1);
                                                L.push(m)
                                            }
                                            return L
                                        }(_),
                                        transport: _.transport || makeFetchTransport
                                    };
                                    (function(m, _) {
                                        !0 === _.debug && (ew.X ? ev.kg.enable() : (0, ev.Cf)(() => {
                                            console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.")
                                        }));
                                        let C = (0, eI.nZ)();
                                        C.update(_.initialScope);
                                        let R = new m(_);
                                        (0, eI.nZ)().setClient(R), R.init()
                                    })(BrowserClient, C), _.autoSessionTracking && void 0 !== eX.document && ((0, e_.yj)({
                                        ignoreDuration: !0
                                    }), (0, e_.cg)(), addHistoryInstrumentationHandler(({
                                        from: m,
                                        to: _
                                    }) => {
                                        void 0 !== m && m !== _ && ((0, e_.yj)({
                                            ignoreDuration: !0
                                        }), (0, e_.cg)())
                                    }))
                                }(_)
                        }(_);
                    let filterTransactions = m => "transaction" === m.type && "/404" === m.transaction ? null : m;
                    filterTransactions.id = "NextClient404Filter", (0, e_.Qy)(filterTransactions);
                    let filterIncompleteNavigationTransactions = m => "transaction" === m.type && m.transaction === tH ? null : m;
                    filterIncompleteNavigationTransactions.id = "IncompleteTransactionFilter", (0, e_.Qy)(filterIncompleteNavigationTransactions)
                }({
                    dsn: "https://96cd2ecfae2ef16c7727bed1a3db75e4@o4507852651954176.ingest.de.sentry.io/4508136210169936",
                    integrations: [(ef = {
                        maskAllText: !1,
                        blockAllMedia: !1,
                        maskAllInputs: !1,
                        networkDetailAllowUrls: [window.location.origin, "https://api.bloxflip.com", "https://ws.bloxflip.com"]
                    }, new Replay(ef))],
                    tracePropagationTargets: ["api.bloxflip.com", "ws.bloxflip.com", "localhost"],
                    tracesSampleRate: .01,
                    replaysSessionSampleRate: .01,
                    replaysOnErrorSampleRate: .5,
                    debug: !1
                })
        },
        4595: function(m, _, C) {
            "use strict";
            C.d(_, {
                Z: function() {
                    return Button
                }
            });
            var R = C(85893),
                L = C(93967),
                B = C.n(L),
                F = C(67294),
                U = C(63811),
                H = C.n(U);

            function Button(m) {
                let {
                    children: _,
                    variant: C = "default",
                    isActive: L = !1,
                    as: U,
                    className: q,
                    ...V
                } = m, X = U || "button", [K, Y] = (0, F.useState)(!1);
                return (0, R.jsx)(R.Fragment, {
                    children: (0, R.jsx)(X, {
                        className: B()(H().button, H()[C], L && H().isActive, q, K && H().clicked),
                        ...V,
                        onMouseDown: () => Y(!0),
                        onMouseUp: () => Y(!1),
                        onMouseOut: () => Y(!1),
                        "data-sentry-element": "TagName",
                        "data-sentry-source-file": "button.tsx",
                        children: _
                    })
                })
            }
        },
        30931: function(m, _, C) {
            "use strict";
            C.r(_), C.d(_, {
                ACCESS_KEY_TIKTOK: function() {
                    return ed
                },
                default: function() {
                    return _app
                },
                growthbook: function() {
                    return ep
                }
            });
            var R = C(85893);
            C(12732);
            var L = C(67294);
            C(91326), C(34385), C(24106);
            var B = C(49089),
                F = C(11163),
                U = C(25074),
                H = C(27243);
            C(83079);
            var q = C(2181),
                V = C(62961),
                X = C(54847),
                K = C(52969),
                Y = C.n(K),
                Q = C(4595);
            let ErrorContent = m => {
                let {
                    message: _,
                    title: C
                } = m;
                return (0, R.jsxs)("div", {
                    className: Y().errorPage,
                    "data-sentry-component": "ErrorContent",
                    "data-sentry-source-file": "ErrorDom.tsx",
                    children: [(0, R.jsx)("h1", {
                        children: null != C ? C : "Site under maintenance"
                    }), (0, R.jsx)("p", {
                        children: null != _ ? _ : "We're sorry! Site under maintenance. We'll be back soon! Thank you for your patience."
                    }), (0, R.jsx)("br", {}), (0, R.jsx)("br", {}), (0, R.jsx)(Q.Z, {
                        variant: "primary",
                        onClick: () => location.reload(),
                        "data-sentry-element": "Button",
                        "data-sentry-source-file": "ErrorDom.tsx",
                        children: "Try again?"
                    })]
                })
            };
            let ErrorBoundary = class ErrorBoundary extends L.Component {
                static getDerivedStateFromError(m) {
                    return {
                        hasError: !0
                    }
                }
                componentDidCatch(m, _) {
                    console.log({
                        error: m,
                        errorInfo: _
                    })
                }
                render() {
                    return this.state.hasError ? (0, R.jsx)(ErrorContent, {
                        title: "Oops, something went wrong",
                        message: "There are technical issues. Our team working on fix. Apologies for inconvenience.",
                        "data-sentry-element": "ErrorContent",
                        "data-sentry-component": "ErrorBoundary",
                        "data-sentry-source-file": "index.tsx"
                    }) : this.props.children
                }
                constructor(m) {
                    super(m), this.state = {
                        hasError: !1
                    }
                }
            };
            var et = C(27188),
                er = C.n(et),
                en = C(93967),
                ei = C.n(en);
            let LoadingScreen = m => {
                var _;
                return (0, R.jsx)("div", { ...m,
                    className: ei()(er().loaderScreen, null !== (_ = m.className) && void 0 !== _ ? _ : null),
                    "data-sentry-component": "LoadingScreen",
                    "data-sentry-source-file": "LoaderScreen.tsx",
                    children: (0, R.jsx)("div", {
                        className: er().loaderScreenCenter,
                        children: (0, R.jsx)("img", {
                            src: "/logotype.svg",
                            alt: "bloxflip logo"
                        })
                    })
                })
            };
            var eo = C(6428),
                ea = C(81361);
            let nanoid = (m = 21) => crypto.getRandomValues(new Uint8Array(m)).reduce((m, _) => ((_ &= 63) < 36 ? m += _.toString(36) : _ < 62 ? m += (_ - 26).toString(36).toUpperCase() : _ > 62 ? m += "-" : m += "_", m), ""),
                paseLinkQueries = m => {
                    let _ = new URLSearchParams(null != m ? m : window.location.search),
                        C = Object.fromEntries(_.entries());
                    return C
                };
            var es = C(86501),
                ec = C(83198),
                el = C(25387),
                eu = C(38178);
            let ed = "ea70247f8e7befdbf58568f6594c556306c99618",
                ep = new ea.Gr({
                    apiHost: "https://cdn.growthbook.io",
                    clientKey: "key_prod_559ede01dcb3b310",
                    trackingCallback: (m, _) => {
                        console.log({
                            experimentId: m.key,
                            variationId: _.variationId
                        })
                    }
                });
            el.d.configure();
            var _app = function(m) {
                let {
                    Component: _,
                    pageProps: C
                } = m, K = (0, F.useRouter)(), Y = (0, eo.Z)(), [Q, et] = (0, L.useState)(!1), [er, en] = (0, L.useState)(!1), updateIpAddress = async () => {
                    try {
                        let m = await (0, q.I_R)();
                        if (!m || !("ip" in m)) throw Error("no ip address");
                        window.ipAddress = m.ip, X.Z && X.Z.dispatch({
                            type: V.QU,
                            payload: m.ip
                        })
                    } catch (m) {
                        console.log(m)
                    }
                }, handleGrowBook = async () => {
                    try {
                        await ep.loadFeatures();
                        let m = localStorage.getItem("visitorId");
                        m || (m = nanoid(), localStorage.setItem("visitorId", m));
                        let _ = !!X.Z.getState().auth.user;
                        ep.setAttributes({
                            id: m,
                            loggedIn: _,
                            url: document.location.href
                        })
                    } catch (m) {
                        console.log(m)
                    }
                }, handleParams = async () => {
                    try {
                        let m = paseLinkQueries();
                        if (m && "id" in m) {
                            let _ = String(m.id).match(/^[0-9]+$/g) && "string" == typeof m.id ? parseInt(m.id) : m.id,
                                C = await (0, q.st5)(_);
                            if (C && (null == C ? void 0 : C.success)) {
                                let m = new URLSearchParams(window.location.search);
                                (m = new URLSearchParams(Object.fromEntries(m.entries()))).delete("id");
                                let _ = m.toString();
                                es.Am.success("Thank you very much for the payment! The FlipCoins have been credited to your account!"), K.replace({
                                    pathname: K.pathname,
                                    query: _
                                }, void 0, {
                                    shallow: !0
                                })
                            }
                        }
                    } catch (m) {
                        console.log(m)
                    }
                }, handleHashs = () => {
                    let m = location.hash.trim();
                    m.includes("#giveaway") && X.Z.dispatch({
                        type: V.IP
                    })
                };
                (0, L.useEffect)(() => {
                    let handleRouteChange = m => {
                        console.log("routing to " + m), ep.getFeatures().fe_ga_enabled && B.ZP.send({
                            hitType: "pageview",
                            page: location.pathname + location.search
                        }), ep.getFeatures().fe_mixpanel_enabled && ec.Z.track("pageview", {
                            page: location.pathname + location.search
                        })
                    };
                    return K.events.on("routeChangeComplete", handleRouteChange), () => {
                        K.events.off("routeChangeComplete", handleRouteChange)
                    }
                }, [K.events]), (0, L.useEffect)(() => {
                    navigator.serviceWorker && navigator.serviceWorker.register("".concat(self.origin, "/OneSignalSDKWorker.js")).then(m => console.log(m)).catch(m => console.log(m))
                }, []), (0, L.useEffect)(() => {
                    (0, eu.aG)(), handleHashs(), handleGrowBook(), updateIpAddress(), handleParams(), U.Z.init({
                        appId: "c8fbda32-4568-4342-9ac1-2a9f5c996546"
                    }).then(async () => {
                        et(!0), await Promise.race([U.Z.isPushNotificationsEnabled, () => new Promise(m => setTimeout(() => m(!0), 1e3))].map(m => m())), U.Z.showSlidedownPrompt().then(() => {
                            console.log("one signal prompted")
                        })
                    });
                    let handleRouteChange = () => {
                        ep.getFeatures().fe_ga_enabled && console.log("ga4 !!up")
                    };
                    return K.events.on("routeChangeComplete", handleRouteChange), (0, q.vK9)(), sessionStorage.setItem("timeJoined", new Date().getTime().toString()), H.Z.init(3100154, 6), ec.Z.init("0c9266b8cede669e4a7bd3bfb2c8e6e4"), B.ZP.initialize("G-7QWC8W9ECE"), B.ZP.ga(m => {
                            window.ga4ClientId = m.get("clientId")
                        }), window.intercomSettings = {
                            api_base: "https://api-iam.intercom.io",
                            app_id: "ze033am6"
                        },
                        function() {
                            let m = window,
                                _ = m.Intercom;
                            if ("function" == typeof _) _("reattach_activator"), _("update", m.intercomSettings);
                            else {
                                let _ = document,
                                    i = function() {
                                        i.c(arguments)
                                    };
                                i.q = [], i.c = function(m) {
                                    i.q.push(m)
                                }, m.Intercom = i;
                                let l = function() {
                                    let m = _.createElement("script");
                                    m.type = "text/javascript", m.async = !0, m.src = "https://widget.intercom.io/widget/ze033am6";
                                    let C = _.getElementsByTagName("script")[0];
                                    C.parentNode.insertBefore(m, C)
                                };
                                "complete" === document.readyState ? l() : m.attachEvent ? m.attachEvent("onload", l) : m.addEventListener("load", l, !1)
                            }
                        }(), () => {
                            K.events.off("routeChangeComplete", handleRouteChange)
                        }
                }, []);
                let ei = _.getLayout || (m => m);
                return (0, L.useEffect)(() => {
                    let handleRouteChange = () => {
                            try {
                                let {
                                    firstLoaded: m
                                } = X.Z.getState().auth;
                                if (m) return;
                                en(!0)
                            } catch (m) {
                                console.log(m)
                            }
                        },
                        handleRouteChangeComplete = () => {
                            en(!1)
                        };
                    try {
                        let {
                            firstLoaded: m
                        } = X.Z.getState().auth;
                        m || X.Z.dispatch({
                            type: V.bO,
                            payload: !0
                        })
                    } catch (m) {
                        console.log(m)
                    }
                    return K.events.on("routeChangeStart", handleRouteChange), K.events.on("routeChangeComplete", handleRouteChangeComplete), K.events.on("routeChangeError", handleRouteChangeComplete), () => {
                        K.events.off("routeChangeStart", handleRouteChange), K.events.off("routeChangeError", handleRouteChangeComplete), K.events.off("routeChangeComplete", handleRouteChangeComplete)
                    }
                }, [K.events]), (0, R.jsxs)(ErrorBoundary, {
                    "data-sentry-element": "ErrorBoundary",
                    "data-sentry-component": "MyApp",
                    "data-sentry-source-file": "_app.tsx",
                    children: [(0, R.jsx)(LoadingScreen, {
                        className: !er && Y.width > 0 ? "fadeout" : void 0,
                        "data-sentry-element": "LoadingScreen",
                        "data-sentry-source-file": "_app.tsx"
                    }), (0, R.jsx)(ea.Ny, {
                        growthbook: ep,
                        "data-sentry-element": "GrowthBookProvider",
                        "data-sentry-source-file": "_app.tsx",
                        children: ei((0, R.jsx)(_, { ...C,
                            oneSignalInitialized: Q
                        }))
                    })]
                })
            }
        },
        2181: function(m, _, C) {
            "use strict";
            C.d(_, {
                $NM: function() {
                    return loginWithCookie
                },
                $Oj: function() {
                    return loginWithUserPass
                },
                $P3: function() {
                    return changNotiSettings
                },
                $wS: function() {
                    return playBlackjackV2Action
                },
                AHC: function() {
                    return rollRewardCase
                },
                Ab4: function() {
                    return createTowersGame
                },
                B4p: function() {
                    return setWithdrawalTarget
                },
                BYP: function() {
                    return getCaseBattles
                },
                C6: function() {
                    return getRobux
                },
                CZg: function() {
                    return getSellixHistory
                },
                DA_: function() {
                    return getRaffleDrawingResults
                },
                Dqh: function() {
                    return InitRblxAgeCheck
                },
                EXI: function() {
                    return getGameHistory
                },
                EXV: function() {
                    return loginWithRedemptionToken
                },
                FOM: function() {
                    return setAttemptPayment
                },
                FSK: function() {
                    return createDiceGame
                },
                Fo_: function() {
                    return loginWithUserPassAndSecondFactor
                },
                FzF: function() {
                    return getUserCrashData
                },
                G8W: function() {
                    return getFflags
                },
                GSw: function() {
                    return getBigRollPlayers
                },
                GVV: function() {
                    return showListedLimited
                },
                Gio: function() {
                    return upgradeMultipleCase
                },
                H_Z: function() {
                    return getWalletHistory
                },
                HtC: function() {
                    return claimUserAffiliateEarnings
                },
                HtV: function() {
                    return completeSecurityQuestion
                },
                Hvh: function() {
                    return getRaceInformation
                },
                I80: function() {
                    return launchExternalGame
                },
                IBG: function() {
                    return testAuth
                },
                ICb: function() {
                    return getAuthenticatedUser
                },
                IQh: function() {
                    return getAllRewards
                },
                ITX: function() {
                    return getVideoCompetitions
                },
                I_R: function() {
                    return getIpAddress
                },
                It1: function() {
                    return confirmEmailCode
                },
                J6H: function() {
                    return doTowersAction
                },
                J_T: function() {
                    return doMinesAction
                },
                Jbu: function() {
                    return getSingleCase
                },
                JmF: function() {
                    return getDiceGame
                },
                KX5: function() {
                    return depositStripeWithPaymentIntent
                },
                Kbv: function() {
                    return getVideoCompetitionsWinners
                },
                Lti: function() {
                    return getUserProfileData
                },
                MAM: function() {
                    return unlinkPhone
                },
                MS6: function() {
                    return loginWithUserPassAndToken
                },
                MeR: function() {
                    return fetchCryptoInfo
                },
                N4q: function() {
                    return completeTradeFrictionChallenge
                },
                NPu: function() {
                    return getCrashSchema
                },
                NXu: function() {
                    return unlinkEmail
                },
                Ne5: function() {
                    return createBlackjackV2Game
                },
                NfL: function() {
                    return rollItemsCase
                },
                Nhe: function() {
                    return createMinesGame
                },
                NxJ: function() {
                    return getAllItems
                },
                OIx: function() {
                    return confirmSmsCode
                },
                PlH: function() {
                    return depositBloxBillGooglePay
                },
                Plg: function() {
                    return getMinesGame
                },
                Q2H: function() {
                    return purchaseLimited
                },
                QZi: function() {
                    return listForSale
                },
                Qiv: function() {
                    return checkPayGardenDailyDepositLimit
                },
                QnB: function() {
                    return loginWithLinkRealm
                },
                Qy1: function() {
                    return solve2FA
                },
                RZ0: function() {
                    return liquidateRbx
                },
                Sv1: function() {
                    return loginwithpassWeblogin
                },
                U0J: function() {
                    return getRaffleLatestGame
                },
                URt: function() {
                    return getDepositDiscounts
                },
                VD: function() {
                    return getCCMethodsAllowed
                },
                WOK: function() {
                    return fetchSwapped
                },
                WcZ: function() {
                    return createNewBattle
                },
                XMO: function() {
                    return ChangeUserPrivacy
                },
                Y8w: function() {
                    return createCommunityCase
                },
                Z5X: function() {
                    return depositStripeWithPaymentMethod
                },
                ZO7: function() {
                    return redeemGiftcard
                },
                ZYU: function() {
                    return initiateGameAuth
                },
                _De: function() {
                    return attachPhoneNumber
                },
                _Fc: function() {
                    return getCommunityCase
                },
                _Lf: function() {
                    return findCaseItem
                },
                _Lu: function() {
                    return depositBloxBill
                },
                _Mv: function() {
                    return unlistItem
                },
                __8: function() {
                    return ssoSync
                },
                _yt: function() {
                    return upgradeCase
                },
                a4R: function() {
                    return getCaseBattle
                },
                aKb: function() {
                    return updateUserAffiliateCode
                },
                bIn: function() {
                    return claimRakebackBalance
                },
                bUA: function() {
                    return loginWithInstant
                },
                blP: function() {
                    return q
                },
                cdK: function() {
                    return deleteCommunityCase
                },
                cru: function() {
                    return getRecentBets
                },
                foq: function() {
                    return getJackpotGame
                },
                gfS: function() {
                    return getRaffleWinners
                },
                guP: function() {
                    return updateCommunityCase
                },
                hI4: function() {
                    return getAllSlotGames
                },
                ikH: function() {
                    return getTowersGame
                },
                jPb: function() {
                    return getChatData
                },
                jS6: function() {
                    return getRates
                },
                jTS: function() {
                    return getUserAffiliatesData
                },
                kr6: function() {
                    return loginWithRobloxSSO
                },
                lrf: function() {
                    return getProvablyFairData
                },
                mUe: function() {
                    return ssoLink
                },
                mXL: function() {
                    return getBigRollGame
                },
                nSh: function() {
                    return checkKinguinGiftcard
                },
                nTd: function() {
                    return getAllCommunityCases
                },
                nXh: function() {
                    return getAuthUser
                },
                oib: function() {
                    return getSiteSchema
                },
                orI: function() {
                    return rollPlinkoGame
                },
                oux: function() {
                    return claimCouponCode
                },
                pxG: function() {
                    return prepareTwoFactoredTrade
                },
                q0g: function() {
                    return FinishMLAgeCheck
                },
                q59: function() {
                    return checkGameAuth
                },
                q6B: function() {
                    return getCommunityCases
                },
                qAr: function() {
                    return lookupUser
                },
                rMC: function() {
                    return attachEmail
                },
                reb: function() {
                    return getLimiteds
                },
                rtJ: function() {
                    return completeTradeFrictionChallengeV2
                },
                sIj: function() {
                    return updateClientSeed
                },
                sjs: function() {
                    return showListedLimiteds
                },
                spc: function() {
                    return getPlinkoMultipliers
                },
                st5: function() {
                    return validateTransferCoastal
                },
                sxD: function() {
                    return solveCaptcha
                },
                t9F: function() {
                    return get10percentBonus
                },
                tbP: function() {
                    return getCCDetailsCoastalpay
                },
                vK9: function() {
                    return changeSourceHeader
                },
                vRJ: function() {
                    return InitMLAgeCheck
                },
                ve9: function() {
                    return handle2fa
                },
                vuG: function() {
                    return depositBloxBillApplePay
                },
                w4K: function() {
                    return getRouletteV2Schema
                },
                wAH: function() {
                    return enterLinkUrl
                },
                wCQ: function() {
                    return joinBigRollGame
                },
                wLO: function() {
                    return getAllCases
                },
                wjJ: function() {
                    return getAuthMethods
                },
                x$_: function() {
                    return depositRbxFromBloxland
                },
                y7t: function() {
                    return getCurrentBlackjackV2Game
                },
                yDX: function() {
                    return deleteCurrentBlackjackV2Game
                },
                yI8: function() {
                    return getUserVipData
                },
                ylq: function() {
                    return handleBlackjackV2Insurance
                },
                zO2: function() {
                    return rollCommunityCase
                },
                zXi: function() {
                    return initializeTradeFrictionChallenge
                },
                zeD: function() {
                    return getActiveCupsGames
                }
            });
            var R, L = C(9669),
                B = C.n(L);
            C(30931);
            var F = C(86501),
                U = C(11530);
            let H = ""; {
                H = "localhosts" === window.location.hostname ? "http://localhost:5000/" : "https://api.bloxflip.com/", localStorage.getItem("api_override") && (H = "https://rest-bf-staging.studs.ltd");
                let m = null !== (R = localStorage.getItem("action_env")) && void 0 !== R ? R : null,
                    _ = U.p || window.envsw;
                if (_ && m && "bloxflip.com" !== window.location.hostname) try {
                    let C = parseInt(m);
                    !isNaN(C) && C >= 0 && C in _ && (H = _[C].restUrl)
                } catch (m) {
                    console.log(m)
                }
            }
            let q = B().create({
                    baseURL: H,
                    headers: B().defaults.headers.common
                }),
                getFflags = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("https://cdn.growthbook.io/api/features/key_prod_559ede01dcb3b310"),
                            C = {};
                        for (let m in _.data.features) C[m] = _.data.features[m].defaultValue;
                        m(C)
                    } catch (m) {
                        _(m)
                    }
                }),
                changeSourceHeader = (m, _) => {
                    if (["rain", "rakeback", "daily"].includes(_)) {
                        var C;
                        if (new Date().getTime() - sessionStorage.getItem("timeJoined") < (null !== (C = window.sourceRetentionInt) && void 0 !== C ? C : 12e4)) {
                            q.defaults.headers.common.source = _ + "Retention";
                            return
                        }
                    }
                },
                InitRblxAgeCheck = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/user/rblx-agecheck", {});
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                InitMLAgeCheck = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/user/ml-agecheck", {});
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                FinishMLAgeCheck = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/user/ml-agecheck", {
                            sessionId: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                ChangeUserPrivacy = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.put("/user/update-privacy-enabled", {
                            privacyEnabled: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                getSiteSchema = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/site");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                loginWithRobloxSSO = async (m, _, C) => new Promise(async (R, L) => {
                    try {
                        let L = await q.post("/user/login?oauth=true&clientId=" + C, {
                            affiliateCode: _,
                            codeToken: m
                        });
                        R(L.data)
                    } catch (m) {
                        L(m)
                    }
                }),
                ssoLink = async m => {
                    let {
                        externalToken: _,
                        redirectUrl: C
                    } = m;
                    return new Promise(async (m, R) => {
                        try {
                            let R = await q.post("/user/link-sso", {
                                externalToken: _,
                                redirectUrl: C
                            });
                            m(R.data)
                        } catch (m) {
                            R(m)
                        }
                    })
                },
                ssoSync = async m => {
                    let {
                        externalToken: _,
                        redirectUrl: C
                    } = m;
                    return new Promise(async (m, R) => {
                        try {
                            let R = await q.post("/user/link-bgame", {
                                externalToken: _,
                                redirectUrl: C
                            });
                            m(R.data)
                        } catch (m) {
                            R(m)
                        }
                    })
                },
                checkGameAuth = async (m, _, C, R) => new Promise(async (L, B) => {
                    try {
                        let B = await q.post("/user/game-auth/check", {
                            userId: m,
                            pin: _,
                            resumeKey: C,
                            username: R
                        });
                        L(B.data)
                    } catch (m) {
                        B(m)
                    }
                }),
                launchExternalGame = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.post("/games/external/launch", {
                            slug: m,
                            demo: _
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                initiateGameAuth = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.post("/user/game-auth", {
                            username: m,
                            resumeKey: _
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                getAuthUser = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/user");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                getWalletHistory = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.get("/user/wallet-history?size=" + _ + "&page=" + m);
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                getSellixHistory = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.get("/user/sellix-history?size=" + _ + "&page=" + m);
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                getAuthMethods = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.get("/user/auth-methods/" + m + "?uniqueDeviceId=" + _);
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                getGameHistory = async (m, _, C) => (console.log(m), new Promise(async (R, L) => {
                    try {
                        let L = await q.get("/games/".concat(m, "/history?size=").concat(C, "&page=").concat(_));
                        R(L.data)
                    } catch (m) {
                        L(m)
                    }
                })),
                getAuthenticatedUser = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.get("/user?cache=" + m);
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                getRobux = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/inventory/viewRbx");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                showListedLimiteds = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/limiteds");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                showListedLimited = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.get("/limiteds/show/" + m);
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                getLimiteds = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/inventory/viewRoblox");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                testAuth = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/user/isAuthenticated");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                getChatData = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/chat/history");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                getUserProfileData = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/user");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                lookupUser = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.get("/user/lookup/" + m);
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                unlistItem = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/limiteds/unlist", {
                            userAssetId: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                createTowersGame = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.post("/games/towers/create", {
                            difficulty: m,
                            betAmount: _
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                doTowersAction = async (m, _, C) => new Promise(async (R, L) => {
                    try {
                        let L = await q.post("/games/towers/action", {
                            cashout: m,
                            tile: _,
                            towerLevel: C
                        });
                        R(L.data)
                    } catch (m) {
                        L(m)
                    }
                }),
                getTowersGame = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/games/towers");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                createMinesGame = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.post("/games/mines/create", {
                            mines: m,
                            betAmount: _
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                doMinesAction = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.post("/games/mines/action", {
                            cashout: m,
                            mine: _
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                getMinesGame = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/games/mines");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                rollPlinkoGame = async (m, _, C) => new Promise(async (R, L) => {
                    try {
                        let L = await q.post("/games/plinko/roll", {
                            rows: m,
                            risk: _,
                            amount: C
                        });
                        R(L.data)
                    } catch (m) {
                        L(m)
                    }
                }),
                purchaseLimited = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.post("/limiteds/purchase", {
                            userAssetId: m,
                            itemPrice: _
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                initializeTradeFrictionChallenge = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.post("/limiteds/challenge/initialize", {});
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                prepareTwoFactoredTrade = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/limiteds/challenge/initialize", {
                            tId: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                completeSecurityQuestion = async (m, _, C) => new Promise(async (R, L) => {
                    try {
                        let L = await q.post("/user/complete-question", {
                            sessionId: m,
                            userId: _,
                            answer: C
                        });
                        R(L.data)
                    } catch (m) {
                        L(m)
                    }
                }),
                completeTradeFrictionChallengeV2 = async (m, _, C, R, L, B) => new Promise(async (F, U) => {
                    try {
                        let U = await q.post("/limiteds/challenge/complete", {
                            challengeType: m,
                            challengeId: _,
                            code: C,
                            challengeMetadata: R,
                            challengeExtType: L,
                            tId: B
                        });
                        F(U.data)
                    } catch (m) {
                        U(m)
                    }
                }),
                completeTradeFrictionChallenge = async (m, _, C) => new Promise(async (R, L) => {
                    try {
                        let L = await q.post("/limiteds/challenge/complete", {
                            challengeType: m,
                            challengeId: _,
                            code: C
                        });
                        R(L.data)
                    } catch (m) {
                        L(m)
                    }
                }),
                listForSale = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.post("/limiteds/list", {
                            userAssetId: m,
                            itemPrice: _
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                handle2fa = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/limiteds/2fa", {
                            code: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                redeemGiftcard = async (m, _, C) => new Promise(async (R, L) => {
                    try {
                        let L = await q.post("/user/redeem", {
                            code: m,
                            fp: _,
                            clientId: C
                        });
                        R(L.data)
                    } catch (m) {
                        L(m)
                    }
                }),
                depositRbxFromBloxland = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/user/bloxLandDeposit", {
                            amount: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                setWithdrawalTarget = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.post("/user/withdrawTarget", {
                            amount: m,
                            deliveryType: _
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                liquidateRbx = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/user/liquidate", {
                            amount: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                depositStripeWithPaymentMethod = async (m, _, C, R, L) => new Promise(async (B, F) => {
                    try {
                        let F = await q.post("/user/depositCC?newPricingV2=true", {
                            rbxAmount: m,
                            paymentMethod: _,
                            sponsorCode: C,
                            clientId: R,
                            token: L
                        });
                        B(F.data)
                    } catch (m) {
                        F(m)
                    }
                }),
                getCCMethodsAllowed = () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/user/depositCC");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                getCCDetailsCoastalpay = (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.post("/user/depositCC/coastalPay?returnUrl=".concat(m, "&returnUrlNavigation=top"), {
                            rbxAmount: _,
                            paymentMethod: "CoastalPay"
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                validateTransferCoastal = function(m, _) {
                    let C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : document.URL;
                    return new Promise(async (R, L) => {
                        try {
                            let L = await q.post("/user/depositCC/coastalPay?returnUrl=".concat(encodeURIComponent(C), "&returnUrlNavigation=top"), Object.assign({}, m ? {
                                paymentId: m
                            } : {
                                rbxAmount: _
                            }));
                            R(L.data)
                        } catch (m) {
                            L(m)
                        }
                    })
                },
                depositBloxBill = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/user/depositCC/bloxbill?newPricingV2=true", {
                            bloxBillToken: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                depositBloxBillGooglePay = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.post("/user/depositCC/bloxbill?newPricingV2=true", {
                            googlePayData: m,
                            usdAmount: _
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                depositBloxBillApplePay = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.post("/user/depositCC/bloxbill?newPricingV2=true", {
                            applePayData: m,
                            usdAmount: _
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                depositStripeWithPaymentIntent = async (m, _, C, R, L) => new Promise(async (B, F) => {
                    try {
                        let F = await q.post("/user/depositCC?newPricingV2=true", {
                            rbxAmount: m,
                            paymentIntentId: _,
                            sponsorCode: C,
                            clientId: R,
                            token: L
                        });
                        B(F.data)
                    } catch (m) {
                        F(m)
                    }
                }),
                getRates = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/user/depositCC?newPricingV2=true", {
                            rbxAmount: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                fetchSwapped = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/user/swapped", {});
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                fetchCryptoInfo = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/user/crypto-info", {
                            assetId: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                getRecentBets = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.get("/live-feed/" + m);
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                getUserAffiliatesData = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/user/affiliates");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                updateUserAffiliateCode = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/user/affiliates/update-code", {
                            code: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                claimUserAffiliateEarnings = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.post("/user/affiliates/claim", {});
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                claimCouponCode = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/coupon/redeem", {
                            code: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                setAttemptPayment = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/user/depositCC/attempt?depositMethod=".concat(m), {});
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                getActiveCupsGames = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/games/cups");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                getRaceInformation = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/race");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                getCaseBattle = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.get("/games/case-battles?_id=" + m);
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                getCaseBattles = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/games/case-battles");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                createCommunityCase = async m => {
                    let {
                        items: _,
                        commission: C
                    } = m;
                    return new Promise(async (m, R) => {
                        try {
                            let R = await q.post("/games/community-cases/create", {
                                items: _,
                                commission: C
                            });
                            m(R.data)
                        } catch (m) {
                            R(m)
                        }
                    })
                },
                createNewBattle = async function(m, _, C) {
                    let R = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "SOLO_1V1",
                        L = arguments.length > 4 ? arguments[4] : void 0,
                        B = arguments.length > 5 ? arguments[5] : void 0,
                        F = arguments.length > 6 ? arguments[6] : void 0;
                    return new Promise(async (U, H) => {
                        try {
                            let H = await q.post("/games/case-battles/create", {
                                caseItems: m,
                                expectedPrice: _,
                                quickOpening: C,
                                gameMode: R,
                                crazyMode: L,
                                sharedMode: B,
                                terminalMode: F
                            });
                            U(H.data)
                        } catch (m) {
                            H(m)
                        }
                    })
                },
                rollRewardCase = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/rewards/roll", {
                            slug: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                rollItemsCase = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/games/cases/roll", {
                            slug: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                rollCommunityCase = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.post("/games/cases/roll", {
                            uuid: m,
                            directPlay: _
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                upgradeCase = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.post("games/".concat(_, "/upgrade"), {
                            gameId: m
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                upgradeMultipleCase = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.post("games/".concat(_, "/upgrade/bulk"), {
                            gameIds: m
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                findCaseItem = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/games/community-cases/find-item", {
                            value: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                getCommunityCase = async m => new Promise(async (_, C) => {
                    try {
                        var R, L;
                        let C = await q.get("/games/community-cases/" + m);
                        _(null === (L = C.data) || void 0 === L ? void 0 : null === (R = L.cases) || void 0 === R ? void 0 : R[0])
                    } catch (m) {
                        C(m)
                    }
                }),
                deleteCommunityCase = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.delete("/games/community-cases/" + m);
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                updateCommunityCase = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.patch("/games/community-cases/" + m, {
                            displayName: _
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                getSingleCase = async m => new Promise(async (_, C) => {
                    try {
                        var R, L;
                        let C = await q.get("/games/cases/" + m);
                        _(null === (L = C.data) || void 0 === L ? void 0 : null === (R = L.cases) || void 0 === R ? void 0 : R[0])
                    } catch (m) {
                        C(m)
                    }
                }),
                getAllRewards = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.get("/rewards?cache=" + m);
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                getAllCases = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/games/cases");
                        m(_.data.cases)
                    } catch (m) {
                        _(m)
                    }
                }),
                getAllSlotGames = async (m, _, C, R) => new Promise(async (L, B) => {
                    try {
                        let B = await q.get("/games/external?page=" + m + "&size=100&provider=" + R + "&sort=" + C + "&search=" + _);
                        L(B.data)
                    } catch (m) {
                        B(m)
                    }
                }),
                getCommunityCases = async m => {
                    let {
                        search: _,
                        minPrice: C,
                        maxPrice: R
                    } = m, L = new URLSearchParams;
                    _ && _.length > 2 && L.append("searchTerm", _), C && L.append("minPrice", C), R && L.append("maxPrice", R);
                    try {
                        let m = await q.get("/games/community-cases", {
                            params: L
                        });
                        return m.data.cases
                    } catch (m) {
                        var B;
                        F.Am.error(null !== (B = m.response.data.message) && void 0 !== B ? B : "Something went wrong")
                    }
                },
                getAllCommunityCases = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.get("/games/community-cases".concat(m ? "?filter=my" : ""));
                        _(C.data.cases)
                    } catch (m) {
                        var R;
                        F.Am.error(null !== (R = m.response.data.message) && void 0 !== R ? R : "Something went wrong"), C(m)
                    }
                }),
                getAllItems = async (m, _, C) => new Promise(async (R, L) => {
                    try {
                        let L = await q.get("/games/community-cases/items?page=" + m + "&limit=" + _ + "&query=" + C);
                        R(L.data)
                    } catch (m) {
                        L(m)
                    }
                }),
                getPlinkoMultipliers = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/games/plinko/multipliers");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                getUserVipData = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/vip");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                claimRakebackBalance = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.post("/vip/claim");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                getProvablyFairData = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/provably-fair");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                updateClientSeed = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/provably-fair/clientSeed", {
                            clientSeed: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                loginWithUserPass = async (m, _, C, R) => new Promise(async (L, B) => {
                    try {
                        let B = await q.post("/user/login?userpass=true&clientId=" + R, {
                            affiliateCode: C,
                            username: m,
                            password: _
                        });
                        L(B.data)
                    } catch (m) {
                        B(m)
                    }
                }),
                loginWithLinkRealm = async (m, _, C) => new Promise(async (R, L) => {
                    try {
                        let L = await q.post("/user/login?linkrealm=true&clientId=" + C, {
                            affiliateCode: _,
                            token: m
                        });
                        R(L.data)
                    } catch (m) {
                        L(m)
                    }
                }),
                loginWithInstant = async (m, _, C, R) => new Promise(async (L, B) => {
                    try {
                        let B = await q.post("/user/login?instant=true&clientId=" + R, {
                            affiliateCode: _,
                            username: m,
                            deviceId: C
                        });
                        L(B.data)
                    } catch (m) {
                        B(m)
                    }
                }),
                loginWithUserPassAndToken = async (m, _, C, R, L, B, F, U) => new Promise(async (H, V) => {
                    try {
                        let V = await q.post("/user/login?userpass=true&preAuth=false&clientId=" + B, {
                            affiliateCode: L,
                            username: m,
                            password: _,
                            captchaId: C,
                            captchaToken: R,
                            securityQuestionRedemptionToken: F,
                            securityQuestionSessionId: U
                        });
                        H(V.data)
                    } catch (m) {
                        V(m)
                    }
                }),
                loginWithUserPassAndSecondFactor = async (m, _, C, R, L, B, F) => new Promise(async (U, H) => {
                    try {
                        let H = await q.post("/user/login?userpass=true&clientId=" + F, {
                            affiliateCode: B,
                            challengeId: m,
                            userId: _,
                            code: L,
                            challengeType: C,
                            password: R
                        });
                        U(H.data)
                    } catch (m) {
                        H(m)
                    }
                }),
                loginWithRedemptionToken = async (m, _, C) => new Promise(async (R, L) => {
                    try {
                        let L = await q.post("/user/login?gameauth=true&clientId=" + C, {
                            affiliateCode: _,
                            redemptionToken: m
                        });
                        R(L.data)
                    } catch (m) {
                        L(m)
                    }
                }),
                loginWithCookie = async (m, _, C) => new Promise(async (R, L) => {
                    try {
                        let L = await q.post("/user/login?clientId=" + C, {
                            cookie: m,
                            affiliateCode: _
                        });
                        R(L.data)
                    } catch (m) {
                        L(m)
                    }
                }),
                getRouletteV2Schema = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/games/roulette");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                getCrashSchema = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/games/crash");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                getUserCrashData = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/games/crash/me");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                getJackpotGame = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/games/jackpot");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                joinBigRollGame = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/games/bigroll/join", {
                            betAmount: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                getBigRollGame = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/games/bigroll/game");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                getBigRollPlayers = async (m, _) => new Promise(async (C, R) => {
                    try {
                        let R = await q.get("/games/bigroll/players", {
                            params: {
                                page: m,
                                pageSize: _
                            }
                        });
                        C(R.data)
                    } catch (m) {
                        R(m)
                    }
                }),
                getRaffleDrawingResults = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/games/raffle/drawing-results");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                attachEmail = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.put("/user/init-change-email", {
                            email: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                confirmEmailCode = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/user/confirm-change-email", {
                            code: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                attachPhoneNumber = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.put("/user/init-change-phone", {
                            phoneNumber: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                unlinkPhone = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.delete("/user/remove-phone");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                unlinkEmail = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.delete("/user/remove-email");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                confirmSmsCode = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.post("/user/confirm-change-phone", {
                            code: m
                        });
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                changNotiSettings = async m => new Promise(async (_, C) => {
                    let R = { ...m
                    };
                    R.rainNotificationSettings.rainMinimum = 1e3 * R.rainNotificationSettings.rainMinimum;
                    try {
                        let m = await q.put("/user/notification-settings", R);
                        _(m.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                getRaffleWinners = async function() {
                    let m = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                    return new Promise(async (_, C) => {
                        try {
                            let C = await q.get("/games/raffle/latest-winners" + (m ? "?limit=" + m : ""));
                            _(C.data)
                        } catch (m) {
                            C(m)
                        }
                    })
                },
                getRaffleLatestGame = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.get("/games/raffle/latest-game" + (m ? "?gameId=" + m : ""));
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                getDepositDiscounts = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/user/promotion/deposits/active");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                getVideoCompetitions = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.get("user/video-competition/active-competition?competitionType=" + m);
                        _(C.data)
                    } catch (m) {
                        C(m)
                    }
                }),
                getVideoCompetitionsWinners = async (m, _, C) => new Promise(async (R, L) => {
                    try {
                        let L = await q.get("user/video-competition/recent-winners?competitionType=".concat(m, "&pageIndex=").concat(_, "&pageSize=").concat(C));
                        R(L.data)
                    } catch (m) {
                        L(m)
                    }
                }),
                enterLinkUrl = async m => {
                    let {
                        captchaToken: _,
                        competitionType: C,
                        videoUrl: R
                    } = m;
                    return new Promise(async (m, L) => {
                        try {
                            let L = await q.post("/user/video-competition/join", {
                                captchaToken: _,
                                competitionType: C,
                                videoUrl: R
                            });
                            m(L.data)
                        } catch (m) {
                            L(m)
                        }
                    })
                },
                getIpAddress = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await window.fetch("https://api.ipify.org?format=json", {
                                mode: "cors"
                            }),
                            C = await _.json();
                        m(C)
                    } catch (m) {
                        _(m)
                    }
                }),
                checkKinguinGiftcard = async m => new Promise(async (_, C) => {
                    try {
                        let C = await q.get("/825adace-b454-11ec-b909-0242ac120002/external/check/d439985f-5b59-43bb-ac59-238307e17f78", {
                                params: {
                                    code: m
                                }
                            }),
                            R = await C.data;
                        _(R)
                    } catch (m) {
                        C(m)
                    }
                }),
                loginwithpassWeblogin = async (m, _, C) => new Promise(async (R, L) => {
                    try {
                        let L = await q.post("/user/login?weblogin=true&clientId=" + C, {
                            username: m,
                            password: _
                        });
                        R(L)
                    } catch (m) {
                        L(m)
                    }
                }),
                solveCaptcha = async (m, _, C, R) => new Promise(async (L, B) => {
                    try {
                        let B = await q.post("/user/login?weblogin=true&clientId=" + C, {
                            instanceId: m,
                            sessionId: _,
                            inputChoice: R
                        });
                        L(B)
                    } catch (m) {
                        B(m)
                    }
                }),
                solve2FA = async (m, _, C, R) => new Promise(async (L, B) => {
                    try {
                        let B = await q.post("/user/login?weblogin=true&clientId=" + C, {
                            instanceId: m,
                            sessionId: _,
                            code: R
                        });
                        L(B.data)
                    } catch (m) {
                        B(m)
                    }
                }),
                get10percentBonus = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.request({
                            method: "POST",
                            url: "/user/promotion/promocodes/affiliate",
                            headers: {
                                "Content-Type": "application/json"
                            }
                        });
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                }),
                getDiceGame = m => q.get("/games/dice/".concat(m)).then(m => m.data),
                createDiceGame = (m, _, C, R, L) => q.post("/games/dice/roll", {
                    bet: m,
                    ranges: [{
                        min: C ? 0 : _,
                        max: C ? _ : 99.99
                    }],
                    multiplier: R,
                    payout: L
                }).then(m => m.data),
                createBlackjackV2Game = m => new Promise(async (_, C) => {
                    var R, L, B, F;
                    try {
                        let B = await q.post("games/blackjackv2/join-game", {
                                bet: m
                            }),
                            F = (null === (R = B.data) || void 0 === R ? void 0 : R.success) ? _ : C,
                            U = (null === (L = B.data) || void 0 === L ? void 0 : L.success) ? B.data.game : B.data.message;
                        F(U)
                    } catch (_) {
                        let m = null === (F = _.response) || void 0 === F ? void 0 : null === (B = F.data) || void 0 === B ? void 0 : B.msg;
                        C((m || "Something went wrong!").slice(0, 100))
                    }
                }),
                playBlackjackV2Action = m => {
                    let {
                        gameId: _,
                        action: C,
                        handIndex: R
                    } = m;
                    return new Promise(async (m, L) => {
                        var B, F, U, H;
                        try {
                            let U = await q.post("games/blackjackv2/action", {
                                    gameId: _,
                                    action: C,
                                    handIndex: R
                                }),
                                H = (null === (B = U.data) || void 0 === B ? void 0 : B.success) ? m : L,
                                V = (null === (F = U.data) || void 0 === F ? void 0 : F.success) ? U.data.game : U.data.message;
                            H(V)
                        } catch (_) {
                            let m = null === (H = _.response) || void 0 === H ? void 0 : null === (U = H.data) || void 0 === U ? void 0 : U.message;
                            L((m || "Something went wrong!").slice(0, 100))
                        }
                    })
                },
                handleBlackjackV2Insurance = (m, _) => new Promise(async (C, R) => {
                    var L, B, F, U;
                    try {
                        let F = await q.post("games/blackjackv2/insurance", {
                                gameId: m,
                                taken: _
                            }),
                            U = (null === (L = F.data) || void 0 === L ? void 0 : L.success) ? C : R,
                            H = (null === (B = F.data) || void 0 === B ? void 0 : B.success) ? F.data.game : F.data.message;
                        U(H)
                    } catch (_) {
                        let m = null === (U = _.response) || void 0 === U ? void 0 : null === (F = U.data) || void 0 === F ? void 0 : F.message;
                        R((m || "Something went wrong!").slice(0, 100))
                    }
                }),
                getCurrentBlackjackV2Game = () => new Promise(async (m, _) => {
                    var C, R, L, B, F;
                    try {
                        let L = await q.get("games/blackjackv2/my-game"),
                            B = (null === (C = L.data) || void 0 === C ? void 0 : C.success) ? m : _,
                            F = (null === (R = L.data) || void 0 === R ? void 0 : R.success) ? L.data.game : L.data.message;
                        B(F)
                    } catch (C) {
                        let m = (null === (L = C.response) || void 0 === L ? void 0 : L.status) === 404 ? "404" : null === (F = C.response) || void 0 === F ? void 0 : null === (B = F.data) || void 0 === B ? void 0 : B.message;
                        _((m || "Something went wrong!").slice(0, 100))
                    }
                }),
                deleteCurrentBlackjackV2Game = () => new Promise(async (m, _) => {
                    var C, R, L, B;
                    try {
                        let L = await q.delete("games/blackjackv2/my-game"),
                            B = (null === (C = L.data) || void 0 === C ? void 0 : C.success) ? m : _,
                            F = (null === (R = L.data) || void 0 === R ? void 0 : R.success) ? L.data.game : L.data.message;
                        B(F)
                    } catch (C) {
                        let m = null === (B = C.response) || void 0 === B ? void 0 : null === (L = B.data) || void 0 === L ? void 0 : L.message;
                        _((m || "Something went wrong!").slice(0, 100))
                    }
                }),
                checkPayGardenDailyDepositLimit = async () => new Promise(async (m, _) => {
                    try {
                        let _ = await q.get("/paygarden/limit-check");
                        m(_.data)
                    } catch (m) {
                        _(m)
                    }
                })
        },
        11530: function(m, _, C) {
            "use strict";
            C.d(_, {
                p: function() {
                    return R
                }
            });
            let getPreviewEnv = () => {
                    let m = window.location.hostname;
                    if (!/\.bazooki\.cncsites\.com$/.test(m)) return null;
                    let _ = m.split(".")[0];
                    return {
                        name: "Preview Env (".concat(_, ")"),
                        wsUrl: "wss://".concat(m, "/api/ws"),
                        restUrl: "https://".concat(m, "/api")
                    }
                },
                R = [...getPreviewEnv() ? [getPreviewEnv()] : [], {
                    name: "Production",
                    wsUrl: "wss://ws.bloxflip.com",
                    restUrl: "https://api.bloxflip.com"
                }, {
                    name: "Staging [NEW]",
                    wsUrl: "wss://bf-staging-ws.bazooki-infra.dev",
                    restUrl: "https://bf-staging-rest.bazooki-infra.dev"
                }, {
                    name: "Develop",
                    wsUrl: "wss://develop-ws.bloxflip.dev",
                    restUrl: "https://develop-rest.bloxflip.dev"
                }, {
                    name: "Localhost",
                    wsUrl: "ws://localhost:9092",
                    restUrl: "http://localhost:5000"
                }, {
                    name: "A Workstation",
                    wsUrl: "ws://172.20.10.6:9092",
                    restUrl: "http://172.20.10.6:5000"
                }]
        },
        40400: function(m, _) {
            "use strict";
            _.Z = m => {
                var _;
                return null === (_ = String(m).match(/^-?\d+(?:\.\d{0,2})?/)) || void 0 === _ ? void 0 : _[0]
            }
        },
        38178: function(m, _, C) {
            "use strict";
            C.d(_, {
                Tc: function() {
                    return R
                },
                _Q: function() {
                    return playSoundEffect
                },
                aG: function() {
                    return preloadAllSounds
                }
            });
            let R = {
                    BLACKJACK: {
                        CARD_SLIDE: {
                            url: "../sounds/blackjackv2/card-slide-2.wav",
                            speed: 2
                        },
                        CARD_SLIDE_ALT: {
                            url: "../sounds/blackjackv2/card-slide-1.wav",
                            speed: 1.5
                        },
                        CARD_FLIP: {
                            url: "../sounds/blackjackv2/card-flip.wav"
                        },
                        CLICK: {
                            url: "../sounds/blackjackv2/click.wav",
                            volume: 1,
                            speed: .5
                        },
                        COIN: {
                            url: "../sounds/blackjackv2/coin-drop.wav",
                            volume: .2
                        },
                        COINS_SCATTER: {
                            url: "../sounds/blackjackv2/coins-scatter.wav",
                            delay: .4,
                            volume: .7
                        },
                        HINT: {
                            url: "../sounds/blackjackv2/hint.mp3",
                            volume: .5
                        },
                        WIN: {
                            url: "../sounds/blackjackv2/win.mp3",
                            speed: 1.2
                        }
                    },
                    DICE: {
                        ROLL: {
                            url: "../sounds/dice-roll.wav"
                        },
                        WIN: {
                            url: "../sounds/dice-win.mp3"
                        }
                    },
                    UPGRADER: {
                        UPGRADE: {
                            url: "../sounds/upgrader-sound.mp3",
                            volume: .4
                        }
                    },
                    CASES: {
                        TICK: {
                            url: "../sounds/wheel_tick.mp3",
                            volume: .4
                        },
                        WIN: {
                            url: "../sounds/wheel_win.mp3"
                        }
                    },
                    MINES: {
                        SUSPENSE: {
                            url: "../sounds/suspense.mp3",
                            volume: .15
                        },
                        EXPLOSION: {
                            url: "../sounds/explosion.mp3",
                            volume: .4
                        },
                        GOOD: {
                            url: "../sounds/good.mp3",
                            volume: .3
                        },
                        BIG_CASHOUT: {
                            url: "../sounds/big_cashout.mp3",
                            volume: .2
                        }
                    },
                    TOWERS: {
                        BREAK: {
                            url: "../sounds/break.mp3",
                            volume: .2
                        },
                        STOMP: {
                            url: "../sounds/stomp.mp3",
                            volume: .2
                        },
                        BIG_CASHOUT: {
                            url: "../sounds/big_cashout.mp3",
                            volume: .2
                        }
                    }
                },
                playSoundEffect = m => {
                    let _ = new Audio(m.url);
                    if (_.currentTime = m.start || 0, _.volume = m.volume || 1, _.playbackRate = m.speed || 1, setTimeout(() => {
                            _.play().catch(m => console.warn("Sound Effect Error:", m))
                        }, 1e3 * (m.delay || 0)), m.end) {
                        let C = setTimeout(() => {
                            _.pause(), _.currentTime = 0, clearTimeout(C)
                        }, 1e3 * m.end)
                    }
                    return _
                },
                preloadAllSounds = () => {
                    let m = {};
                    for (let _ in R) {
                        let C = R[_];
                        for (let R in m[_] = {}, C) {
                            let L = C[R],
                                B = new Audio(L.url);
                            B.preload = "auto", B.load(), m[_][R] = B
                        }
                    }
                }
        },
        83079: function() {},
        24106: function() {},
        91326: function() {},
        34385: function() {},
        12732: function() {},
        63811: function(m) {
            m.exports = {
                flash: "button_flash__afMd3",
                pulse: "button_pulse__JIqIt",
                button: "button_button__dZRSb",
                primary: "button_primary__LXFHi",
                danger: "button_danger__yRxCm",
                secondary: "button_secondary__Fa_lP",
                square: "button_square__fMSa0",
                ingame: "button_ingame__9oa_7",
                gameControl: "button_gameControl__ElkRq",
                tab: "button_tab__RC45L",
                liveFeedTab: "button_liveFeedTab__Bqsl_",
                pagination: "button_pagination__pIaaC",
                inputButton: "button_inputButton__B2DPv",
                betOption: "button_betOption__yOLYh",
                betOptionCompact: "button_betOptionCompact__Gmzj8",
                autoReset: "button_autoReset__R33EV",
                autoIncrease: "button_autoIncrease__uD_yX",
                isActive: "button_isActive__tpT2u",
                clicked: "button_clicked___FpNk",
                selected: "button_selected__AhHIr",
                functional: "button_functional__S9rty",
                debug: "button_debug___BL_z",
                debugActive: "button_debugActive__83d10",
                bottomTop: "button_bottomTop__hxrHI",
                flipCard: "button_flipCard__FYCma",
                bottomTopFlip: "button_bottomTopFlip__0gtbi",
                fade: "button_fade__c1wD8",
                rotate: "button_rotate__xWMdt",
                cupOut: "button_cupOut__jkXra",
                gloss: "button_gloss__crMdU",
                shake: "button_shake__M2koe",
                rotateY: "button_rotateY__r_4ca",
                animateArrow: "button_animateArrow__5kBOs",
                selectionArrowRight: "button_selectionArrowRight__R7ufs",
                selectionArrowLeft: "button_selectionArrowLeft__nFgGy",
                coinExplode: "button_coinExplode__FGeck"
            }
        },
        52969: function(m) {
            m.exports = {
                errorPage: "error_errorPage__6vGAy"
            }
        },
        27188: function(m) {
            m.exports = {
                loaderScreen: "loader_loaderScreen__fVbjK",
                loaderScreenCenter: "loader_loaderScreenCenter__0fFJX",
                loaderScreenCenterLoader: "loader_loaderScreenCenterLoader__a3gD5"
            }
        },
        11163: function(m, _, C) {
            m.exports = C(32059)
        },
        34155: function(m) {
            var _, C, R, L = m.exports = {};

            function defaultSetTimout() {
                throw Error("setTimeout has not been defined")
            }

            function defaultClearTimeout() {
                throw Error("clearTimeout has not been defined")
            }

            function runTimeout(m) {
                if (_ === setTimeout) return setTimeout(m, 0);
                if ((_ === defaultSetTimout || !_) && setTimeout) return _ = setTimeout, setTimeout(m, 0);
                try {
                    return _(m, 0)
                } catch (C) {
                    try {
                        return _.call(null, m, 0)
                    } catch (C) {
                        return _.call(this, m, 0)
                    }
                }
            }! function() {
                try {
                    _ = "function" == typeof setTimeout ? setTimeout : defaultSetTimout
                } catch (m) {
                    _ = defaultSetTimout
                }
                try {
                    C = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout
                } catch (m) {
                    C = defaultClearTimeout
                }
            }();
            var B = [],
                F = !1,
                U = -1;

            function cleanUpNextTick() {
                F && R && (F = !1, R.length ? B = R.concat(B) : U = -1, B.length && drainQueue())
            }

            function drainQueue() {
                if (!F) {
                    var m = runTimeout(cleanUpNextTick);
                    F = !0;
                    for (var _ = B.length; _;) {
                        for (R = B, B = []; ++U < _;) R && R[U].run();
                        U = -1, _ = B.length
                    }
                    R = null, F = !1,
                        function(m) {
                            if (C === clearTimeout) return clearTimeout(m);
                            if ((C === defaultClearTimeout || !C) && clearTimeout) return C = clearTimeout, clearTimeout(m);
                            try {
                                C(m)
                            } catch (_) {
                                try {
                                    return C.call(null, m)
                                } catch (_) {
                                    return C.call(this, m)
                                }
                            }
                        }(m)
                }
            }

            function Item(m, _) {
                this.fun = m, this.array = _
            }

            function noop() {}
            L.nextTick = function(m) {
                var _ = Array(arguments.length - 1);
                if (arguments.length > 1)
                    for (var C = 1; C < arguments.length; C++) _[C - 1] = arguments[C];
                B.push(new Item(m, _)), 1 !== B.length || F || runTimeout(drainQueue)
            }, Item.prototype.run = function() {
                this.fun.apply(null, this.array)
            }, L.title = "browser", L.browser = !0, L.env = {}, L.argv = [], L.version = "", L.versions = {}, L.on = noop, L.addListener = noop, L.once = noop, L.off = noop, L.removeListener = noop, L.removeAllListeners = noop, L.emit = noop, L.prependListener = noop, L.prependOnceListener = noop, L.listeners = function(m) {
                return []
            }, L.binding = function(m) {
                throw Error("process.binding is not supported")
            }, L.cwd = function() {
                return "/"
            }, L.chdir = function(m) {
                throw Error("process.chdir is not supported")
            }, L.umask = function() {
                return 0
            }
        },
        49559: function(m, _) {
            "use strict";
            Object.defineProperty(_, "__esModule", {
                value: !0
            }), _.default = function() {
                var m, _, R = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                    L = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1],
                    B = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2],
                    F = R || "";
                return L && (F = R.toString().trim().replace(/[A-Za-z0-9\u00C0-\u00FF]+[^\s-]*/g, function(m, _, R) {
                    return _ > 0 && _ + m.length !== R.length && m.search(C) > -1 && ":" !== R.charAt(_ - 2) && ("-" !== R.charAt(_ + m.length) || "-" === R.charAt(_ - 1)) && 0 > R.charAt(_ - 1).search(/[^\s-]/) ? m.toLowerCase() : m.substr(1).search(/[A-Z]|\../) > -1 ? m : m.charAt(0).toUpperCase() + m.substr(1)
                })), B && (F = "string" == typeof(_ = m = F) && -1 !== _.indexOf("@") ? (console.warn("This arg looks like an email address, redacting."), "REDACTED (Potential Email Address)") : m), F
            };
            var C = /^(a|an|and|as|at|but|by|en|for|if|in|nor|of|on|or|per|the|to|vs?\.?|via)$/i
        },
        41638: function(m, _, C) {
            "use strict";
            Object.defineProperty(_, "__esModule", {
                value: !0
            }), _.default = _.GA4 = void 0;
            var R = _interopRequireDefault(C(76161)),
                L = _interopRequireDefault(C(49559)),
                B = ["eventCategory", "eventAction", "eventLabel", "eventValue", "hitType"],
                F = ["title", "location"],
                U = ["page", "hitType"],
                H = ["action", "category", "label", "value", "nonInteraction", "transport"];

            function _interopRequireDefault(m) {
                return m && m.__esModule ? m : {
                    default: m
                }
            }

            function _objectWithoutProperties(m, _) {
                if (null == m) return {};
                var C, R, L = function(m, _) {
                    if (null == m) return {};
                    var C, R, L = {},
                        B = Object.keys(m);
                    for (R = 0; R < B.length; R++) C = B[R], _.indexOf(C) >= 0 || (L[C] = m[C]);
                    return L
                }(m, _);
                if (Object.getOwnPropertySymbols) {
                    var B = Object.getOwnPropertySymbols(m);
                    for (R = 0; R < B.length; R++) C = B[R], !(_.indexOf(C) >= 0) && Object.prototype.propertyIsEnumerable.call(m, C) && (L[C] = m[C])
                }
                return L
            }

            function _typeof(m) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(m) {
                    return typeof m
                } : function(m) {
                    return m && "function" == typeof Symbol && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m
                })(m)
            }

            function _toConsumableArray(m) {
                return function(m) {
                    if (Array.isArray(m)) return _arrayLikeToArray(m)
                }(m) || function(m) {
                    if ("undefined" != typeof Symbol && null != m[Symbol.iterator] || null != m["@@iterator"]) return Array.from(m)
                }(m) || _unsupportedIterableToArray(m) || function() {
                    throw TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function ownKeys(m, _) {
                var C = Object.keys(m);
                if (Object.getOwnPropertySymbols) {
                    var R = Object.getOwnPropertySymbols(m);
                    _ && (R = R.filter(function(_) {
                        return Object.getOwnPropertyDescriptor(m, _).enumerable
                    })), C.push.apply(C, R)
                }
                return C
            }

            function _objectSpread(m) {
                for (var _ = 1; _ < arguments.length; _++) {
                    var C = null != arguments[_] ? arguments[_] : {};
                    _ % 2 ? ownKeys(Object(C), !0).forEach(function(_) {
                        _defineProperty(m, _, C[_])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(m, Object.getOwnPropertyDescriptors(C)) : ownKeys(Object(C)).forEach(function(_) {
                        Object.defineProperty(m, _, Object.getOwnPropertyDescriptor(C, _))
                    })
                }
                return m
            }

            function _unsupportedIterableToArray(m, _) {
                if (m) {
                    if ("string" == typeof m) return _arrayLikeToArray(m, _);
                    var C = Object.prototype.toString.call(m).slice(8, -1);
                    if ("Object" === C && m.constructor && (C = m.constructor.name), "Map" === C || "Set" === C) return Array.from(m);
                    if ("Arguments" === C || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(C)) return _arrayLikeToArray(m, _)
                }
            }

            function _arrayLikeToArray(m, _) {
                (null == _ || _ > m.length) && (_ = m.length);
                for (var C = 0, R = Array(_); C < _; C++) R[C] = m[C];
                return R
            }

            function _defineProperties(m, _) {
                for (var C = 0; C < _.length; C++) {
                    var R = _[C];
                    R.enumerable = R.enumerable || !1, R.configurable = !0, "value" in R && (R.writable = !0), Object.defineProperty(m, R.key, R)
                }
            }

            function _defineProperty(m, _, C) {
                return _ in m ? Object.defineProperty(m, _, {
                    value: C,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : m[_] = C, m
            }
            var q = function() {
                var m, _;

                function GA4() {
                    var m = this;
                    (function(m, _) {
                        if (!(m instanceof _)) throw TypeError("Cannot call a class as a function")
                    })(this, GA4), _defineProperty(this, "reset", function() {
                        m.isInitialized = !1, m._testMode = !1, m._currentMeasurementId, m._hasLoadedGA = !1, m._isQueuing = !1, m._queueGtag = []
                    }), _defineProperty(this, "_gtag", function() {
                        for (var _ = arguments.length, C = Array(_), L = 0; L < _; L++) C[L] = arguments[L];
                        m._testMode ? m._queueGtag.push(C) : m._isQueuing ? m._queueGtag.push(C) : R.default.apply(void 0, C)
                    }), _defineProperty(this, "_loadGA", function(_, C) {
                        if ("undefined" != typeof window && "undefined" != typeof document && !m._hasLoadedGA) {
                            var R = document.createElement("script");
                            R.async = !0, R.src = "https://www.googletagmanager.com/gtag/js?id=".concat(_), C && R.setAttribute("nonce", C), document.body.appendChild(R), window.dataLayer = window.dataLayer || [], window.gtag = function() {
                                window.dataLayer.push(arguments)
                            }, m._hasLoadedGA = !0
                        }
                    }), _defineProperty(this, "_toGtagOptions", function(m) {
                        if (m) {
                            var _ = {
                                cookieUpdate: "cookie_update",
                                cookieExpires: "cookie_expires",
                                cookieDomain: "cookie_domain",
                                cookieFlags: "cookie_flags",
                                userId: "user_id",
                                clientId: "client_id",
                                anonymizeIp: "anonymize_ip",
                                contentGroup1: "content_group1",
                                contentGroup2: "content_group2",
                                contentGroup3: "content_group3",
                                contentGroup4: "content_group4",
                                contentGroup5: "content_group5",
                                allowAdFeatures: "allow_google_signals",
                                allowAdPersonalizationSignals: "allow_ad_personalization_signals",
                                nonInteraction: "non_interaction",
                                page: "page_path",
                                hitCallback: "event_callback"
                            };
                            return Object.entries(m).reduce(function(m, C) {
                                var R = function(m) {
                                        if (Array.isArray(m)) return m
                                    }(C) || function(m, _) {
                                        var C, R, L = null == m ? null : "undefined" != typeof Symbol && m[Symbol.iterator] || m["@@iterator"];
                                        if (null != L) {
                                            var B = [],
                                                F = !0,
                                                U = !1;
                                            try {
                                                for (L = L.call(m); !(F = (C = L.next()).done) && (B.push(C.value), !_ || B.length !== _); F = !0);
                                            } catch (m) {
                                                U = !0, R = m
                                            } finally {
                                                try {
                                                    F || null == L.return || L.return()
                                                } finally {
                                                    if (U) throw R
                                                }
                                            }
                                            return B
                                        }
                                    }(C, 2) || _unsupportedIterableToArray(C, 2) || function() {
                                        throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                    }(),
                                    L = R[0],
                                    B = R[1];
                                return _[L] ? m[_[L]] = B : m[L] = B, m
                            }, {})
                        }
                    }), _defineProperty(this, "initialize", function(_) {
                        var C = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        if (!_) throw Error("Require GA_MEASUREMENT_ID");
                        var R = "string" == typeof _ ? [{
                            trackingId: _
                        }] : _;
                        m._currentMeasurementId = R[0].trackingId;
                        var L = C.gaOptions,
                            B = C.gtagOptions,
                            F = C.legacyDimensionMetric,
                            U = void 0 === F || F,
                            H = C.nonce,
                            q = C.testMode,
                            V = void 0 !== q && q;
                        if (m._testMode = V, V || m._loadGA(m._currentMeasurementId, H), m.isInitialized || (m._gtag("js", new Date), R.forEach(function(_) {
                                var C = m._appendCustomMap(_objectSpread(_objectSpread(_objectSpread({
                                    send_page_view: !1
                                }, m._toGtagOptions(_objectSpread(_objectSpread({}, L), _.gaOptions))), B), _.gtagOptions), U);
                                m._gtag("config", _.trackingId, C)
                            })), m.isInitialized = !0, !V) {
                            var X = _toConsumableArray(m._queueGtag);
                            for (m._queueGtag = [], m._isQueuing = !1; X.length;) {
                                var K = X.shift();
                                m._gtag.apply(m, _toConsumableArray(K)), "get" === K[0] && (m._isQueuing = !0)
                            }
                        }
                    }), _defineProperty(this, "set", function(_) {
                        if (!_) {
                            console.warn("`fieldsObject` is required in .set()");
                            return
                        }
                        if ("object" !== _typeof(_)) {
                            console.warn("Expected `fieldsObject` arg to be an Object");
                            return
                        }
                        0 === Object.keys(_).length && console.warn("empty `fieldsObject` given to .set()"), m._gaCommand("set", _)
                    }), _defineProperty(this, "_gaCommandSendEvent", function(_, C, R, L, B) {
                        m._gtag("event", C, _objectSpread(_objectSpread({
                            event_category: _,
                            event_label: R,
                            value: L
                        }, B && {
                            non_interaction: B.nonInteraction
                        }), m._toGtagOptions(B)))
                    }), _defineProperty(this, "_gaCommandSendEventParameters", function() {
                        for (var _ = arguments.length, C = Array(_), R = 0; R < _; R++) C[R] = arguments[R];
                        if ("string" == typeof C[0]) m._gaCommandSendEvent.apply(m, _toConsumableArray(C.slice(1)));
                        else {
                            var L = C[0],
                                F = L.eventCategory,
                                U = L.eventAction,
                                H = L.eventLabel,
                                q = L.eventValue,
                                V = (L.hitType, _objectWithoutProperties(L, B));
                            m._gaCommandSendEvent(F, U, H, q, V)
                        }
                    }), _defineProperty(this, "_gaCommandSendTiming", function(_, C, R, L) {
                        m._gtag("event", "timing_complete", {
                            name: C,
                            value: R,
                            event_category: _,
                            event_label: L
                        })
                    }), _defineProperty(this, "_gaCommandSendPageview", function(_, C) {
                        if (C && Object.keys(C).length) {
                            var R = m._toGtagOptions(C),
                                L = R.title,
                                B = R.location,
                                U = _objectWithoutProperties(R, F);
                            m._gtag("event", "page_view", _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, _ && {
                                page_path: _
                            }), L && {
                                page_title: L
                            }), B && {
                                page_location: B
                            }), U))
                        } else _ ? m._gtag("event", "page_view", {
                            page_path: _
                        }) : m._gtag("event", "page_view")
                    }), _defineProperty(this, "_gaCommandSendPageviewParameters", function() {
                        for (var _ = arguments.length, C = Array(_), R = 0; R < _; R++) C[R] = arguments[R];
                        if ("string" == typeof C[0]) m._gaCommandSendPageview.apply(m, _toConsumableArray(C.slice(1)));
                        else {
                            var L = C[0],
                                B = L.page,
                                F = (L.hitType, _objectWithoutProperties(L, U));
                            m._gaCommandSendPageview(B, F)
                        }
                    }), _defineProperty(this, "_gaCommandSend", function() {
                        for (var _ = arguments.length, C = Array(_), R = 0; R < _; R++) C[R] = arguments[R];
                        var L = "string" == typeof C[0] ? C[0] : C[0].hitType;
                        switch (L) {
                            case "event":
                                m._gaCommandSendEventParameters.apply(m, C);
                                break;
                            case "pageview":
                                m._gaCommandSendPageviewParameters.apply(m, C);
                                break;
                            case "timing":
                                m._gaCommandSendTiming.apply(m, _toConsumableArray(C.slice(1)));
                                break;
                            case "screenview":
                            case "transaction":
                            case "item":
                            case "social":
                            case "exception":
                                console.warn("Unsupported send command: ".concat(L));
                                break;
                            default:
                                console.warn("Send command doesn't exist: ".concat(L))
                        }
                    }), _defineProperty(this, "_gaCommandSet", function() {
                        for (var _ = arguments.length, C = Array(_), R = 0; R < _; R++) C[R] = arguments[R];
                        "string" == typeof C[0] && (C[0] = _defineProperty({}, C[0], C[1])), m._gtag("set", m._toGtagOptions(C[0]))
                    }), _defineProperty(this, "_gaCommand", function(_) {
                        for (var C = arguments.length, R = Array(C > 1 ? C - 1 : 0), L = 1; L < C; L++) R[L - 1] = arguments[L];
                        switch (_) {
                            case "send":
                                m._gaCommandSend.apply(m, R);
                                break;
                            case "set":
                                m._gaCommandSet.apply(m, R);
                                break;
                            default:
                                console.warn("Command doesn't exist: ".concat(_))
                        }
                    }), _defineProperty(this, "ga", function() {
                        for (var _ = arguments.length, C = Array(_), R = 0; R < _; R++) C[R] = arguments[R];
                        if ("string" == typeof C[0]) m._gaCommand.apply(m, C);
                        else {
                            var L = C[0];
                            m._gtag("get", m._currentMeasurementId, "client_id", function(_) {
                                m._isQueuing = !1;
                                var C = m._queueGtag;
                                for (L({
                                        get: function(C) {
                                            return "clientId" === C ? _ : "trackingId" === C ? m._currentMeasurementId : "apiVersion" === C ? "1" : void 0
                                        }
                                    }); C.length;) {
                                    var R = C.shift();
                                    m._gtag.apply(m, _toConsumableArray(R))
                                }
                            }), m._isQueuing = !0
                        }
                        return m.ga
                    }), _defineProperty(this, "event", function(_, C) {
                        if ("string" == typeof _) m._gtag("event", _, m._toGtagOptions(C));
                        else {
                            var R = _.action,
                                B = _.category,
                                F = _.label,
                                U = _.value,
                                q = _.nonInteraction,
                                V = _.transport,
                                X = _objectWithoutProperties(_, H);
                            if (!B || !R) {
                                console.warn("args.category AND args.action are required in event()");
                                return
                            }
                            var K = {
                                hitType: "event",
                                eventCategory: (0, L.default)(B),
                                eventAction: (0, L.default)(R)
                            };
                            F && (K.eventLabel = (0, L.default)(F)), void 0 !== U && ("number" != typeof U ? console.warn("Expected `args.value` arg to be a Number.") : K.eventValue = U), void 0 !== q && ("boolean" != typeof q ? console.warn("`args.nonInteraction` must be a boolean.") : K.nonInteraction = q), void 0 !== V && ("string" != typeof V ? console.warn("`args.transport` must be a string.") : (-1 === ["beacon", "xhr", "image"].indexOf(V) && console.warn("`args.transport` must be either one of these values: `beacon`, `xhr` or `image`"), K.transport = V)), Object.keys(X).filter(function(m) {
                                return "dimension" === m.substr(0, 9)
                            }).forEach(function(m) {
                                K[m] = X[m]
                            }), Object.keys(X).filter(function(m) {
                                return "metric" === m.substr(0, 6)
                            }).forEach(function(m) {
                                K[m] = X[m]
                            }), m._gaCommand("send", K)
                        }
                    }), _defineProperty(this, "send", function(_) {
                        m._gaCommand("send", _)
                    }), _defineProperty(this, "pageview", function(_, C, R) {
                        var L = null == _ ? void 0 : _.trim();
                        if ("" === L) {
                            console.warn("path cannot be an empty string in .pageview()");
                            return
                        }
                        m._gaCommand("send", "pageview", L, {
                            title: R
                        })
                    }), this.reset()
                }
                return m = [{
                    key: "gtag",
                    value: function() {
                        this._gtag.apply(this, arguments)
                    }
                }, {
                    key: "_appendCustomMap",
                    value: function(m) {
                        var _ = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
                        if (!_) return m;
                        m.custom_map || (m.custom_map = {});
                        for (var C = 1; C <= 200; C++) m.custom_map["dimension".concat(C)] || (m.custom_map["dimension".concat(C)] = "dimension".concat(C)), m.custom_map["metric".concat(C)] || (m.custom_map["metric".concat(C)] = "metric".concat(C));
                        return m
                    }
                }, {
                    key: "outboundLink",
                    value: function(m, _) {
                        var C = m.label;
                        if ("function" != typeof _) {
                            console.warn("hitCallback function is required");
                            return
                        }
                        if (!C) {
                            console.warn("args.label is required in outboundLink()");
                            return
                        }
                        var R = {
                                hitType: "event",
                                eventCategory: "Outbound",
                                eventAction: "Click",
                                eventLabel: (0, L.default)(C)
                            },
                            B = !1,
                            F = setTimeout(function() {
                                B = !0, _()
                            }, 250);
                        R.hitCallback = function() {
                            clearTimeout(F), B || _()
                        }, this._gaCommand("send", R)
                    }
                }], _defineProperties(GA4.prototype, m), _ && _defineProperties(GA4, _), GA4
            }();
            _.GA4 = q;
            var V = new q;
            _.default = V
        },
        76161: function(m, _) {
            "use strict";
            Object.defineProperty(_, "__esModule", {
                value: !0
            }), _.default = void 0, _.default = function() {
                for (var m, _ = arguments.length, C = Array(_), R = 0; R < _; R++) C[R] = arguments[R];
                "undefined" != typeof window && (void 0 === window.gtag && (window.dataLayer = window.dataLayer || [], window.gtag = function() {
                    window.dataLayer.push(arguments)
                }), (m = window).gtag.apply(m, C))
            }
        },
        49089: function(m, _, C) {
            "use strict";

            function _typeof(m) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(m) {
                    return typeof m
                } : function(m) {
                    return m && "function" == typeof Symbol && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m
                })(m)
            }
            _.ZP = void 0;
            var R = function(m, _) {
                if (!_ && m && m.__esModule) return m;
                if (null === m || "object" !== _typeof(m) && "function" != typeof m) return {
                    default: m
                };
                var C = _getRequireWildcardCache(_);
                if (C && C.has(m)) return C.get(m);
                var R = {},
                    L = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var B in m)
                    if ("default" !== B && Object.prototype.hasOwnProperty.call(m, B)) {
                        var F = L ? Object.getOwnPropertyDescriptor(m, B) : null;
                        F && (F.get || F.set) ? Object.defineProperty(R, B, F) : R[B] = m[B]
                    }
                return R.default = m, C && C.set(m, R), R
            }(C(41638));

            function _getRequireWildcardCache(m) {
                if ("function" != typeof WeakMap) return null;
                var _ = new WeakMap,
                    C = new WeakMap;
                return (_getRequireWildcardCache = function(m) {
                    return m ? C : _
                })(m)
            }
            R.GA4;
            var L = R.default;
            _.ZP = L
        },
        25074: function(m, _) {
            "use strict";
            let C = [],
                R = !1,
                L = !1,
                doesOneSignalExist = () => !!window.OneSignal,
                handleOnLoad = (m, _) => {
                    R = !0, window.OneSignal = window.OneSignal || [], window.OneSignal.push(() => {
                        window.OneSignal.init(_)
                    }), window.OneSignal.push(() => {
                        processQueuedOneSignalFunctions(), m()
                    })
                },
                handleOnError = m => {
                    L = !0, processQueuedOneSignalFunctions(), m()
                },
                processQueuedOneSignalFunctions = () => {
                    C.forEach(m => {
                        let {
                            name: _,
                            args: C,
                            promiseResolver: R
                        } = m;
                        R ? B[_](...C).then(m => {
                            R(m)
                        }) : B[_](...C)
                    })
                },
                B = {
                    init: m => new Promise(_ => {
                        if (R) {
                            _();
                            return
                        }
                        if (!m || !m.appId) throw Error("You need to provide your OneSignal appId.");
                        if (!document) {
                            _();
                            return
                        }
                        let C = document.createElement("script");
                        C.id = "onesignal-sdk", C.src = "https://cdn.onesignal.com/sdks/OneSignalSDK.js", C.async = !0, C.onload = () => {
                            handleOnLoad(_, m)
                        }, C.onerror = () => {
                            handleOnError(_)
                        }, document.head.appendChild(C)
                    }),
                    on: function(m, _) {
                        if (!doesOneSignalExist()) {
                            C.push({
                                name: "on",
                                args: arguments
                            });
                            return
                        }
                        window.OneSignal.push(() => {
                            window.OneSignal.on(m, _)
                        })
                    },
                    off: function(m, _) {
                        if (!doesOneSignalExist()) {
                            C.push({
                                name: "off",
                                args: arguments
                            });
                            return
                        }
                        window.OneSignal.push(() => {
                            window.OneSignal.off(m, _)
                        })
                    },
                    once: function(m, _) {
                        if (!doesOneSignalExist()) {
                            C.push({
                                name: "once",
                                args: arguments
                            });
                            return
                        }
                        window.OneSignal.push(() => {
                            window.OneSignal.once(m, _)
                        })
                    },
                    isPushNotificationsEnabled: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "isPushNotificationsEnabled",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.isPushNotificationsEnabled(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    showHttpPrompt: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "showHttpPrompt",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.showHttpPrompt(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    registerForPushNotifications: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "registerForPushNotifications",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.registerForPushNotifications(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    setDefaultNotificationUrl: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "setDefaultNotificationUrl",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.setDefaultNotificationUrl(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    setDefaultTitle: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "setDefaultTitle",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.setDefaultTitle(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    getTags: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "getTags",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.getTags(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    sendTag: function(m, _, R) {
                        return new Promise((B, F) => {
                            if (L) {
                                B();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "sendTag",
                                    args: arguments,
                                    promiseResolver: B
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.sendTag(m, _, R).then(m => B(m)).catch(m => F(m))
                                })
                            } catch (m) {
                                F(m)
                            }
                        })
                    },
                    sendTags: function(m, _) {
                        return new Promise((R, B) => {
                            if (L) {
                                R();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "sendTags",
                                    args: arguments,
                                    promiseResolver: R
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.sendTags(m, _).then(m => R(m)).catch(m => B(m))
                                })
                            } catch (m) {
                                B(m)
                            }
                        })
                    },
                    deleteTag: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "deleteTag",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.deleteTag(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    deleteTags: function(m, _) {
                        return new Promise((R, B) => {
                            if (L) {
                                R();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "deleteTags",
                                    args: arguments,
                                    promiseResolver: R
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.deleteTags(m, _).then(m => R(m)).catch(m => B(m))
                                })
                            } catch (m) {
                                B(m)
                            }
                        })
                    },
                    addListenerForNotificationOpened: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "addListenerForNotificationOpened",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.addListenerForNotificationOpened(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    setSubscription: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "setSubscription",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.setSubscription(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    showHttpPermissionRequest: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "showHttpPermissionRequest",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.showHttpPermissionRequest(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    showNativePrompt: function() {
                        return new Promise((m, _) => {
                            if (L) {
                                m();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "showNativePrompt",
                                    args: arguments,
                                    promiseResolver: m
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.showNativePrompt().then(_ => m(_)).catch(m => _(m))
                                })
                            } catch (m) {
                                _(m)
                            }
                        })
                    },
                    showSlidedownPrompt: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "showSlidedownPrompt",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.showSlidedownPrompt(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    showCategorySlidedown: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "showCategorySlidedown",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.showCategorySlidedown(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    showSmsSlidedown: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "showSmsSlidedown",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.showSmsSlidedown(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    showEmailSlidedown: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "showEmailSlidedown",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.showEmailSlidedown(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    showSmsAndEmailSlidedown: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "showSmsAndEmailSlidedown",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.showSmsAndEmailSlidedown(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    getNotificationPermission: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "getNotificationPermission",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.getNotificationPermission(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    getUserId: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "getUserId",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.getUserId(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    getSubscription: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "getSubscription",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.getSubscription(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    setEmail: function(m, _) {
                        return new Promise((R, B) => {
                            if (L) {
                                R();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "setEmail",
                                    args: arguments,
                                    promiseResolver: R
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.setEmail(m, _).then(m => R(m)).catch(m => B(m))
                                })
                            } catch (m) {
                                B(m)
                            }
                        })
                    },
                    setSMSNumber: function(m, _) {
                        return new Promise((R, B) => {
                            if (L) {
                                R();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "setSMSNumber",
                                    args: arguments,
                                    promiseResolver: R
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.setSMSNumber(m, _).then(m => R(m)).catch(m => B(m))
                                })
                            } catch (m) {
                                B(m)
                            }
                        })
                    },
                    logoutEmail: function() {
                        return new Promise((m, _) => {
                            if (L) {
                                m();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "logoutEmail",
                                    args: arguments,
                                    promiseResolver: m
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.logoutEmail().then(_ => m(_)).catch(m => _(m))
                                })
                            } catch (m) {
                                _(m)
                            }
                        })
                    },
                    logoutSMS: function() {
                        return new Promise((m, _) => {
                            if (L) {
                                m();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "logoutSMS",
                                    args: arguments,
                                    promiseResolver: m
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.logoutSMS().then(_ => m(_)).catch(m => _(m))
                                })
                            } catch (m) {
                                _(m)
                            }
                        })
                    },
                    setExternalUserId: function(m, _) {
                        return new Promise((R, B) => {
                            if (L) {
                                R();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "setExternalUserId",
                                    args: arguments,
                                    promiseResolver: R
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.setExternalUserId(m, _).then(m => R(m)).catch(m => B(m))
                                })
                            } catch (m) {
                                B(m)
                            }
                        })
                    },
                    removeExternalUserId: function() {
                        return new Promise((m, _) => {
                            if (L) {
                                m();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "removeExternalUserId",
                                    args: arguments,
                                    promiseResolver: m
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.removeExternalUserId().then(_ => m(_)).catch(m => _(m))
                                })
                            } catch (m) {
                                _(m)
                            }
                        })
                    },
                    getExternalUserId: function() {
                        return new Promise((m, _) => {
                            if (L) {
                                m();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "getExternalUserId",
                                    args: arguments,
                                    promiseResolver: m
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.getExternalUserId().then(_ => m(_)).catch(m => _(m))
                                })
                            } catch (m) {
                                _(m)
                            }
                        })
                    },
                    provideUserConsent: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "provideUserConsent",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.provideUserConsent(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    getEmailId: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "getEmailId",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.getEmailId(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    getSMSId: function(m) {
                        return new Promise((_, R) => {
                            if (L) {
                                _();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "getSMSId",
                                    args: arguments,
                                    promiseResolver: _
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.getSMSId(m).then(m => _(m)).catch(m => R(m))
                                })
                            } catch (m) {
                                R(m)
                            }
                        })
                    },
                    sendOutcome: function(m, _) {
                        return new Promise((R, B) => {
                            if (L) {
                                R();
                                return
                            }
                            if (!doesOneSignalExist()) {
                                C.push({
                                    name: "sendOutcome",
                                    args: arguments,
                                    promiseResolver: R
                                });
                                return
                            }
                            try {
                                window.OneSignal.push(() => {
                                    window.OneSignal.sendOutcome(m, _).then(m => R(m)).catch(m => B(m))
                                })
                            } catch (m) {
                                B(m)
                            }
                        })
                    }
                };
            _.Z = B
        },
        93967: function(m, _) {
            var C;
            /*!
            	Copyright (c) 2018 Jed Watson.
            	Licensed under the MIT License (MIT), see
            	http://jedwatson.github.io/classnames
            */
            ! function() {
                "use strict";
                var R = {}.hasOwnProperty;

                function classNames() {
                    for (var m = "", _ = 0; _ < arguments.length; _++) {
                        var C = arguments[_];
                        C && (m = appendClass(m, function(m) {
                            if ("string" == typeof m || "number" == typeof m) return m;
                            if ("object" != typeof m) return "";
                            if (Array.isArray(m)) return classNames.apply(null, m);
                            if (m.toString !== Object.prototype.toString && !m.toString.toString().includes("[native code]")) return m.toString();
                            var _ = "";
                            for (var C in m) R.call(m, C) && m[C] && (_ = appendClass(_, C));
                            return _
                        }(C)))
                    }
                    return m
                }

                function appendClass(m, _) {
                    return _ ? m ? m + " " + _ : m + _ : m
                }
                m.exports ? (classNames.default = classNames, m.exports = classNames) : void 0 !== (C = (function() {
                    return classNames
                }).apply(_, [])) && (m.exports = C)
            }()
        },
        4942: function(m, _, C) {
            "use strict";
            C.d(_, {
                Z: function() {
                    return _defineProperty
                }
            });
            var R = C(83997);

            function _defineProperty(m, _, C) {
                return (_ = (0, R.Z)(_)) in m ? Object.defineProperty(m, _, {
                    value: C,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : m[_] = C, m
            }
        },
        1413: function(m, _, C) {
            "use strict";
            C.d(_, {
                Z: function() {
                    return _objectSpread2
                }
            });
            var R = C(4942);

            function ownKeys(m, _) {
                var C = Object.keys(m);
                if (Object.getOwnPropertySymbols) {
                    var R = Object.getOwnPropertySymbols(m);
                    _ && (R = R.filter(function(_) {
                        return Object.getOwnPropertyDescriptor(m, _).enumerable
                    })), C.push.apply(C, R)
                }
                return C
            }

            function _objectSpread2(m) {
                for (var _ = 1; _ < arguments.length; _++) {
                    var C = null != arguments[_] ? arguments[_] : {};
                    _ % 2 ? ownKeys(Object(C), !0).forEach(function(_) {
                        (0, R.Z)(m, _, C[_])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(m, Object.getOwnPropertyDescriptors(C)) : ownKeys(Object(C)).forEach(function(_) {
                        Object.defineProperty(m, _, Object.getOwnPropertyDescriptor(C, _))
                    })
                }
                return m
            }
        },
        83997: function(m, _, C) {
            "use strict";
            C.d(_, {
                Z: function() {
                    return toPropertyKey
                }
            });
            var R = C(71002);

            function toPropertyKey(m) {
                var _ = function(m, _) {
                    if ("object" != (0, R.Z)(m) || !m) return m;
                    var C = m[Symbol.toPrimitive];
                    if (void 0 !== C) {
                        var L = C.call(m, _ || "default");
                        if ("object" != (0, R.Z)(L)) return L;
                        throw TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === _ ? String : Number)(m)
                }(m, "string");
                return "symbol" == (0, R.Z)(_) ? _ : _ + ""
            }
        },
        71002: function(m, _, C) {
            "use strict";

            function _typeof(m) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(m) {
                    return typeof m
                } : function(m) {
                    return m && "function" == typeof Symbol && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m
                })(m)
            }
            C.d(_, {
                Z: function() {
                    return _typeof
                }
            })
        },
        60811: function(m, _, C) {
            "use strict";
            C.d(_, {
                G: function() {
                    return getAsyncContextStrategy
                }
            });
            var R = C(13533),
                L = C(16824),
                B = C(29531),
                F = C(43927);
            let AsyncContextStack = class AsyncContextStack {
                constructor(m, _) {
                    let C, R;
                    C = m || new F.s, R = _ || new F.s, this._stack = [{
                        scope: C
                    }], this._isolationScope = R
                }
                withScope(m) {
                    let _;
                    let C = this._pushScope();
                    try {
                        _ = m(C)
                    } catch (m) {
                        throw this._popScope(), m
                    }
                    return (0, L.J8)(_) ? _.then(m => (this._popScope(), m), m => {
                        throw this._popScope(), m
                    }) : (this._popScope(), _)
                }
                getClient() {
                    return this.getStackTop().client
                }
                getScope() {
                    return this.getStackTop().scope
                }
                getIsolationScope() {
                    return this._isolationScope
                }
                getStackTop() {
                    return this._stack[this._stack.length - 1]
                }
                _pushScope() {
                    let m = this.getScope().clone();
                    return this._stack.push({
                        client: this.getClient(),
                        scope: m
                    }), m
                }
                _popScope() {
                    return !(this._stack.length <= 1) && !!this._stack.pop()
                }
            };

            function getAsyncContextStack() {
                let m = (0, R.c)(),
                    _ = (0, R.q)(m);
                return _.stack = _.stack || new AsyncContextStack((0, B.Y)("defaultCurrentScope", () => new F.s), (0, B.Y)("defaultIsolationScope", () => new F.s))
            }

            function withScope(m) {
                return getAsyncContextStack().withScope(m)
            }

            function withSetScope(m, _) {
                let C = getAsyncContextStack();
                return C.withScope(() => (C.getStackTop().scope = m, _(m)))
            }

            function withIsolationScope(m) {
                return getAsyncContextStack().withScope(() => m(getAsyncContextStack().getIsolationScope()))
            }

            function getAsyncContextStrategy(m) {
                let _ = (0, R.q)(m);
                return _.acs ? _.acs : {
                    withIsolationScope,
                    withScope,
                    withSetScope,
                    withSetIsolationScope: (m, _) => withIsolationScope(_),
                    getCurrentScope: () => getAsyncContextStack().getScope(),
                    getIsolationScope: () => getAsyncContextStack().getIsolationScope()
                }
            }
        },
        13533: function(m, _, C) {
            "use strict";
            C.d(_, {
                c: function() {
                    return getMainCarrier
                },
                q: function() {
                    return getSentryCarrier
                }
            });
            var R = C(29531),
                L = C(42990);

            function getMainCarrier() {
                return getSentryCarrier(R.GLOBAL_OBJ), R.GLOBAL_OBJ
            }

            function getSentryCarrier(m) {
                let _ = m.__SENTRY__ = m.__SENTRY__ || {};
                return _.version = _.version || L.J, _[L.J] = _[L.J] || {}
            }
        },
        73243: function(m, _, C) {
            "use strict";
            C.d(_, {
                J: function() {
                    return R
                }
            });
            let R = "production"
        },
        73076: function(m, _, C) {
            "use strict";
            C.d(_, {
                $e: function() {
                    return withScope
                },
                aF: function() {
                    return getIsolationScope
                },
                lW: function() {
                    return getGlobalScope
                },
                nZ: function() {
                    return getCurrentScope
                },
                s3: function() {
                    return getClient
                }
            });
            var R = C(29531),
                L = C(60811),
                B = C(13533),
                F = C(43927);

            function getCurrentScope() {
                let m = (0, B.c)(),
                    _ = (0, L.G)(m);
                return _.getCurrentScope()
            }

            function getIsolationScope() {
                let m = (0, B.c)(),
                    _ = (0, L.G)(m);
                return _.getIsolationScope()
            }

            function getGlobalScope() {
                return (0, R.Y)("globalScope", () => new F.s)
            }

            function withScope(...m) {
                let _ = (0, B.c)(),
                    C = (0, L.G)(_);
                if (2 === m.length) {
                    let [_, R] = m;
                    return _ ? C.withSetScope(_, R) : C.withScope(R)
                }
                return C.withScope(m[0])
            }

            function getClient() {
                return getCurrentScope().getClient()
            }
        },
        94223: function(m, _, C) {
            "use strict";
            C.d(_, {
                X: function() {
                    return R
                }
            });
            let R = !1
        },
        11793: function(m, _, C) {
            "use strict";
            C.d(_, {
                Mq: function() {
                    return createEventEnvelope
                },
                Q3: function() {
                    return createSessionEnvelope
                },
                uE: function() {
                    return createSpanEnvelope
                }
            });
            var R = C(39432),
                L = C(73326),
                B = C(72123),
                F = C(81585);

            function createSessionEnvelope(m, _, C, B) {
                let F = (0, R.HY)(C),
                    U = {
                        sent_at: new Date().toISOString(),
                        ...F && {
                            sdk: F
                        },
                        ...!!B && _ && {
                            dsn: (0, L.RA)(_)
                        }
                    },
                    H = "aggregates" in m ? [{
                        type: "sessions"
                    }, m] : [{
                        type: "session"
                    }, m.toJSON()];
                return (0, R.Jd)(U, [H])
            }

            function createEventEnvelope(m, _, C, L) {
                var B;
                let F = (0, R.HY)(C),
                    U = m.type && "replay_event" !== m.type ? m.type : "event";
                (B = C && C.sdk) && (m.sdk = m.sdk || {}, m.sdk.name = m.sdk.name || B.name, m.sdk.version = m.sdk.version || B.version, m.sdk.integrations = [...m.sdk.integrations || [], ...B.integrations || []], m.sdk.packages = [...m.sdk.packages || [], ...B.packages || []]);
                let H = (0, R.Cd)(m, F, L, _);
                delete m.sdkProcessingMetadata;
                let q = [{
                    type: U
                }, m];
                return (0, R.Jd)(H, [q])
            }

            function createSpanEnvelope(m, _) {
                let C = (0, B.jC)(m[0]),
                    U = _ && _.getDsn(),
                    H = _ && _.getOptions().tunnel,
                    q = {
                        sent_at: new Date().toISOString(),
                        ...!!C.trace_id && !!C.public_key && {
                            trace: C
                        },
                        ...!!H && U && {
                            dsn: (0, L.RA)(U)
                        }
                    },
                    V = _ && _.getOptions().beforeSendSpan,
                    X = V ? m => V((0, F.XU)(m)) : m => (0, F.XU)(m),
                    K = [];
                for (let _ of m) {
                    let m = X(_);
                    m && K.push((0, R.KQ)(m))
                }
                return (0, R.Jd)(q, K)
            }
        },
        39424: function(m, _, C) {
            "use strict";
            C.d(_, {
                Qy: function() {
                    return addEventProcessor
                },
                Tb: function() {
                    return captureException
                },
                av: function() {
                    return setUser
                },
                cg: function() {
                    return captureSession
                },
                eN: function() {
                    return captureEvent
                },
                v: function() {
                    return setContext
                },
                yj: function() {
                    return startSession
                },
                yl: function() {
                    return flush
                }
            });
            var R = C(41001),
                L = C(29531),
                B = C(73243),
                F = C(73076),
                U = C(94223),
                H = C(10042),
                q = C(5808);

            function captureException(m, _) {
                return (0, F.nZ)().captureException(m, (0, q.U0)(_))
            }

            function captureEvent(m, _) {
                return (0, F.nZ)().captureEvent(m, _)
            }

            function setContext(m, _) {
                (0, F.aF)().setContext(m, _)
            }

            function setUser(m) {
                (0, F.aF)().setUser(m)
            }
            async function flush(m) {
                let _ = (0, F.s3)();
                return _ ? _.flush(m) : (U.X && R.kg.warn("Cannot flush events. No client defined."), Promise.resolve(!1))
            }

            function addEventProcessor(m) {
                (0, F.aF)().addEventProcessor(m)
            }

            function startSession(m) {
                let _ = (0, F.s3)(),
                    C = (0, F.aF)(),
                    R = (0, F.nZ)(),
                    {
                        release: U,
                        environment: q = B.J
                    } = _ && _.getOptions() || {},
                    {
                        userAgent: V
                    } = L.GLOBAL_OBJ.navigator || {},
                    X = (0, H.Hv)({
                        release: U,
                        environment: q,
                        user: R.getUser() || C.getUser(),
                        ...V && {
                            userAgent: V
                        },
                        ...m
                    }),
                    K = C.getSession();
                return K && "ok" === K.status && (0, H.CT)(K, {
                    status: "exited"
                }), endSession(), C.setSession(X), R.setSession(X), X
            }

            function endSession() {
                let m = (0, F.aF)(),
                    _ = (0, F.nZ)(),
                    C = _.getSession() || m.getSession();
                C && (0, H.RJ)(C), _sendSessionUpdate(), m.setSession(), _.setSession()
            }

            function _sendSessionUpdate() {
                let m = (0, F.aF)(),
                    _ = (0, F.nZ)(),
                    C = (0, F.s3)(),
                    R = _.getSession() || m.getSession();
                R && C && C.captureSession(R)
            }

            function captureSession(m = !1) {
                if (m) {
                    endSession();
                    return
                }
                _sendSessionUpdate()
            }
        },
        72751: function(m, _, C) {
            "use strict";
            C.d(_, {
                y: function() {
                    return getMetricSummaryJsonForSpan
                }
            });
            var R = C(27179);

            function getMetricSummaryJsonForSpan(m) {
                let _ = m._sentryMetrics;
                if (!_) return;
                let C = {};
                for (let [, [m, L]] of _) {
                    let _ = C[m] || (C[m] = []);
                    _.push((0, R.Jr)(L))
                }
                return C
            }
        },
        43927: function(m, _, C) {
            "use strict";
            C.d(_, {
                s: function() {
                    return V
                }
            });
            var R = C(19548),
                L = C(16824),
                B = C(26181),
                F = C(41982),
                U = C(41001),
                H = C(10042),
                q = C(89366);
            let ScopeClass = class ScopeClass {
                constructor() {
                    this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = (0, R.Q)()
                }
                clone() {
                    let m = new ScopeClass;
                    return m._breadcrumbs = [...this._breadcrumbs], m._tags = { ...this._tags
                    }, m._extra = { ...this._extra
                    }, m._contexts = { ...this._contexts
                    }, m._user = this._user, m._level = this._level, m._session = this._session, m._transactionName = this._transactionName, m._fingerprint = this._fingerprint, m._eventProcessors = [...this._eventProcessors], m._requestSession = this._requestSession, m._attachments = [...this._attachments], m._sdkProcessingMetadata = { ...this._sdkProcessingMetadata
                    }, m._propagationContext = { ...this._propagationContext
                    }, m._client = this._client, m._lastEventId = this._lastEventId, (0, q.D)(m, (0, q.Y)(this)), m
                }
                setClient(m) {
                    this._client = m
                }
                setLastEventId(m) {
                    this._lastEventId = m
                }
                getClient() {
                    return this._client
                }
                lastEventId() {
                    return this._lastEventId
                }
                addScopeListener(m) {
                    this._scopeListeners.push(m)
                }
                addEventProcessor(m) {
                    return this._eventProcessors.push(m), this
                }
                setUser(m) {
                    return this._user = m || {
                        email: void 0,
                        id: void 0,
                        ip_address: void 0,
                        username: void 0
                    }, this._session && (0, H.CT)(this._session, {
                        user: m
                    }), this._notifyScopeListeners(), this
                }
                getUser() {
                    return this._user
                }
                getRequestSession() {
                    return this._requestSession
                }
                setRequestSession(m) {
                    return this._requestSession = m, this
                }
                setTags(m) {
                    return this._tags = { ...this._tags,
                        ...m
                    }, this._notifyScopeListeners(), this
                }
                setTag(m, _) {
                    return this._tags = { ...this._tags,
                        [m]: _
                    }, this._notifyScopeListeners(), this
                }
                setExtras(m) {
                    return this._extra = { ...this._extra,
                        ...m
                    }, this._notifyScopeListeners(), this
                }
                setExtra(m, _) {
                    return this._extra = { ...this._extra,
                        [m]: _
                    }, this._notifyScopeListeners(), this
                }
                setFingerprint(m) {
                    return this._fingerprint = m, this._notifyScopeListeners(), this
                }
                setLevel(m) {
                    return this._level = m, this._notifyScopeListeners(), this
                }
                setTransactionName(m) {
                    return this._transactionName = m, this._notifyScopeListeners(), this
                }
                setContext(m, _) {
                    return null === _ ? delete this._contexts[m] : this._contexts[m] = _, this._notifyScopeListeners(), this
                }
                setSession(m) {
                    return m ? this._session = m : delete this._session, this._notifyScopeListeners(), this
                }
                getSession() {
                    return this._session
                }
                update(m) {
                    if (!m) return this;
                    let _ = "function" == typeof m ? m(this) : m,
                        [C, R] = _ instanceof V ? [_.getScopeData(), _.getRequestSession()] : (0, L.PO)(_) ? [m, m.requestSession] : [],
                        {
                            tags: B,
                            extra: F,
                            user: U,
                            contexts: H,
                            level: q,
                            fingerprint: X = [],
                            propagationContext: K
                        } = C || {};
                    return this._tags = { ...this._tags,
                        ...B
                    }, this._extra = { ...this._extra,
                        ...F
                    }, this._contexts = { ...this._contexts,
                        ...H
                    }, U && Object.keys(U).length && (this._user = U), q && (this._level = q), X.length && (this._fingerprint = X), K && (this._propagationContext = K), R && (this._requestSession = R), this
                }
                clear() {
                    return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, (0, q.D)(this, void 0), this._attachments = [], this._propagationContext = (0, R.Q)(), this._notifyScopeListeners(), this
                }
                addBreadcrumb(m, _) {
                    let C = "number" == typeof _ ? _ : 100;
                    if (C <= 0) return this;
                    let R = {
                            timestamp: (0, B.yW)(),
                            ...m
                        },
                        L = this._breadcrumbs;
                    return L.push(R), this._breadcrumbs = L.length > C ? L.slice(-C) : L, this._notifyScopeListeners(), this
                }
                getLastBreadcrumb() {
                    return this._breadcrumbs[this._breadcrumbs.length - 1]
                }
                clearBreadcrumbs() {
                    return this._breadcrumbs = [], this._notifyScopeListeners(), this
                }
                addAttachment(m) {
                    return this._attachments.push(m), this
                }
                clearAttachments() {
                    return this._attachments = [], this
                }
                getScopeData() {
                    return {
                        breadcrumbs: this._breadcrumbs,
                        attachments: this._attachments,
                        contexts: this._contexts,
                        tags: this._tags,
                        extra: this._extra,
                        user: this._user,
                        level: this._level,
                        fingerprint: this._fingerprint || [],
                        eventProcessors: this._eventProcessors,
                        propagationContext: this._propagationContext,
                        sdkProcessingMetadata: this._sdkProcessingMetadata,
                        transactionName: this._transactionName,
                        span: (0, q.Y)(this)
                    }
                }
                setSDKProcessingMetadata(m) {
                    return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata,
                        ...m
                    }, this
                }
                setPropagationContext(m) {
                    return this._propagationContext = m, this
                }
                getPropagationContext() {
                    return this._propagationContext
                }
                captureException(m, _) {
                    let C = _ && _.event_id ? _.event_id : (0, F.DM)();
                    if (!this._client) return U.kg.warn("No client configured on scope - will not capture exception!"), C;
                    let R = Error("Sentry syntheticException");
                    return this._client.captureException(m, {
                        originalException: m,
                        syntheticException: R,
                        ..._,
                        event_id: C
                    }, this), C
                }
                captureMessage(m, _, C) {
                    let R = C && C.event_id ? C.event_id : (0, F.DM)();
                    if (!this._client) return U.kg.warn("No client configured on scope - will not capture message!"), R;
                    let L = Error(m);
                    return this._client.captureMessage(m, _, {
                        originalException: m,
                        syntheticException: L,
                        ...C,
                        event_id: R
                    }, this), R
                }
                captureEvent(m, _) {
                    let C = _ && _.event_id ? _.event_id : (0, F.DM)();
                    return this._client ? this._client.captureEvent(m, { ..._,
                        event_id: C
                    }, this) : U.kg.warn("No client configured on scope - will not capture event!"), C
                }
                _notifyScopeListeners() {
                    this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach(m => {
                        m(this)
                    }), this._notifyingListeners = !1)
                }
            };
            let V = ScopeClass
        },
        31218: function(m, _, C) {
            "use strict";
            C.d(_, {
                $J: function() {
                    return B
                },
                E1: function() {
                    return H
                },
                JQ: function() {
                    return X
                },
                S3: function() {
                    return F
                },
                TE: function() {
                    return L
                },
                Wb: function() {
                    return q
                },
                Zj: function() {
                    return R
                },
                ju: function() {
                    return U
                },
                p6: function() {
                    return V
                }
            });
            let R = "sentry.source",
                L = "sentry.sample_rate",
                B = "sentry.op",
                F = "sentry.origin",
                U = "sentry.idle_span_finish_reason",
                H = "sentry.measurement_unit",
                q = "sentry.measurement_value",
                V = "sentry.profile_id",
                X = "sentry.exclusive_time"
        },
        10042: function(m, _, C) {
            "use strict";
            C.d(_, {
                CT: function() {
                    return updateSession
                },
                Hv: function() {
                    return makeSession
                },
                RJ: function() {
                    return closeSession
                }
            });
            var R = C(26181),
                L = C(41982),
                B = C(27179);

            function makeSession(m) {
                let _ = (0, R.ph)(),
                    C = {
                        sid: (0, L.DM)(),
                        init: !0,
                        timestamp: _,
                        started: _,
                        duration: 0,
                        status: "ok",
                        errors: 0,
                        ignoreDuration: !1,
                        toJSON: () => (0, B.Jr)({
                            sid: `${C.sid}`,
                            init: C.init,
                            started: new Date(1e3 * C.started).toISOString(),
                            timestamp: new Date(1e3 * C.timestamp).toISOString(),
                            status: C.status,
                            errors: C.errors,
                            did: "number" == typeof C.did || "string" == typeof C.did ? `${C.did}` : void 0,
                            duration: C.duration,
                            abnormal_mechanism: C.abnormal_mechanism,
                            attrs: {
                                release: C.release,
                                environment: C.environment,
                                ip_address: C.ipAddress,
                                user_agent: C.userAgent
                            }
                        })
                    };
                return m && updateSession(C, m), C
            }

            function updateSession(m, _ = {}) {
                if (!_.user || (!m.ipAddress && _.user.ip_address && (m.ipAddress = _.user.ip_address), m.did || _.did || (m.did = _.user.id || _.user.email || _.user.username)), m.timestamp = _.timestamp || (0, R.ph)(), _.abnormal_mechanism && (m.abnormal_mechanism = _.abnormal_mechanism), _.ignoreDuration && (m.ignoreDuration = _.ignoreDuration), _.sid && (m.sid = 32 === _.sid.length ? _.sid : (0, L.DM)()), void 0 !== _.init && (m.init = _.init), !m.did && _.did && (m.did = `${_.did}`), "number" == typeof _.started && (m.started = _.started), m.ignoreDuration) m.duration = void 0;
                else if ("number" == typeof _.duration) m.duration = _.duration;
                else {
                    let _ = m.timestamp - m.started;
                    m.duration = _ >= 0 ? _ : 0
                }
                _.release && (m.release = _.release), _.environment && (m.environment = _.environment), !m.ipAddress && _.ipAddress && (m.ipAddress = _.ipAddress), !m.userAgent && _.userAgent && (m.userAgent = _.userAgent), "number" == typeof _.errors && (m.errors = _.errors), _.status && (m.status = _.status)
            }

            function closeSession(m, _) {
                let C = {};
                _ ? C = {
                    status: _
                } : "ok" === m.status && (C = {
                    status: "exited"
                }), updateSession(m, C)
            }
        },
        72123: function(m, _, C) {
            "use strict";
            C.d(_, {
                Lh: function() {
                    return freezeDscOnSpan
                },
                _l: function() {
                    return getDynamicSamplingContextFromClient
                },
                jC: function() {
                    return getDynamicSamplingContextFromSpan
                }
            });
            var R = C(27179),
                L = C(60859),
                B = C(73243),
                F = C(73076),
                U = C(31218),
                H = C(67973),
                q = C(81585);
            let V = "_frozenDsc";

            function freezeDscOnSpan(m, _) {
                (0, R.xp)(m, V, _)
            }

            function getDynamicSamplingContextFromClient(m, _) {
                let C = _.getOptions(),
                    {
                        publicKey: L
                    } = _.getDsn() || {},
                    F = (0, R.Jr)({
                        environment: C.environment || B.J,
                        release: C.release,
                        public_key: L,
                        trace_id: m
                    });
                return _.emit("createDsc", F), F
            }

            function getDynamicSamplingContextFromSpan(m) {
                let _ = (0, F.s3)();
                if (!_) return {};
                let C = getDynamicSamplingContextFromClient((0, q.XU)(m).trace_id || "", _),
                    R = (0, q.Gx)(m),
                    B = R[V];
                if (B) return B;
                let X = R.spanContext().traceState,
                    K = X && X.get("sentry.dsc"),
                    Y = K && (0, L.EN)(K);
                if (Y) return Y;
                let Q = (0, q.XU)(R),
                    et = Q.data || {},
                    er = et[U.TE];
                null != er && (C.sample_rate = `${er}`);
                let en = et[U.Zj],
                    ei = Q.description;
                return "url" !== en && ei && (C.transaction = ei), (0, H.z)() && (C.sampled = String((0, q.Tt)(R))), _.emit("createDsc", C, R), C
            }
        },
        72441: function(m, _, C) {
            "use strict";
            C.d(_, {
                l: function() {
                    return timedEventsToMeasurements
                },
                o: function() {
                    return setMeasurement
                }
            });
            var R = C(31218),
                L = C(81585);

            function setMeasurement(m, _, C, B = (0, L.HN)()) {
                let F = B && (0, L.Gx)(B);
                F && F.addEvent(m, {
                    [R.Wb]: _,
                    [R.E1]: C
                })
            }

            function timedEventsToMeasurements(m) {
                if (!m || 0 === m.length) return;
                let _ = {};
                return m.forEach(m => {
                    let C = m.attributes || {},
                        L = C[R.E1],
                        B = C[R.Wb];
                    "string" == typeof L && "number" == typeof B && (_[m.name] = {
                        value: B,
                        unit: L
                    })
                }), _
            }
        },
        58915: function(m, _, C) {
            "use strict";
            C.d(_, {
                b: function() {
                    return SentryNonRecordingSpan
                }
            });
            var R = C(41982),
                L = C(81585);
            let SentryNonRecordingSpan = class SentryNonRecordingSpan {
                constructor(m = {}) {
                    this._traceId = m.traceId || (0, R.DM)(), this._spanId = m.spanId || (0, R.DM)().substring(16)
                }
                spanContext() {
                    return {
                        spanId: this._spanId,
                        traceId: this._traceId,
                        traceFlags: L.ve
                    }
                }
                end(m) {}
                setAttribute(m, _) {
                    return this
                }
                setAttributes(m) {
                    return this
                }
                setStatus(m) {
                    return this
                }
                updateName(m) {
                    return this
                }
                isRecording() {
                    return !1
                }
                addEvent(m, _, C) {
                    return this
                }
                addLink(m) {
                    return this
                }
                addLinks(m) {
                    return this
                }
                recordException(m, _) {}
            }
        },
        69737: function(m, _, C) {
            "use strict";
            C.d(_, {
                OP: function() {
                    return L
                },
                Q0: function() {
                    return setHttpStatus
                },
                jt: function() {
                    return B
                },
                pq: function() {
                    return R
                }
            });
            let R = 0,
                L = 1,
                B = 2;

            function setHttpStatus(m, _) {
                m.setAttribute("http.response.status_code", _);
                let C = function(m) {
                    if (m < 400 && m >= 100) return {
                        code: L
                    };
                    if (m >= 400 && m < 500) switch (m) {
                        case 401:
                            return {
                                code: B,
                                message: "unauthenticated"
                            };
                        case 403:
                            return {
                                code: B,
                                message: "permission_denied"
                            };
                        case 404:
                            return {
                                code: B,
                                message: "not_found"
                            };
                        case 409:
                            return {
                                code: B,
                                message: "already_exists"
                            };
                        case 413:
                            return {
                                code: B,
                                message: "failed_precondition"
                            };
                        case 429:
                            return {
                                code: B,
                                message: "resource_exhausted"
                            };
                        case 499:
                            return {
                                code: B,
                                message: "cancelled"
                            };
                        default:
                            return {
                                code: B,
                                message: "invalid_argument"
                            }
                    }
                    if (m >= 500 && m < 600) switch (m) {
                        case 501:
                            return {
                                code: B,
                                message: "unimplemented"
                            };
                        case 503:
                            return {
                                code: B,
                                message: "unavailable"
                            };
                        case 504:
                            return {
                                code: B,
                                message: "deadline_exceeded"
                            };
                        default:
                            return {
                                code: B,
                                message: "internal_error"
                            }
                    }
                    return {
                        code: B,
                        message: "unknown_error"
                    }
                }(_);
                "unknown_error" !== C.message && m.setStatus(C)
            }
        },
        99450: function(m, _, C) {
            "use strict";
            C.d(_, {
                qp: function() {
                    return startInactiveSpan
                },
                GK: function() {
                    return startSpan
                },
                _d: function() {
                    return withActiveSpan
                }
            });
            var R = C(13533),
                L = C(73076),
                B = C(60811),
                F = C(31218),
                U = C(16824),
                H = C(67973),
                q = C(89366),
                V = C(81585),
                X = C(72123),
                K = C(41001),
                Y = C(94223),
                Q = C(79769),
                et = C(58915),
                er = C(41982),
                en = C(26181),
                ei = C(27179),
                eo = C(11793),
                ea = C(72751),
                es = C(72441);
            let ec = "_sentryScope",
                el = "_sentryIsolationScope";

            function getCapturedScopesOnSpan(m) {
                return {
                    scope: m[ec],
                    isolationScope: m[el]
                }
            }
            let SentrySpan = class SentrySpan {
                constructor(m = {}) {
                    this._traceId = m.traceId || (0, er.DM)(), this._spanId = m.spanId || (0, er.DM)().substring(16), this._startTime = m.startTimestamp || (0, en.ph)(), this._attributes = {}, this.setAttributes({
                        [F.S3]: "manual",
                        [F.$J]: m.op,
                        ...m.attributes
                    }), this._name = m.name, m.parentSpanId && (this._parentSpanId = m.parentSpanId), "sampled" in m && (this._sampled = m.sampled), m.endTimestamp && (this._endTime = m.endTimestamp), this._events = [], this._isStandaloneSpan = m.isStandalone, this._endTime && this._onSpanEnded()
                }
                addLink(m) {
                    return this
                }
                addLinks(m) {
                    return this
                }
                recordException(m, _) {}
                spanContext() {
                    let {
                        _spanId: m,
                        _traceId: _,
                        _sampled: C
                    } = this;
                    return {
                        spanId: m,
                        traceId: _,
                        traceFlags: C ? V.i0 : V.ve
                    }
                }
                setAttribute(m, _) {
                    return void 0 === _ ? delete this._attributes[m] : this._attributes[m] = _, this
                }
                setAttributes(m) {
                    return Object.keys(m).forEach(_ => this.setAttribute(_, m[_])), this
                }
                updateStartTime(m) {
                    this._startTime = (0, V.$k)(m)
                }
                setStatus(m) {
                    return this._status = m, this
                }
                updateName(m) {
                    return this._name = m, this
                }
                end(m) {
                    this._endTime || (this._endTime = (0, V.$k)(m), function(m) {
                        if (!Y.X) return;
                        let {
                            description: _ = "< unknown name >",
                            op: C = "< unknown op >"
                        } = (0, V.XU)(m), {
                            spanId: R
                        } = m.spanContext(), L = (0, V.Gx)(m), B = L === m, F = `[Tracing] Finishing "${C}" ${B?"root ":""}span "${_}" with ID ${R}`;
                        K.kg.log(F)
                    }(this), this._onSpanEnded())
                }
                getSpanJSON() {
                    return (0, ei.Jr)({
                        data: this._attributes,
                        description: this._name,
                        op: this._attributes[F.$J],
                        parent_span_id: this._parentSpanId,
                        span_id: this._spanId,
                        start_timestamp: this._startTime,
                        status: (0, V._4)(this._status),
                        timestamp: this._endTime,
                        trace_id: this._traceId,
                        origin: this._attributes[F.S3],
                        _metrics_summary: (0, ea.y)(this),
                        profile_id: this._attributes[F.p6],
                        exclusive_time: this._attributes[F.JQ],
                        measurements: (0, es.l)(this._events),
                        is_segment: this._isStandaloneSpan && (0, V.Gx)(this) === this || void 0,
                        segment_id: this._isStandaloneSpan ? (0, V.Gx)(this).spanContext().spanId : void 0
                    })
                }
                isRecording() {
                    return !this._endTime && !!this._sampled
                }
                addEvent(m, _, C) {
                    Y.X && K.kg.log("[Tracing] Adding an event to span:", m);
                    let R = isSpanTimeInput(_) ? _ : C || (0, en.ph)(),
                        L = isSpanTimeInput(_) ? {} : _ || {},
                        B = {
                            name: m,
                            time: (0, V.$k)(R),
                            attributes: L
                        };
                    return this._events.push(B), this
                }
                isStandaloneSpan() {
                    return !!this._isStandaloneSpan
                }
                _onSpanEnded() {
                    let m = (0, L.s3)();
                    m && m.emit("spanEnd", this);
                    let _ = this._isStandaloneSpan || this === (0, V.Gx)(this);
                    if (!_) return;
                    if (this._isStandaloneSpan) {
                        this._sampled ? function(m) {
                            let _ = (0, L.s3)();
                            if (!_) return;
                            let C = m[1];
                            if (!C || 0 === C.length) {
                                _.recordDroppedEvent("before_send", "span");
                                return
                            }
                            let R = _.getTransport();
                            R && R.send(m).then(null, m => {
                                Y.X && K.kg.error("Error while sending span:", m)
                            })
                        }((0, eo.uE)([this], m)) : (Y.X && K.kg.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled."), m && m.recordDroppedEvent("sample_rate", "span"));
                        return
                    }
                    let C = this._convertSpanToTransaction();
                    if (C) {
                        let m = getCapturedScopesOnSpan(this).scope || (0, L.nZ)();
                        m.captureEvent(C)
                    }
                }
                _convertSpanToTransaction() {
                    if (!isFullFinishedSpan((0, V.XU)(this))) return;
                    this._name || (Y.X && K.kg.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this._name = "<unlabeled transaction>");
                    let {
                        scope: m,
                        isolationScope: _
                    } = getCapturedScopesOnSpan(this), C = m || (0, L.nZ)(), R = C.getClient() || (0, L.s3)();
                    if (!0 !== this._sampled) {
                        Y.X && K.kg.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."), R && R.recordDroppedEvent("sample_rate", "transaction");
                        return
                    }
                    let B = (0, V.Dp)(this).filter(m => m !== this && !(m instanceof SentrySpan && m.isStandaloneSpan())),
                        U = B.map(m => (0, V.XU)(m)).filter(isFullFinishedSpan),
                        H = this._attributes[F.Zj],
                        q = {
                            contexts: {
                                trace: (0, V.HR)(this)
                            },
                            spans: U.length > 1e3 ? U.sort((m, _) => m.start_timestamp - _.start_timestamp).slice(0, 1e3) : U,
                            start_timestamp: this._startTime,
                            timestamp: this._endTime,
                            transaction: this._name,
                            type: "transaction",
                            sdkProcessingMetadata: {
                                capturedSpanScope: m,
                                capturedSpanIsolationScope: _,
                                ...(0, ei.Jr)({
                                    dynamicSamplingContext: (0, X.jC)(this)
                                })
                            },
                            _metrics_summary: (0, ea.y)(this),
                            ...H && {
                                transaction_info: {
                                    source: H
                                }
                            }
                        },
                        Q = (0, es.l)(this._events),
                        et = Q && Object.keys(Q).length;
                    return et && (Y.X && K.kg.log("[Measurements] Adding measurements to transaction event", JSON.stringify(Q, void 0, 2)), q.measurements = Q), q
                }
            };

            function isSpanTimeInput(m) {
                return m && "number" == typeof m || m instanceof Date || Array.isArray(m)
            }

            function isFullFinishedSpan(m) {
                return !!m.start_timestamp && !!m.timestamp && !!m.span_id && !!m.trace_id
            }
            var eu = C(69737);
            let ed = "__SENTRY_SUPPRESS_TRACING__";

            function startSpan(m, _) {
                let C = getAcs();
                if (C.startSpan) return C.startSpan(m, _);
                let R = parseSentrySpanArguments(m),
                    {
                        forceTransaction: B,
                        parentSpan: F
                    } = m;
                return (0, L.$e)(m.scope, () => {
                    let C = void 0 !== F ? m => withActiveSpan(F, m) : m => m();
                    return C(() => {
                        let C = (0, L.nZ)(),
                            F = getParentSpan(C),
                            H = m.onlyIfParent && !F,
                            X = H ? new et.b : createChildOrRootSpan({
                                parentSpan: F,
                                spanArguments: R,
                                forceTransaction: B,
                                scope: C
                            });
                        return (0, q.D)(C, X),
                            function(m, _, C = () => {}) {
                                var R;
                                let L;
                                try {
                                    L = m()
                                } catch (m) {
                                    throw _(m), C(), m
                                }
                                return R = L, (0, U.J8)(R) ? R.then(m => (C(), m), m => {
                                    throw _(m), C(), m
                                }) : (C(), R)
                            }(() => _(X), () => {
                                let {
                                    status: m
                                } = (0, V.XU)(X);
                                X.isRecording() && (!m || "ok" === m) && X.setStatus({
                                    code: eu.jt,
                                    message: "internal_error"
                                })
                            }, () => X.end())
                    })
                })
            }

            function startInactiveSpan(m) {
                let _ = getAcs();
                if (_.startInactiveSpan) return _.startInactiveSpan(m);
                let C = parseSentrySpanArguments(m),
                    {
                        forceTransaction: R,
                        parentSpan: B
                    } = m,
                    F = m.scope ? _ => (0, L.$e)(m.scope, _) : void 0 !== B ? m => withActiveSpan(B, m) : m => m();
                return F(() => {
                    let _ = (0, L.nZ)(),
                        B = getParentSpan(_),
                        F = m.onlyIfParent && !B;
                    return F ? new et.b : createChildOrRootSpan({
                        parentSpan: B,
                        spanArguments: C,
                        forceTransaction: R,
                        scope: _
                    })
                })
            }

            function withActiveSpan(m, _) {
                let C = getAcs();
                return C.withActiveSpan ? C.withActiveSpan(m, _) : (0, L.$e)(C => ((0, q.D)(C, m || void 0), _(C)))
            }

            function createChildOrRootSpan({
                parentSpan: m,
                spanArguments: _,
                forceTransaction: C,
                scope: R
            }) {
                var B;
                let F;
                if (!(0, H.z)()) return new et.b;
                let U = (0, L.aF)();
                if (m && !C) F = function(m, _, C) {
                    let {
                        spanId: R,
                        traceId: B
                    } = m.spanContext(), F = !_.getScopeData().sdkProcessingMetadata[ed] && (0, V.Tt)(m), U = F ? new SentrySpan({ ...C,
                        parentSpanId: R,
                        traceId: B,
                        sampled: F
                    }) : new et.b({
                        traceId: B
                    });
                    (0, V.j5)(m, U);
                    let H = (0, L.s3)();
                    return H && (H.emit("spanStart", U), C.endTimestamp && H.emit("spanEnd", U)), U
                }(m, R, _), (0, V.j5)(m, F);
                else if (m) {
                    let C = (0, X.jC)(m),
                        {
                            traceId: L,
                            spanId: B
                        } = m.spanContext(),
                        U = (0, V.Tt)(m);
                    F = _startRootSpan({
                        traceId: L,
                        parentSpanId: B,
                        ..._
                    }, R, U), (0, X.Lh)(F, C)
                } else {
                    let {
                        traceId: m,
                        dsc: C,
                        parentSpanId: L,
                        sampled: B
                    } = { ...U.getPropagationContext(),
                        ...R.getPropagationContext()
                    };
                    F = _startRootSpan({
                        traceId: m,
                        parentSpanId: L,
                        ..._
                    }, R, B), C && (0, X.Lh)(F, C)
                }
                return function(m) {
                    if (!Y.X) return;
                    let {
                        description: _ = "< unknown name >",
                        op: C = "< unknown op >",
                        parent_span_id: R
                    } = (0, V.XU)(m), {
                        spanId: L
                    } = m.spanContext(), B = (0, V.Tt)(m), F = (0, V.Gx)(m), U = F === m, H = `[Tracing] Starting ${B?"sampled":"unsampled"} ${U?"root ":""}span`, q = [`op: ${C}`, `name: ${_}`, `ID: ${L}`];
                    if (R && q.push(`parent ID: ${R}`), !U) {
                        let {
                            op: m,
                            description: _
                        } = (0, V.XU)(F);
                        q.push(`root ID: ${F.spanContext().spanId}`), m && q.push(`root op: ${m}`), _ && q.push(`root description: ${_}`)
                    }
                    K.kg.log(`${H}
  ${q.join("\n  ")}`)
                }(F), (B = F) && ((0, ei.xp)(B, el, U), (0, ei.xp)(B, ec, R)), F
            }

            function parseSentrySpanArguments(m) {
                let _ = m.experimental || {},
                    C = {
                        isStandalone: _.standalone,
                        ...m
                    };
                if (m.startTime) {
                    let _ = { ...C
                    };
                    return _.startTimestamp = (0, V.$k)(m.startTime), delete _.startTime, _
                }
                return C
            }

            function getAcs() {
                let m = (0, R.c)();
                return (0, B.G)(m)
            }

            function _startRootSpan(m, _, C) {
                let R = (0, L.s3)(),
                    B = R && R.getOptions() || {},
                    {
                        name: U = "",
                        attributes: q
                    } = m,
                    [V, X] = _.getScopeData().sdkProcessingMetadata[ed] ? [!1] : function(m, _) {
                        let C;
                        if (!(0, H.z)(m)) return [!1];
                        C = "function" == typeof m.tracesSampler ? m.tracesSampler(_) : void 0 !== _.parentSampled ? _.parentSampled : void 0 !== m.tracesSampleRate ? m.tracesSampleRate : 1;
                        let R = (0, Q.o)(C);
                        return void 0 === R ? (Y.X && K.kg.warn("[Tracing] Discarding transaction because of invalid sample rate."), [!1]) : R ? Math.random() < R ? [!0, R] : (Y.X && K.kg.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(C)})`), [!1, R]) : (Y.X && K.kg.log(`[Tracing] Discarding transaction because ${"function"==typeof m.tracesSampler?"tracesSampler returned 0 or false":"a negative sampling decision was inherited or tracesSampleRate is set to 0"}`), [!1, R])
                    }(B, {
                        name: U,
                        parentSampled: C,
                        attributes: q,
                        transactionContext: {
                            name: U,
                            parentSampled: C
                        }
                    }),
                    et = new SentrySpan({ ...m,
                        attributes: {
                            [F.Zj]: "custom",
                            ...m.attributes
                        },
                        sampled: V
                    });
                return void 0 !== X && et.setAttribute(F.TE, X), R && R.emit("spanStart", et), et
            }

            function getParentSpan(m) {
                let _ = (0, q.Y)(m);
                if (!_) return;
                let C = (0, L.s3)(),
                    R = C ? C.getOptions() : {};
                return R.parentSpanIsAlwaysRootSpan ? (0, V.Gx)(_) : _
            }
        },
        67973: function(m, _, C) {
            "use strict";
            C.d(_, {
                z: function() {
                    return hasTracingEnabled
                }
            });
            var R = C(73076);

            function hasTracingEnabled(m) {
                if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__) return !1;
                let _ = (0, R.s3)(),
                    C = m || _ && _.getOptions();
                return !!C && (C.enableTracing || "tracesSampleRate" in C || "tracesSampler" in C)
            }
        },
        79769: function(m, _, C) {
            "use strict";
            C.d(_, {
                o: function() {
                    return parseSampleRate
                }
            });
            var R = C(41001),
                L = C(94223);

            function parseSampleRate(m) {
                if ("boolean" == typeof m) return Number(m);
                let _ = "string" == typeof m ? parseFloat(m) : m;
                if ("number" != typeof _ || isNaN(_) || _ < 0 || _ > 1) {
                    L.X && R.kg.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(m)} of type ${JSON.stringify(typeof m)}.`);
                    return
                }
                return _
            }
        },
        5808: function(m, _, C) {
            "use strict";
            C.d(_, {
                U0: function() {
                    return parseEventHintOrCaptureContext
                },
                R: function() {
                    return prepareEvent
                }
            });
            var R = C(41982),
                L = C(26181),
                B = C(89163),
                F = C(29531),
                U = C(83408),
                H = C(73243),
                q = C(73076),
                V = C(80128),
                X = C(41001),
                K = C(16824),
                Y = C(94223),
                Q = C(43927),
                et = C(27179),
                er = C(72123),
                en = C(81585);

            function mergeScopeData(m, _) {
                let {
                    extra: C,
                    tags: R,
                    user: L,
                    contexts: B,
                    level: F,
                    sdkProcessingMetadata: U,
                    breadcrumbs: H,
                    fingerprint: q,
                    eventProcessors: V,
                    attachments: X,
                    propagationContext: K,
                    transactionName: Y,
                    span: Q
                } = _;
                mergeAndOverwriteScopeData(m, "extra", C), mergeAndOverwriteScopeData(m, "tags", R), mergeAndOverwriteScopeData(m, "user", L), mergeAndOverwriteScopeData(m, "contexts", B), mergeAndOverwriteScopeData(m, "sdkProcessingMetadata", U), F && (m.level = F), Y && (m.transactionName = Y), Q && (m.span = Q), H.length && (m.breadcrumbs = [...m.breadcrumbs, ...H]), q.length && (m.fingerprint = [...m.fingerprint, ...q]), V.length && (m.eventProcessors = [...m.eventProcessors, ...V]), X.length && (m.attachments = [...m.attachments, ...X]), m.propagationContext = { ...m.propagationContext,
                    ...K
                }
            }

            function mergeAndOverwriteScopeData(m, _, C) {
                if (C && Object.keys(C).length)
                    for (let R in m[_] = { ...m[_]
                        }, C) Object.prototype.hasOwnProperty.call(C, R) && (m[_][R] = C[R])
            }

            function prepareEvent(m, _, C, eo, ea, es) {
                let {
                    normalizeDepth: ec = 3,
                    normalizeMaxBreadth: el = 1e3
                } = m, eu = { ..._,
                    event_id: _.event_id || C.event_id || (0, R.DM)(),
                    timestamp: _.timestamp || (0, L.yW)()
                }, ed = C.integrations || m.integrations.map(m => m.name);
                (function(m, _) {
                    let {
                        environment: C,
                        release: R,
                        dist: L,
                        maxValueLength: F = 250
                    } = _;
                    "environment" in m || (m.environment = "environment" in _ ? C : H.J), void 0 === m.release && void 0 !== R && (m.release = R), void 0 === m.dist && void 0 !== L && (m.dist = L), m.message && (m.message = (0, B.$G)(m.message, F));
                    let U = m.exception && m.exception.values && m.exception.values[0];
                    U && U.value && (U.value = (0, B.$G)(U.value, F));
                    let q = m.request;
                    q && q.url && (q.url = (0, B.$G)(q.url, F))
                })(eu, m), ed.length > 0 && (eu.sdk = eu.sdk || {}, eu.sdk.integrations = [...eu.sdk.integrations || [], ...ed]), ea && ea.emit("applyFrameMetadata", _), void 0 === _.type && function(m, _) {
                    let C;
                    let R = F.GLOBAL_OBJ._sentryDebugIds;
                    if (!R) return;
                    let L = ei.get(_);
                    L ? C = L : (C = new Map, ei.set(_, C));
                    let B = Object.entries(R).reduce((m, [R, L]) => {
                        let B;
                        let F = C.get(R);
                        F ? B = F : (B = _(R), C.set(R, B));
                        for (let _ = B.length - 1; _ >= 0; _--) {
                            let C = B[_];
                            if (C.filename) {
                                m[C.filename] = L;
                                break
                            }
                        }
                        return m
                    }, {});
                    try {
                        m.exception.values.forEach(m => {
                            m.stacktrace.frames.forEach(m => {
                                m.filename && (m.debug_id = B[m.filename])
                            })
                        })
                    } catch (m) {}
                }(eu, m.stackParser);
                let ep = function(m, _) {
                    if (!_) return m;
                    let C = m ? m.clone() : new Q.s;
                    return C.update(_), C
                }(eo, C.captureContext);
                C.mechanism && (0, R.EG)(eu, C.mechanism);
                let eh = ea ? ea.getEventProcessors() : [],
                    ef = (0, q.lW)().getScopeData();
                if (es) {
                    let m = es.getScopeData();
                    mergeScopeData(ef, m)
                }
                if (ep) {
                    let m = ep.getScopeData();
                    mergeScopeData(ef, m)
                }
                let em = [...C.attachments || [], ...ef.attachments];
                em.length && (C.attachments = em),
                    function(m, _) {
                        let {
                            fingerprint: C,
                            span: L,
                            breadcrumbs: B,
                            sdkProcessingMetadata: F
                        } = _;
                        (function(m, _) {
                            let {
                                extra: C,
                                tags: R,
                                user: L,
                                contexts: B,
                                level: F,
                                transactionName: U
                            } = _, H = (0, et.Jr)(C);
                            H && Object.keys(H).length && (m.extra = { ...H,
                                ...m.extra
                            });
                            let q = (0, et.Jr)(R);
                            q && Object.keys(q).length && (m.tags = { ...q,
                                ...m.tags
                            });
                            let V = (0, et.Jr)(L);
                            V && Object.keys(V).length && (m.user = { ...V,
                                ...m.user
                            });
                            let X = (0, et.Jr)(B);
                            X && Object.keys(X).length && (m.contexts = { ...X,
                                ...m.contexts
                            }), F && (m.level = F), U && "transaction" !== m.type && (m.transaction = U)
                        })(m, _), L && function(m, _) {
                                m.contexts = {
                                    trace: (0, en.wy)(_),
                                    ...m.contexts
                                }, m.sdkProcessingMetadata = {
                                    dynamicSamplingContext: (0, er.jC)(_),
                                    ...m.sdkProcessingMetadata
                                };
                                let C = (0, en.Gx)(_),
                                    R = (0, en.XU)(C).description;
                                R && !m.transaction && "transaction" === m.type && (m.transaction = R)
                            }(m, L), m.fingerprint = m.fingerprint ? (0, R.lE)(m.fingerprint) : [], C && (m.fingerprint = m.fingerprint.concat(C)), m.fingerprint && !m.fingerprint.length && delete m.fingerprint,
                            function(m, _) {
                                let C = [...m.breadcrumbs || [], ..._];
                                m.breadcrumbs = C.length ? C : void 0
                            }(m, B), m.sdkProcessingMetadata = { ...m.sdkProcessingMetadata,
                                ...F
                            }
                    }(eu, ef);
                let eg = [...eh, ...ef.eventProcessors],
                    ey = function notifyEventProcessors(m, _, C, R = 0) {
                        return new V.cW((L, B) => {
                            let F = m[R];
                            if (null === _ || "function" != typeof F) L(_);
                            else {
                                let U = F({ ..._
                                }, C);
                                Y.X && F.id && null === U && X.kg.log(`Event processor "${F.id}" dropped event`), (0, K.J8)(U) ? U.then(_ => notifyEventProcessors(m, _, C, R + 1).then(L)).then(null, B) : notifyEventProcessors(m, U, C, R + 1).then(L).then(null, B)
                            }
                        })
                    }(eg, eu, C);
                return ey.then(m => (m && function(m) {
                    let _ = {};
                    try {
                        m.exception.values.forEach(m => {
                            m.stacktrace.frames.forEach(m => {
                                m.debug_id && (m.abs_path ? _[m.abs_path] = m.debug_id : m.filename && (_[m.filename] = m.debug_id), delete m.debug_id)
                            })
                        })
                    } catch (m) {}
                    if (0 === Object.keys(_).length) return;
                    m.debug_meta = m.debug_meta || {}, m.debug_meta.images = m.debug_meta.images || [];
                    let C = m.debug_meta.images;
                    Object.entries(_).forEach(([m, _]) => {
                        C.push({
                            type: "sourcemap",
                            code_file: m,
                            debug_id: _
                        })
                    })
                }(m), "number" == typeof ec && ec > 0) ? function(m, _, C) {
                    if (!m) return null;
                    let R = { ...m,
                        ...m.breadcrumbs && {
                            breadcrumbs: m.breadcrumbs.map(m => ({ ...m,
                                ...m.data && {
                                    data: (0, U.Fv)(m.data, _, C)
                                }
                            }))
                        },
                        ...m.user && {
                            user: (0, U.Fv)(m.user, _, C)
                        },
                        ...m.contexts && {
                            contexts: (0, U.Fv)(m.contexts, _, C)
                        },
                        ...m.extra && {
                            extra: (0, U.Fv)(m.extra, _, C)
                        }
                    };
                    return m.contexts && m.contexts.trace && R.contexts && (R.contexts.trace = m.contexts.trace, m.contexts.trace.data && (R.contexts.trace.data = (0, U.Fv)(m.contexts.trace.data, _, C))), m.spans && (R.spans = m.spans.map(m => ({ ...m,
                        ...m.data && {
                            data: (0, U.Fv)(m.data, _, C)
                        }
                    }))), R
                }(m, ec, el) : m)
            }
            let ei = new WeakMap;

            function parseEventHintOrCaptureContext(m) {
                return m ? m instanceof Q.s || "function" == typeof m || Object.keys(m).some(m => eo.includes(m)) ? {
                    captureContext: m
                } : m : void 0
            }
            let eo = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"]
        },
        89366: function(m, _, C) {
            "use strict";
            C.d(_, {
                D: function() {
                    return _setSpanForScope
                },
                Y: function() {
                    return _getSpanForScope
                }
            });
            var R = C(27179);
            let L = "_sentrySpan";

            function _setSpanForScope(m, _) {
                _ ? (0, R.xp)(m, L, _) : delete m[L]
            }

            function _getSpanForScope(m) {
                return m[L]
            }
        },
        81585: function(m, _, C) {
            "use strict";
            C.d(_, {
                $k: function() {
                    return spanTimeInputToSeconds
                },
                Dp: function() {
                    return getSpanDescendants
                },
                Gx: function() {
                    return getRootSpan
                },
                HN: function() {
                    return getActiveSpan
                },
                HR: function() {
                    return spanToTransactionTraceContext
                },
                Hb: function() {
                    return spanToTraceHeader
                },
                Tt: function() {
                    return spanIsSampled
                },
                XU: function() {
                    return spanToJSON
                },
                _4: function() {
                    return getStatusMessage
                },
                ed: function() {
                    return removeChildSpanFromSpan
                },
                i0: function() {
                    return Q
                },
                j5: function() {
                    return addChildSpanToSpan
                },
                ve: function() {
                    return Y
                },
                wy: function() {
                    return spanToTraceContext
                }
            });
            var R = C(27179),
                L = C(85712),
                B = C(26181),
                F = C(60811),
                U = C(13533),
                H = C(73076),
                q = C(72751),
                V = C(31218),
                X = C(69737),
                K = C(89366);
            let Y = 0,
                Q = 1;

            function spanToTransactionTraceContext(m) {
                let {
                    spanId: _,
                    traceId: C
                } = m.spanContext(), {
                    data: L,
                    op: B,
                    parent_span_id: F,
                    status: U,
                    origin: H
                } = spanToJSON(m);
                return (0, R.Jr)({
                    parent_span_id: F,
                    span_id: _,
                    trace_id: C,
                    data: L,
                    op: B,
                    status: U,
                    origin: H
                })
            }

            function spanToTraceContext(m) {
                let {
                    spanId: _,
                    traceId: C
                } = m.spanContext(), {
                    parent_span_id: L
                } = spanToJSON(m);
                return (0, R.Jr)({
                    parent_span_id: L,
                    span_id: _,
                    trace_id: C
                })
            }

            function spanToTraceHeader(m) {
                let {
                    traceId: _,
                    spanId: C
                } = m.spanContext(), R = spanIsSampled(m);
                return (0, L.$p)(_, C, R)
            }

            function spanTimeInputToSeconds(m) {
                return "number" == typeof m ? ensureTimestampInSeconds(m) : Array.isArray(m) ? m[0] + m[1] / 1e9 : m instanceof Date ? ensureTimestampInSeconds(m.getTime()) : (0, B.ph)()
            }

            function ensureTimestampInSeconds(m) {
                return m > 9999999999 ? m / 1e3 : m
            }

            function spanToJSON(m) {
                if ("function" == typeof m.getSpanJSON) return m.getSpanJSON();
                try {
                    let {
                        spanId: _,
                        traceId: C
                    } = m.spanContext();
                    if (m.attributes && m.startTime && m.name && m.endTime && m.status) {
                        let {
                            attributes: L,
                            startTime: B,
                            name: F,
                            endTime: U,
                            parentSpanId: H,
                            status: X
                        } = m;
                        return (0, R.Jr)({
                            span_id: _,
                            trace_id: C,
                            data: L,
                            description: F,
                            parent_span_id: H,
                            start_timestamp: spanTimeInputToSeconds(B),
                            timestamp: spanTimeInputToSeconds(U) || void 0,
                            status: getStatusMessage(X),
                            op: L[V.$J],
                            origin: L[V.S3],
                            _metrics_summary: (0, q.y)(m)
                        })
                    }
                    return {
                        span_id: _,
                        trace_id: C
                    }
                } catch (m) {
                    return {}
                }
            }

            function spanIsSampled(m) {
                let {
                    traceFlags: _
                } = m.spanContext();
                return _ === Q
            }

            function getStatusMessage(m) {
                return m && m.code !== X.pq ? m.code === X.OP ? "ok" : m.message || "unknown_error" : void 0
            }
            let et = "_sentryChildSpans",
                er = "_sentryRootSpan";

            function addChildSpanToSpan(m, _) {
                let C = m[er] || m;
                (0, R.xp)(_, er, C), m[et] ? m[et].add(_) : (0, R.xp)(m, et, new Set([_]))
            }

            function removeChildSpanFromSpan(m, _) {
                m[et] && m[et].delete(_)
            }

            function getSpanDescendants(m) {
                let _ = new Set;
                return function addSpanChildren(m) {
                    if (!_.has(m) && spanIsSampled(m)) {
                        _.add(m);
                        let C = m[et] ? Array.from(m[et]) : [];
                        for (let m of C) addSpanChildren(m)
                    }
                }(m), Array.from(_)
            }

            function getRootSpan(m) {
                return m[er] || m
            }

            function getActiveSpan() {
                let m = (0, U.c)(),
                    _ = (0, F.G)(m);
                return _.getActiveSpan ? _.getActiveSpan() : (0, K.Y)((0, H.nZ)())
            }
        },
        36096: function(m, _, C) {
            "use strict";
            C.d(_, {
                X: function() {
                    return R
                }
            });
            let R = !1
        },
        60859: function(m, _, C) {
            "use strict";
            C.d(_, {
                EN: function() {
                    return baggageHeaderToDynamicSamplingContext
                },
                IQ: function() {
                    return dynamicSamplingContextToSentryBaggageHeader
                },
                bU: function() {
                    return F
                }
            });
            var R = C(1525),
                L = C(16824),
                B = C(41001);
            let F = "baggage",
                U = "sentry-",
                H = /^sentry-/;

            function baggageHeaderToDynamicSamplingContext(m) {
                let _ = m && ((0, L.HD)(m) || Array.isArray(m)) ? Array.isArray(m) ? m.reduce((m, _) => {
                    let C = baggageHeaderToObject(_);
                    return Object.entries(C).forEach(([_, C]) => {
                        m[_] = C
                    }), m
                }, {}) : baggageHeaderToObject(m) : void 0;
                if (!_) return;
                let C = Object.entries(_).reduce((m, [_, C]) => {
                    if (_.match(H)) {
                        let R = _.slice(U.length);
                        m[R] = C
                    }
                    return m
                }, {});
                return Object.keys(C).length > 0 ? C : void 0
            }

            function dynamicSamplingContextToSentryBaggageHeader(m) {
                if (!m) return;
                let _ = Object.entries(m).reduce((m, [_, C]) => (C && (m[`${U}${_}`] = C), m), {});
                return function(m) {
                    if (0 !== Object.keys(m).length) return Object.entries(m).reduce((m, [_, C], L) => {
                        let F = `${encodeURIComponent(_)}=${encodeURIComponent(C)}`,
                            U = 0 === L ? F : `${m},${F}`;
                        return U.length > 8192 ? (R.X && B.kg.warn(`Not adding key: ${_} with val: ${C} to baggage header due to exceeding baggage size limits.`), m) : U
                    }, "")
                }(_)
            }

            function baggageHeaderToObject(m) {
                return m.split(",").map(m => m.split("=").map(m => decodeURIComponent(m.trim()))).reduce((m, [_, C]) => (_ && C && (m[_] = C), m), {})
            }
        },
        1869: function(m, _, C) {
            "use strict";
            C.d(_, {
                Rt: function() {
                    return htmlTreeAsString
                },
                iY: function() {
                    return getComponentName
                },
                l4: function() {
                    return getLocationHref
                },
                qT: function() {
                    return getDomElement
                }
            });
            var R = C(16824),
                L = C(29531);
            let B = L.GLOBAL_OBJ;

            function htmlTreeAsString(m, _ = {}) {
                if (!m) return "<unknown>";
                try {
                    let C, L = m,
                        F = [],
                        U = 0,
                        H = 0,
                        q = Array.isArray(_) ? _ : _.keyAttrs,
                        V = !Array.isArray(_) && _.maxStringLength || 80;
                    for (; L && U++ < 5 && (C = function(m, _) {
                            let C = [];
                            if (!m || !m.tagName) return "";
                            if (B.HTMLElement && m instanceof HTMLElement && m.dataset) {
                                if (m.dataset.sentryComponent) return m.dataset.sentryComponent;
                                if (m.dataset.sentryElement) return m.dataset.sentryElement
                            }
                            C.push(m.tagName.toLowerCase());
                            let L = _ && _.length ? _.filter(_ => m.getAttribute(_)).map(_ => [_, m.getAttribute(_)]) : null;
                            if (L && L.length) L.forEach(m => {
                                C.push(`[${m[0]}="${m[1]}"]`)
                            });
                            else {
                                m.id && C.push(`#${m.id}`);
                                let _ = m.className;
                                if (_ && (0, R.HD)(_)) {
                                    let m = _.split(/\s+/);
                                    for (let _ of m) C.push(`.${_}`)
                                }
                            }
                            for (let _ of ["aria-label", "type", "name", "title", "alt"]) {
                                let R = m.getAttribute(_);
                                R && C.push(`[${_}="${R}"]`)
                            }
                            return C.join("")
                        }(L, q), "html" !== C && (!(U > 1) || !(H + 3 * F.length + C.length >= V)));) F.push(C), H += C.length, L = L.parentNode;
                    return F.reverse().join(" > ")
                } catch (m) {
                    return "<unknown>"
                }
            }

            function getLocationHref() {
                try {
                    return B.document.location.href
                } catch (m) {
                    return ""
                }
            }

            function getDomElement(m) {
                return B.document && B.document.querySelector ? B.document.querySelector(m) : null
            }

            function getComponentName(m) {
                if (!B.HTMLElement) return null;
                let _ = m;
                for (let m = 0; m < 5 && _; m++) {
                    if (_ instanceof HTMLElement) {
                        if (_.dataset.sentryComponent) return _.dataset.sentryComponent;
                        if (_.dataset.sentryElement) return _.dataset.sentryElement
                    }
                    _ = _.parentNode
                }
                return null
            }
        },
        1525: function(m, _, C) {
            "use strict";
            C.d(_, {
                X: function() {
                    return R
                }
            });
            let R = !1
        },
        73326: function(m, _, C) {
            "use strict";
            C.d(_, {
                RA: function() {
                    return dsnToString
                },
                U4: function() {
                    return dsnFromString
                },
                vK: function() {
                    return makeDsn
                }
            });
            var R = C(1525),
                L = C(41001);
            let B = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;

            function dsnToString(m, _ = !1) {
                let {
                    host: C,
                    path: R,
                    pass: L,
                    port: B,
                    projectId: F,
                    protocol: U,
                    publicKey: H
                } = m;
                return `${U}://${H}${_&&L?`:${L}`:""}@${C}${B?`:${B}`:""}/${R?`${R}/`:R}${F}`
            }

            function dsnFromString(m) {
                let _ = B.exec(m);
                if (!_) {
                    (0, L.Cf)(() => {
                        console.error(`Invalid Sentry Dsn: ${m}`)
                    });
                    return
                }
                let [C, R, F = "", U = "", H = "", q = ""] = _.slice(1), V = "", X = q, K = X.split("/");
                if (K.length > 1 && (V = K.slice(0, -1).join("/"), X = K.pop()), X) {
                    let m = X.match(/^\d+/);
                    m && (X = m[0])
                }
                return dsnFromComponents({
                    host: U,
                    pass: F,
                    path: V,
                    projectId: X,
                    port: H,
                    protocol: C,
                    publicKey: R
                })
            }

            function dsnFromComponents(m) {
                return {
                    protocol: m.protocol,
                    publicKey: m.publicKey || "",
                    pass: m.pass || "",
                    host: m.host,
                    port: m.port || "",
                    path: m.path || "",
                    projectId: m.projectId
                }
            }

            function makeDsn(m) {
                let _ = "string" == typeof m ? dsnFromString(m) : dsnFromComponents(m);
                if (_ && function(m) {
                        if (!R.X) return !0;
                        let {
                            port: _,
                            projectId: C,
                            protocol: B
                        } = m, F = ["protocol", "publicKey", "host", "projectId"].find(_ => !m[_] && (L.kg.error(`Invalid Sentry Dsn: ${_} missing`), !0));
                        return !F && (C.match(/^\d+$/) ? "http" === B || "https" === B ? !(_ && isNaN(parseInt(_, 10))) || (L.kg.error(`Invalid Sentry Dsn: Invalid port ${_}`), !1) : (L.kg.error(`Invalid Sentry Dsn: Invalid protocol ${B}`), !1) : (L.kg.error(`Invalid Sentry Dsn: Invalid projectId ${C}`), !1))
                    }(_)) return _
            }
        },
        39432: function(m, _, C) {
            "use strict";
            C.d(_, {
                BO: function() {
                    return addItemToEnvelope
                },
                Cd: function() {
                    return createEventEnvelopeHeaders
                },
                HY: function() {
                    return getSdkMetadataForEnvelopeHeader
                },
                Jd: function() {
                    return createEnvelope
                },
                KQ: function() {
                    return createSpanEnvelopeItem
                },
                V$: function() {
                    return serializeEnvelope
                },
                gv: function() {
                    return forEachEnvelopeItem
                },
                mL: function() {
                    return envelopeItemTypeToDataCategory
                },
                zQ: function() {
                    return createAttachmentEnvelopeItem
                }
            });
            var R = C(73326),
                L = C(83408),
                B = C(27179),
                F = C(29531);

            function createEnvelope(m, _ = []) {
                return [m, _]
            }

            function addItemToEnvelope(m, _) {
                let [C, R] = m;
                return [C, [...R, _]]
            }

            function forEachEnvelopeItem(m, _) {
                let C = m[1];
                for (let m of C) {
                    let C = m[0].type,
                        R = _(m, C);
                    if (R) return !0
                }
                return !1
            }

            function encodeUTF8(m) {
                return F.GLOBAL_OBJ.__SENTRY__ && F.GLOBAL_OBJ.__SENTRY__.encodePolyfill ? F.GLOBAL_OBJ.__SENTRY__.encodePolyfill(m) : new TextEncoder().encode(m)
            }

            function serializeEnvelope(m) {
                let [_, C] = m, R = JSON.stringify(_);

                function append(m) {
                    "string" == typeof R ? R = "string" == typeof m ? R + m : [encodeUTF8(R), m] : R.push("string" == typeof m ? encodeUTF8(m) : m)
                }
                for (let m of C) {
                    let [_, C] = m;
                    if (append(`
${JSON.stringify(_)}
`), "string" == typeof C || C instanceof Uint8Array) append(C);
                    else {
                        let m;
                        try {
                            m = JSON.stringify(C)
                        } catch (_) {
                            m = JSON.stringify((0, L.Fv)(C))
                        }
                        append(m)
                    }
                }
                return "string" == typeof R ? R : function(m) {
                    let _ = m.reduce((m, _) => m + _.length, 0),
                        C = new Uint8Array(_),
                        R = 0;
                    for (let _ of m) C.set(_, R), R += _.length;
                    return C
                }(R)
            }

            function createSpanEnvelopeItem(m) {
                return [{
                    type: "span"
                }, m]
            }

            function createAttachmentEnvelopeItem(m) {
                let _ = "string" == typeof m.data ? encodeUTF8(m.data) : m.data;
                return [(0, B.Jr)({
                    type: "attachment",
                    length: _.length,
                    filename: m.filename,
                    content_type: m.contentType,
                    attachment_type: m.attachmentType
                }), _]
            }
            let U = {
                session: "session",
                sessions: "session",
                attachment: "attachment",
                transaction: "transaction",
                event: "error",
                client_report: "internal",
                user_report: "default",
                profile: "profile",
                profile_chunk: "profile",
                replay_event: "replay",
                replay_recording: "replay",
                check_in: "monitor",
                feedback: "feedback",
                span: "span",
                statsd: "metric_bucket"
            };

            function envelopeItemTypeToDataCategory(m) {
                return U[m]
            }

            function getSdkMetadataForEnvelopeHeader(m) {
                if (!m || !m.sdk) return;
                let {
                    name: _,
                    version: C
                } = m.sdk;
                return {
                    name: _,
                    version: C
                }
            }

            function createEventEnvelopeHeaders(m, _, C, L) {
                let F = m.sdkProcessingMetadata && m.sdkProcessingMetadata.dynamicSamplingContext;
                return {
                    event_id: m.event_id,
                    sent_at: new Date().toISOString(),
                    ..._ && {
                        sdk: _
                    },
                    ...!!C && L && {
                        dsn: (0, R.RA)(L)
                    },
                    ...F && {
                        trace: (0, B.Jr)({ ...F
                        })
                    }
                }
            }
        },
        16824: function(m, _, C) {
            "use strict";
            C.d(_, {
                Cy: function() {
                    return isSyntheticEvent
                },
                HD: function() {
                    return isString
                },
                J8: function() {
                    return isThenable
                },
                Kj: function() {
                    return isRegExp
                },
                Le: function() {
                    return isParameterizedString
                },
                PO: function() {
                    return isPlainObject
                },
                TX: function() {
                    return isDOMError
                },
                V9: function() {
                    return isInstanceOf
                },
                VW: function() {
                    return isErrorEvent
                },
                VZ: function() {
                    return isError
                },
                cO: function() {
                    return isEvent
                },
                fm: function() {
                    return isDOMException
                },
                kK: function() {
                    return isElement
                },
                pt: function() {
                    return isPrimitive
                },
                y1: function() {
                    return isVueViewModel
                }
            });
            let R = Object.prototype.toString;

            function isError(m) {
                switch (R.call(m)) {
                    case "[object Error]":
                    case "[object Exception]":
                    case "[object DOMException]":
                    case "[object WebAssembly.Exception]":
                        return !0;
                    default:
                        return isInstanceOf(m, Error)
                }
            }

            function isBuiltin(m, _) {
                return R.call(m) === `[object ${_}]`
            }

            function isErrorEvent(m) {
                return isBuiltin(m, "ErrorEvent")
            }

            function isDOMError(m) {
                return isBuiltin(m, "DOMError")
            }

            function isDOMException(m) {
                return isBuiltin(m, "DOMException")
            }

            function isString(m) {
                return isBuiltin(m, "String")
            }

            function isParameterizedString(m) {
                return "object" == typeof m && null !== m && "__sentry_template_string__" in m && "__sentry_template_values__" in m
            }

            function isPrimitive(m) {
                return null === m || isParameterizedString(m) || "object" != typeof m && "function" != typeof m
            }

            function isPlainObject(m) {
                return isBuiltin(m, "Object")
            }

            function isEvent(m) {
                return "undefined" != typeof Event && isInstanceOf(m, Event)
            }

            function isElement(m) {
                return "undefined" != typeof Element && isInstanceOf(m, Element)
            }

            function isRegExp(m) {
                return isBuiltin(m, "RegExp")
            }

            function isThenable(m) {
                return !!(m && m.then && "function" == typeof m.then)
            }

            function isSyntheticEvent(m) {
                return isPlainObject(m) && "nativeEvent" in m && "preventDefault" in m && "stopPropagation" in m
            }

            function isInstanceOf(m, _) {
                try {
                    return m instanceof _
                } catch (m) {
                    return !1
                }
            }

            function isVueViewModel(m) {
                return !!("object" == typeof m && null !== m && (m.__isVue || m._isVue))
            }
        },
        41001: function(m, _, C) {
            "use strict";
            C.d(_, {
                Cf: function() {
                    return consoleSandbox
                },
                LD: function() {
                    return F
                },
                RU: function() {
                    return B
                },
                kg: function() {
                    return U
                }
            });
            var R = C(1525),
                L = C(29531);
            let B = ["debug", "info", "warn", "error", "log", "assert", "trace"],
                F = {};

            function consoleSandbox(m) {
                if (!("console" in L.GLOBAL_OBJ)) return m();
                let _ = L.GLOBAL_OBJ.console,
                    C = {},
                    R = Object.keys(F);
                R.forEach(m => {
                    let R = F[m];
                    C[m] = _[m], _[m] = R
                });
                try {
                    return m()
                } finally {
                    R.forEach(m => {
                        _[m] = C[m]
                    })
                }
            }
            let U = (0, L.Y)("logger", function() {
                let m = !1,
                    _ = {
                        enable: () => {
                            m = !0
                        },
                        disable: () => {
                            m = !1
                        },
                        isEnabled: () => m
                    };
                return R.X ? B.forEach(C => {
                    _[C] = (..._) => {
                        m && consoleSandbox(() => {
                            L.GLOBAL_OBJ.console[C](`Sentry Logger [${C}]:`, ..._)
                        })
                    }
                }) : B.forEach(m => {
                    _[m] = () => void 0
                }), _
            })
        },
        41982: function(m, _, C) {
            "use strict";
            C.d(_, {
                DM: function() {
                    return uuid4
                },
                Db: function() {
                    return addExceptionTypeValue
                },
                EG: function() {
                    return addExceptionMechanism
                },
                YO: function() {
                    return checkOrSetAlreadyCaught
                },
                jH: function() {
                    return getEventDescription
                },
                lE: function() {
                    return arrayify
                }
            });
            var R = C(27179),
                L = C(29531);

            function uuid4() {
                let m = L.GLOBAL_OBJ,
                    _ = m.crypto || m.msCrypto,
                    getRandomByte = () => 16 * Math.random();
                try {
                    if (_ && _.randomUUID) return _.randomUUID().replace(/-/g, "");
                    _ && _.getRandomValues && (getRandomByte = () => {
                        let m = new Uint8Array(1);
                        return _.getRandomValues(m), m[0]
                    })
                } catch (m) {}
                return "10000000100040008000100000000000".replace(/[018]/g, m => (m ^ (15 & getRandomByte()) >> m / 4).toString(16))
            }

            function getFirstException(m) {
                return m.exception && m.exception.values ? m.exception.values[0] : void 0
            }

            function getEventDescription(m) {
                let {
                    message: _,
                    event_id: C
                } = m;
                if (_) return _;
                let R = getFirstException(m);
                return R ? R.type && R.value ? `${R.type}: ${R.value}` : R.type || R.value || C || "<unknown>" : C || "<unknown>"
            }

            function addExceptionTypeValue(m, _, C) {
                let R = m.exception = m.exception || {},
                    L = R.values = R.values || [],
                    B = L[0] = L[0] || {};
                B.value || (B.value = _ || ""), B.type || (B.type = C || "Error")
            }

            function addExceptionMechanism(m, _) {
                let C = getFirstException(m);
                if (!C) return;
                let R = C.mechanism;
                if (C.mechanism = {
                        type: "generic",
                        handled: !0,
                        ...R,
                        ..._
                    }, _ && "data" in _) {
                    let m = { ...R && R.data,
                        ..._.data
                    };
                    C.mechanism.data = m
                }
            }

            function checkOrSetAlreadyCaught(m) {
                if (m && m.__sentry_captured__) return !0;
                try {
                    (0, R.xp)(m, "__sentry_captured__", !0)
                } catch (m) {}
                return !1
            }

            function arrayify(m) {
                return Array.isArray(m) ? m : [m]
            }
        },
        83408: function(m, _, C) {
            "use strict";
            C.d(_, {
                Fv: function() {
                    return normalize
                },
                Qy: function() {
                    return function normalizeToSize(m, _ = 3, C = 102400) {
                        let R = normalize(m, _);
                        return ~-encodeURI(JSON.stringify(R)).split(/%..|./).length > C ? normalizeToSize(m, _ - 1, C) : R
                    }
                }
            });
            var R = C(16824),
                L = C(27179),
                B = C(42283);

            function normalize(m, _ = 100, C = Infinity) {
                try {
                    return function visit(m, _, C = Infinity, F = Infinity, U = function() {
                        let m = "function" == typeof WeakSet,
                            _ = m ? new WeakSet : [];
                        return [function(C) {
                            if (m) return !!_.has(C) || (_.add(C), !1);
                            for (let m = 0; m < _.length; m++) {
                                let R = _[m];
                                if (R === C) return !0
                            }
                            return _.push(C), !1
                        }, function(C) {
                            if (m) _.delete(C);
                            else
                                for (let m = 0; m < _.length; m++)
                                    if (_[m] === C) {
                                        _.splice(m, 1);
                                        break
                                    }
                        }]
                    }()) {
                        let [H, q] = U;
                        if (null == _ || ["boolean", "string"].includes(typeof _) || "number" == typeof _ && Number.isFinite(_)) return _;
                        let V = function(m, _) {
                            try {
                                if ("domain" === m && _ && "object" == typeof _ && _._events) return "[Domain]";
                                if ("domainEmitter" === m) return "[DomainEmitter]";
                                if ("undefined" != typeof global && _ === global) return "[Global]";
                                if ("undefined" != typeof window && _ === window) return "[Window]";
                                if ("undefined" != typeof document && _ === document) return "[Document]";
                                if ((0, R.y1)(_)) return "[VueViewModel]";
                                if ((0, R.Cy)(_)) return "[SyntheticEvent]";
                                if ("number" == typeof _ && !Number.isFinite(_)) return `[${_}]`;
                                if ("function" == typeof _) return `[Function: ${(0,B.$P)(_)}]`;
                                if ("symbol" == typeof _) return `[${String(_)}]`;
                                if ("bigint" == typeof _) return `[BigInt: ${String(_)}]`;
                                let C = function(m) {
                                    let _ = Object.getPrototypeOf(m);
                                    return _ ? _.constructor.name : "null prototype"
                                }(_);
                                if (/^HTML(\w*)Element$/.test(C)) return `[HTMLElement: ${C}]`;
                                return `[object ${C}]`
                            } catch (m) {
                                return `**non-serializable** (${m})`
                            }
                        }(m, _);
                        if (!V.startsWith("[object ")) return V;
                        if (_.__sentry_skip_normalization__) return _;
                        let X = "number" == typeof _.__sentry_override_normalization_depth__ ? _.__sentry_override_normalization_depth__ : C;
                        if (0 === X) return V.replace("object ", "");
                        if (H(_)) return "[Circular ~]";
                        if (_ && "function" == typeof _.toJSON) try {
                            let m = _.toJSON();
                            return visit("", m, X - 1, F, U)
                        } catch (m) {}
                        let K = Array.isArray(_) ? [] : {},
                            Y = 0,
                            Q = (0, L.Sh)(_);
                        for (let m in Q) {
                            if (!Object.prototype.hasOwnProperty.call(Q, m)) continue;
                            if (Y >= F) {
                                K[m] = "[MaxProperties ~]";
                                break
                            }
                            let _ = Q[m];
                            K[m] = visit(m, _, X - 1, F, U), Y++
                        }
                        return q(_), K
                    }("", m, _, C)
                } catch (m) {
                    return {
                        ERROR: `**non-serializable** (${m})`
                    }
                }
            }
        },
        27179: function(m, _, C) {
            "use strict";
            C.d(_, {
                $Q: function() {
                    return markFunctionWrapped
                },
                HK: function() {
                    return getOriginalFunction
                },
                Jr: function() {
                    return dropUndefinedKeys
                },
                Sh: function() {
                    return convertToPlainObject
                },
                _j: function() {
                    return urlEncode
                },
                hl: function() {
                    return fill
                },
                xp: function() {
                    return addNonEnumerableProperty
                },
                zf: function() {
                    return extractExceptionKeysForMessage
                }
            });
            var R = C(1869),
                L = C(1525),
                B = C(16824),
                F = C(41001),
                U = C(89163);

            function fill(m, _, C) {
                if (!(_ in m)) return;
                let R = m[_],
                    L = C(R);
                "function" == typeof L && markFunctionWrapped(L, R), m[_] = L
            }

            function addNonEnumerableProperty(m, _, C) {
                try {
                    Object.defineProperty(m, _, {
                        value: C,
                        writable: !0,
                        configurable: !0
                    })
                } catch (C) {
                    L.X && F.kg.log(`Failed to add non-enumerable property "${_}" to object`, m)
                }
            }

            function markFunctionWrapped(m, _) {
                try {
                    let C = _.prototype || {};
                    m.prototype = _.prototype = C, addNonEnumerableProperty(m, "__sentry_original__", _)
                } catch (m) {}
            }

            function getOriginalFunction(m) {
                return m.__sentry_original__
            }

            function urlEncode(m) {
                return Object.keys(m).map(_ => `${encodeURIComponent(_)}=${encodeURIComponent(m[_])}`).join("&")
            }

            function convertToPlainObject(m) {
                if ((0, B.VZ)(m)) return {
                    message: m.message,
                    name: m.name,
                    stack: m.stack,
                    ...getOwnProperties(m)
                };
                if (!(0, B.cO)(m)) return m; {
                    let _ = {
                        type: m.type,
                        target: serializeEventTarget(m.target),
                        currentTarget: serializeEventTarget(m.currentTarget),
                        ...getOwnProperties(m)
                    };
                    return "undefined" != typeof CustomEvent && (0, B.V9)(m, CustomEvent) && (_.detail = m.detail), _
                }
            }

            function serializeEventTarget(m) {
                try {
                    return (0, B.kK)(m) ? (0, R.Rt)(m) : Object.prototype.toString.call(m)
                } catch (m) {
                    return "<unknown>"
                }
            }

            function getOwnProperties(m) {
                if ("object" != typeof m || null === m) return {}; {
                    let _ = {};
                    for (let C in m) Object.prototype.hasOwnProperty.call(m, C) && (_[C] = m[C]);
                    return _
                }
            }

            function extractExceptionKeysForMessage(m, _ = 40) {
                let C = Object.keys(convertToPlainObject(m));
                C.sort();
                let R = C[0];
                if (!R) return "[object has no keys]";
                if (R.length >= _) return (0, U.$G)(R, _);
                for (let m = C.length; m > 0; m--) {
                    let R = C.slice(0, m).join(", ");
                    if (!(R.length > _)) {
                        if (m === C.length) return R;
                        return (0, U.$G)(R, _)
                    }
                }
                return ""
            }

            function dropUndefinedKeys(m) {
                let _ = new Map;
                return function _dropUndefinedKeys(m, _) {
                    if (function(m) {
                            if (!(0, B.PO)(m)) return !1;
                            try {
                                let _ = Object.getPrototypeOf(m).constructor.name;
                                return !_ || "Object" === _
                            } catch (m) {
                                return !0
                            }
                        }(m)) {
                        let C = _.get(m);
                        if (void 0 !== C) return C;
                        let R = {};
                        for (let C of (_.set(m, R), Object.getOwnPropertyNames(m))) void 0 !== m[C] && (R[C] = _dropUndefinedKeys(m[C], _));
                        return R
                    }
                    if (Array.isArray(m)) {
                        let C = _.get(m);
                        if (void 0 !== C) return C;
                        let R = [];
                        return _.set(m, R), m.forEach(m => {
                            R.push(_dropUndefinedKeys(m, _))
                        }), R
                    }
                    return m
                }(m, _)
            }
        },
        19548: function(m, _, C) {
            "use strict";
            C.d(_, {
                Q: function() {
                    return generatePropagationContext
                }
            });
            var R = C(41982);

            function generatePropagationContext() {
                return {
                    traceId: (0, R.DM)(),
                    spanId: (0, R.DM)().substring(16)
                }
            }
        },
        42283: function(m, _, C) {
            "use strict";
            C.d(_, {
                $P: function() {
                    return getFunctionName
                },
                Fi: function() {
                    return R
                },
                Fr: function() {
                    return getFramesFromEvent
                },
                Sq: function() {
                    return stackParserFromStackParserOptions
                },
                pE: function() {
                    return createStackParser
                }
            });
            let R = "?",
                L = /\(error: (.*)\)/,
                B = /captureMessage|captureException/;

            function createStackParser(...m) {
                let _ = m.sort((m, _) => m[0] - _[0]).map(m => m[1]);
                return (m, C = 0, F = 0) => {
                    let U = [],
                        H = m.split("\n");
                    for (let m = C; m < H.length; m++) {
                        let C = H[m];
                        if (C.length > 1024) continue;
                        let R = L.test(C) ? C.replace(L, "$1") : C;
                        if (!R.match(/\S*Error: /)) {
                            for (let m of _) {
                                let _ = m(R);
                                if (_) {
                                    U.push(_);
                                    break
                                }
                            }
                            if (U.length >= 50 + F) break
                        }
                    }
                    return function(m) {
                        if (!m.length) return [];
                        let _ = Array.from(m);
                        return /sentryWrapped/.test(getLastStackFrame(_).function || "") && _.pop(), _.reverse(), B.test(getLastStackFrame(_).function || "") && (_.pop(), B.test(getLastStackFrame(_).function || "") && _.pop()), _.slice(0, 50).map(m => ({ ...m,
                            filename: m.filename || getLastStackFrame(_).filename,
                            function: m.function || R
                        }))
                    }(U.slice(F))
                }
            }

            function stackParserFromStackParserOptions(m) {
                return Array.isArray(m) ? createStackParser(...m) : m
            }

            function getLastStackFrame(m) {
                return m[m.length - 1] || {}
            }
            let F = "<anonymous>";

            function getFunctionName(m) {
                try {
                    if (!m || "function" != typeof m) return F;
                    return m.name || F
                } catch (m) {
                    return F
                }
            }

            function getFramesFromEvent(m) {
                let _ = m.exception;
                if (_) {
                    let m = [];
                    try {
                        return _.values.forEach(_ => {
                            _.stacktrace.frames && m.push(..._.stacktrace.frames)
                        }), m
                    } catch (m) {}
                }
            }
        },
        89163: function(m, _, C) {
            "use strict";
            C.d(_, {
                $G: function() {
                    return truncate
                },
                U0: function() {
                    return stringMatchesSomePattern
                },
                nK: function() {
                    return safeJoin
                }
            });
            var R = C(16824);

            function truncate(m, _ = 0) {
                return "string" != typeof m || 0 === _ ? m : m.length <= _ ? m : `${m.slice(0,_)}...`
            }

            function safeJoin(m, _) {
                if (!Array.isArray(m)) return "";
                let C = [];
                for (let _ = 0; _ < m.length; _++) {
                    let L = m[_];
                    try {
                        (0, R.y1)(L) ? C.push("[VueViewModel]"): C.push(String(L))
                    } catch (m) {
                        C.push("[value cannot be serialized]")
                    }
                }
                return C.join(_)
            }

            function stringMatchesSomePattern(m, _ = [], C = !1) {
                return _.some(_ => (function(m, _, C = !1) {
                    return !!(0, R.HD)(m) && ((0, R.Kj)(_) ? _.test(m) : !!(0, R.HD)(_) && (C ? m === _ : m.includes(_)))
                })(m, _, C))
            }
        },
        80128: function(m, _, C) {
            "use strict";
            C.d(_, {
                $2: function() {
                    return rejectedSyncPromise
                },
                WD: function() {
                    return resolvedSyncPromise
                },
                cW: function() {
                    return SyncPromise
                }
            });
            var R, L, B = C(16824);

            function resolvedSyncPromise(m) {
                return new SyncPromise(_ => {
                    _(m)
                })
            }

            function rejectedSyncPromise(m) {
                return new SyncPromise((_, C) => {
                    C(m)
                })
            }(R = L || (L = {}))[R.PENDING = 0] = "PENDING", R[R.RESOLVED = 1] = "RESOLVED", R[R.REJECTED = 2] = "REJECTED";
            let SyncPromise = class SyncPromise {
                constructor(m) {
                    SyncPromise.prototype.__init.call(this), SyncPromise.prototype.__init2.call(this), SyncPromise.prototype.__init3.call(this), SyncPromise.prototype.__init4.call(this), this._state = L.PENDING, this._handlers = [];
                    try {
                        m(this._resolve, this._reject)
                    } catch (m) {
                        this._reject(m)
                    }
                }
                then(m, _) {
                    return new SyncPromise((C, R) => {
                        this._handlers.push([!1, _ => {
                            if (m) try {
                                C(m(_))
                            } catch (m) {
                                R(m)
                            } else C(_)
                        }, m => {
                            if (_) try {
                                C(_(m))
                            } catch (m) {
                                R(m)
                            } else R(m)
                        }]), this._executeHandlers()
                    })
                } catch (m) {
                    return this.then(m => m, m)
                } finally(m) {
                    return new SyncPromise((_, C) => {
                        let R, L;
                        return this.then(_ => {
                            L = !1, R = _, m && m()
                        }, _ => {
                            L = !0, R = _, m && m()
                        }).then(() => {
                            if (L) {
                                C(R);
                                return
                            }
                            _(R)
                        })
                    })
                }
                __init() {
                    this._resolve = m => {
                        this._setResult(L.RESOLVED, m)
                    }
                }
                __init2() {
                    this._reject = m => {
                        this._setResult(L.REJECTED, m)
                    }
                }
                __init3() {
                    this._setResult = (m, _) => {
                        if (this._state === L.PENDING) {
                            if ((0, B.J8)(_)) {
                                _.then(this._resolve, this._reject);
                                return
                            }
                            this._state = m, this._value = _, this._executeHandlers()
                        }
                    }
                }
                __init4() {
                    this._executeHandlers = () => {
                        if (this._state === L.PENDING) return;
                        let m = this._handlers.slice();
                        this._handlers = [], m.forEach(m => {
                            m[0] || (this._state === L.RESOLVED && m[1](this._value), this._state === L.REJECTED && m[2](this._value), m[0] = !0)
                        })
                    }
                }
            }
        },
        26181: function(m, _, C) {
            "use strict";
            C.d(_, {
                Z1: function() {
                    return B
                },
                ph: function() {
                    return L
                },
                yW: function() {
                    return dateTimestampInSeconds
                }
            });
            var R = C(29531);

            function dateTimestampInSeconds() {
                return Date.now() / 1e3
            }
            let L = function() {
                    let {
                        performance: m
                    } = R.GLOBAL_OBJ;
                    if (!m || !m.now) return dateTimestampInSeconds;
                    let _ = Date.now() - m.now(),
                        C = void 0 == m.timeOrigin ? _ : m.timeOrigin;
                    return () => (C + m.now()) / 1e3
                }(),
                B = (() => {
                    let {
                        performance: m
                    } = R.GLOBAL_OBJ;
                    if (!m || !m.now) return;
                    let _ = m.now(),
                        C = Date.now(),
                        L = m.timeOrigin ? Math.abs(m.timeOrigin + _ - C) : 36e5,
                        B = m.timing && m.timing.navigationStart,
                        F = "number" == typeof B ? Math.abs(B + _ - C) : 36e5;
                    return L < 36e5 || F < 36e5 ? L <= F ? m.timeOrigin : B : C
                })()
        },
        85712: function(m, _, C) {
            "use strict";
            C.d(_, {
                $p: function() {
                    return generateSentryTraceHeader
                },
                pT: function() {
                    return propagationContextFromHeaders
                }
            });
            var R = C(60859),
                L = C(41982);
            let B = RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");

            function propagationContextFromHeaders(m, _) {
                let C = function(m) {
                        let _;
                        if (!m) return;
                        let C = m.match(B);
                        if (C) return "1" === C[3] ? _ = !0 : "0" === C[3] && (_ = !1), {
                            traceId: C[1],
                            parentSampled: _,
                            parentSpanId: C[2]
                        }
                    }(m),
                    F = (0, R.EN)(_),
                    {
                        traceId: U,
                        parentSpanId: H,
                        parentSampled: q
                    } = C || {};
                return C ? {
                    traceId: U || (0, L.DM)(),
                    parentSpanId: H || (0, L.DM)().substring(16),
                    spanId: (0, L.DM)().substring(16),
                    sampled: q,
                    dsc: F || {}
                } : {
                    traceId: U || (0, L.DM)(),
                    spanId: (0, L.DM)().substring(16)
                }
            }

            function generateSentryTraceHeader(m = (0, L.DM)(), _ = (0, L.DM)().substring(16), C) {
                let R = "";
                return void 0 !== C && (R = C ? "-1" : "-0"), `${m}-${_}${R}`
            }
        },
        42990: function(m, _, C) {
            "use strict";
            C.d(_, {
                J: function() {
                    return R
                }
            });
            let R = "8.34.0"
        },
        29531: function(m, _, C) {
            "use strict";
            C.d(_, {
                GLOBAL_OBJ: function() {
                    return L
                },
                Y: function() {
                    return getGlobalSingleton
                }
            });
            var R = C(42990);
            let L = globalThis;

            function getGlobalSingleton(m, _, C) {
                let B = C || L,
                    F = B.__SENTRY__ = B.__SENTRY__ || {},
                    U = F[R.J] = F[R.J] || {};
                return U[m] || (U[m] = _())
            }
        },
        86501: function(m, _, C) {
            "use strict";
            let R, L;
            C.d(_, {
                x7: function() {
                    return Ie
                },
                ZP: function() {
                    return ek
                },
                Am: function() {
                    return dist_n
                }
            });
            var B, F = C(67294);
            let U = {
                    data: ""
                },
                t = m => "object" == typeof window ? ((m ? m.querySelector("#_goober") : window._goober) || Object.assign((m || document.head).appendChild(document.createElement("style")), {
                    innerHTML: " ",
                    id: "_goober"
                })).firstChild : m || U,
                H = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g,
                q = /\/\*[^]*?\*\/|  +/g,
                V = /\n+/g,
                o = (m, _) => {
                    let C = "",
                        R = "",
                        L = "";
                    for (let B in m) {
                        let F = m[B];
                        "@" == B[0] ? "i" == B[1] ? C = B + " " + F + ";" : R += "f" == B[1] ? o(F, B) : B + "{" + o(F, "k" == B[1] ? "" : _) + "}" : "object" == typeof F ? R += o(F, _ ? _.replace(/([^,])+/g, m => B.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, _ => /&/.test(_) ? _.replace(/&/g, m) : m ? m + " " + _ : _)) : B) : null != F && (B = /^--/.test(B) ? B : B.replace(/[A-Z]/g, "-$&").toLowerCase(), L += o.p ? o.p(B, F) : B + ":" + F + ";")
                    }
                    return C + (_ && L ? _ + "{" + L + "}" : L) + R
                },
                X = {},
                s = m => {
                    if ("object" == typeof m) {
                        let _ = "";
                        for (let C in m) _ += C + s(m[C]);
                        return _
                    }
                    return m
                },
                i = (m, _, C, R, L) => {
                    var B;
                    let F = s(m),
                        U = X[F] || (X[F] = (m => {
                            let _ = 0,
                                C = 11;
                            for (; _ < m.length;) C = 101 * C + m.charCodeAt(_++) >>> 0;
                            return "go" + C
                        })(F));
                    if (!X[U]) {
                        let _ = F !== m ? m : (m => {
                            let _, C, R = [{}];
                            for (; _ = H.exec(m.replace(q, ""));) _[4] ? R.shift() : _[3] ? (C = _[3].replace(V, " ").trim(), R.unshift(R[0][C] = R[0][C] || {})) : R[0][_[1]] = _[2].replace(V, " ").trim();
                            return R[0]
                        })(m);
                        X[U] = o(L ? {
                            ["@keyframes " + U]: _
                        } : _, C ? "" : "." + U)
                    }
                    let K = C && X.g ? X.g : null;
                    return C && (X.g = X[U]), B = X[U], K ? _.data = _.data.replace(K, B) : -1 === _.data.indexOf(B) && (_.data = R ? B + _.data : _.data + B), U
                },
                p = (m, _, C) => m.reduce((m, R, L) => {
                    let B = _[L];
                    if (B && B.call) {
                        let m = B(C),
                            _ = m && m.props && m.props.className || /^go/.test(m) && m;
                        B = _ ? "." + _ : m && "object" == typeof m ? m.props ? "" : o(m, "") : !1 === m ? "" : m
                    }
                    return m + R + (null == B ? "" : B)
                }, "");

            function u(m) {
                let _ = this || {},
                    C = m.call ? m(_.p) : m;
                return i(C.unshift ? C.raw ? p(C, [].slice.call(arguments, 1), _.p) : C.reduce((m, C) => Object.assign(m, C && C.call ? C(_.p) : C), {}) : C, t(_.target), _.g, _.o, _.k)
            }
            u.bind({
                g: 1
            });
            let K, Y, Q, et = u.bind({
                k: 1
            });

            function j(m, _) {
                let C = this || {};
                return function() {
                    let R = arguments;

                    function a(L, B) {
                        let F = Object.assign({}, L),
                            U = F.className || a.className;
                        C.p = Object.assign({
                            theme: Y && Y()
                        }, F), C.o = / *go\d+/.test(U), F.className = u.apply(C, R) + (U ? " " + U : ""), _ && (F.ref = B);
                        let H = m;
                        return m[0] && (H = F.as || m, delete F.as), Q && H[0] && Q(F), K(H, F)
                    }
                    return _ ? _(a) : a
                }
            }
            var W = m => "function" == typeof m,
                T = (m, _) => W(m) ? m(_) : m,
                er = (R = 0, () => (++R).toString()),
                dist_b = () => {
                    if (void 0 === L && "u" > typeof window) {
                        let m = matchMedia("(prefers-reduced-motion: reduce)");
                        L = !m || m.matches
                    }
                    return L
                },
                en = new Map,
                $ = m => {
                    if (en.has(m)) return;
                    let _ = setTimeout(() => {
                        en.delete(m), dist_u({
                            type: 4,
                            toastId: m
                        })
                    }, 1e3);
                    en.set(m, _)
                },
                J = m => {
                    let _ = en.get(m);
                    _ && clearTimeout(_)
                },
                v = (m, _) => {
                    switch (_.type) {
                        case 0:
                            return { ...m,
                                toasts: [_.toast, ...m.toasts].slice(0, 20)
                            };
                        case 1:
                            return _.toast.id && J(_.toast.id), { ...m,
                                toasts: m.toasts.map(m => m.id === _.toast.id ? { ...m,
                                    ..._.toast
                                } : m)
                            };
                        case 2:
                            let {
                                toast: C
                            } = _;
                            return m.toasts.find(m => m.id === C.id) ? v(m, {
                                type: 1,
                                toast: C
                            }) : v(m, {
                                type: 0,
                                toast: C
                            });
                        case 3:
                            let {
                                toastId: R
                            } = _;
                            return R ? $(R) : m.toasts.forEach(m => {
                                $(m.id)
                            }), { ...m,
                                toasts: m.toasts.map(m => m.id === R || void 0 === R ? { ...m,
                                    visible: !1
                                } : m)
                            };
                        case 4:
                            return void 0 === _.toastId ? { ...m,
                                toasts: []
                            } : { ...m,
                                toasts: m.toasts.filter(m => m.id !== _.toastId)
                            };
                        case 5:
                            return { ...m,
                                pausedAt: _.time
                            };
                        case 6:
                            let L = _.time - (m.pausedAt || 0);
                            return { ...m,
                                pausedAt: void 0,
                                toasts: m.toasts.map(m => ({ ...m,
                                    pauseDuration: m.pauseDuration + L
                                }))
                            }
                    }
                },
                ei = [],
                eo = {
                    toasts: [],
                    pausedAt: void 0
                },
                dist_u = m => {
                    eo = v(eo, m), ei.forEach(m => {
                        m(eo)
                    })
                },
                ea = {
                    blank: 4e3,
                    error: 4e3,
                    success: 2e3,
                    loading: 1 / 0,
                    custom: 4e3
                },
                I = (m = {}) => {
                    let [_, C] = (0, F.useState)(eo);
                    (0, F.useEffect)(() => (ei.push(C), () => {
                        let m = ei.indexOf(C);
                        m > -1 && ei.splice(m, 1)
                    }), [_]);
                    let R = _.toasts.map(_ => {
                        var C, R;
                        return { ...m,
                            ...m[_.type],
                            ..._,
                            duration: _.duration || (null == (C = m[_.type]) ? void 0 : C.duration) || (null == m ? void 0 : m.duration) || ea[_.type],
                            style: { ...m.style,
                                ...null == (R = m[_.type]) ? void 0 : R.style,
                                ..._.style
                            }
                        }
                    });
                    return { ..._,
                        toasts: R
                    }
                },
                G = (m, _ = "blank", C) => ({
                    createdAt: Date.now(),
                    visible: !0,
                    type: _,
                    ariaProps: {
                        role: "status",
                        "aria-live": "polite"
                    },
                    message: m,
                    pauseDuration: 0,
                    ...C,
                    id: (null == C ? void 0 : C.id) || er()
                }),
                dist_h = m => (_, C) => {
                    let R = G(_, m, C);
                    return dist_u({
                        type: 2,
                        toast: R
                    }), R.id
                },
                dist_n = (m, _) => dist_h("blank")(m, _);
            dist_n.error = dist_h("error"), dist_n.success = dist_h("success"), dist_n.loading = dist_h("loading"), dist_n.custom = dist_h("custom"), dist_n.dismiss = m => {
                dist_u({
                    type: 3,
                    toastId: m
                })
            }, dist_n.remove = m => dist_u({
                type: 4,
                toastId: m
            }), dist_n.promise = (m, _, C) => {
                let R = dist_n.loading(_.loading, { ...C,
                    ...null == C ? void 0 : C.loading
                });
                return m.then(m => (dist_n.success(T(_.success, m), {
                    id: R,
                    ...C,
                    ...null == C ? void 0 : C.success
                }), m)).catch(m => {
                    dist_n.error(T(_.error, m), {
                        id: R,
                        ...C,
                        ...null == C ? void 0 : C.error
                    })
                }), m
            };
            var Z = (m, _) => {
                    dist_u({
                        type: 1,
                        toast: {
                            id: m,
                            height: _
                        }
                    })
                },
                ee = () => {
                    dist_u({
                        type: 5,
                        time: Date.now()
                    })
                },
                D = m => {
                    let {
                        toasts: _,
                        pausedAt: C
                    } = I(m);
                    (0, F.useEffect)(() => {
                        if (C) return;
                        let m = Date.now(),
                            R = _.map(_ => {
                                if (_.duration === 1 / 0) return;
                                let C = (_.duration || 0) + _.pauseDuration - (m - _.createdAt);
                                if (C < 0) {
                                    _.visible && dist_n.dismiss(_.id);
                                    return
                                }
                                return setTimeout(() => dist_n.dismiss(_.id), C)
                            });
                        return () => {
                            R.forEach(m => m && clearTimeout(m))
                        }
                    }, [_, C]);
                    let R = (0, F.useCallback)(() => {
                            C && dist_u({
                                type: 6,
                                time: Date.now()
                            })
                        }, [C]),
                        L = (0, F.useCallback)((m, C) => {
                            let {
                                reverseOrder: R = !1,
                                gutter: L = 8,
                                defaultPosition: B
                            } = C || {}, F = _.filter(_ => (_.position || B) === (m.position || B) && _.height), U = F.findIndex(_ => _.id === m.id), H = F.filter((m, _) => _ < U && m.visible).length;
                            return F.filter(m => m.visible).slice(...R ? [H + 1] : [0, H]).reduce((m, _) => m + (_.height || 0) + L, 0)
                        }, [_]);
                    return {
                        toasts: _,
                        handlers: {
                            updateHeight: Z,
                            startPause: ee,
                            endPause: R,
                            calculateOffset: L
                        }
                    }
                },
                es = et `
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`,
                ec = et `
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`,
                el = et `
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`,
                eu = j("div")
            `
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${m=>m.primary||"#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${es} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${ec} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${m=>m.secondary||"#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${el} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, ed = et `
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, ep = j("div")
            `
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${m=>m.secondary||"#e0e0e0"};
  border-right-color: ${m=>m.primary||"#616161"};
  animation: ${ed} 1s linear infinite;
`, eh = et `
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, ef = et `
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, em = j("div")
            `
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${m=>m.primary||"#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${eh} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${ef} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${m=>m.secondary||"#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, eg = j("div")
            `
  position: absolute;
`, ey = j("div")
            `
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, e_ = et `
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, ev = j("div")
            `
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${e_} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, M = ({
                toast: m
            }) => {
                let {
                    icon: _,
                    type: C,
                    iconTheme: R
                } = m;
                return void 0 !== _ ? "string" == typeof _ ? F.createElement(ev, null, _) : _ : "blank" === C ? null : F.createElement(ey, null, F.createElement(ep, { ...R
                }), "loading" !== C && F.createElement(eg, null, "error" === C ? F.createElement(eu, { ...R
                }) : F.createElement(em, { ...R
                })))
            }, ye = m => `
0% {transform: translate3d(0,${-200*m}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, ge = m => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${-150*m}%,-1px) scale(.6); opacity:0;}
`, eb = j("div")
            `
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, eS = j("div")
            `
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Ae = (m, _) => {
                let C = m.includes("top") ? 1 : -1,
                    [R, L] = dist_b() ? ["0%{opacity:0;} 100%{opacity:1;}", "0%{opacity:1;} 100%{opacity:0;}"] : [ye(C), ge(C)];
                return {
                    animation: _ ? `${et(R)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${et(L)} 0.4s forwards cubic-bezier(.06,.71,.55,1)`
                }
            }, ew = F.memo(({
                toast: m,
                position: _,
                style: C,
                children: R
            }) => {
                let L = m.height ? Ae(m.position || _ || "top-center", m.visible) : {
                        opacity: 0
                    },
                    B = F.createElement(M, {
                        toast: m
                    }),
                    U = F.createElement(eS, { ...m.ariaProps
                    }, T(m.message, m));
                return F.createElement(eb, {
                    className: m.className,
                    style: { ...L,
                        ...C,
                        ...m.style
                    }
                }, "function" == typeof R ? R({
                    icon: B,
                    message: U
                }) : F.createElement(F.Fragment, null, B, U))
            });
            B = F.createElement, o.p = void 0, K = B, Y = void 0, Q = void 0;
            var Ee = ({
                    id: m,
                    className: _,
                    style: C,
                    onHeightUpdate: R,
                    children: L
                }) => {
                    let B = F.useCallback(_ => {
                        if (_) {
                            let i = () => {
                                R(m, _.getBoundingClientRect().height)
                            };
                            i(), new MutationObserver(i).observe(_, {
                                subtree: !0,
                                childList: !0,
                                characterData: !0
                            })
                        }
                    }, [m, R]);
                    return F.createElement("div", {
                        ref: B,
                        className: _,
                        style: C
                    }, L)
                },
                Re = (m, _) => {
                    let C = m.includes("top"),
                        R = m.includes("center") ? {
                            justifyContent: "center"
                        } : m.includes("right") ? {
                            justifyContent: "flex-end"
                        } : {};
                    return {
                        left: 0,
                        right: 0,
                        display: "flex",
                        position: "absolute",
                        transition: dist_b() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)",
                        transform: `translateY(${_*(C?1:-1)}px)`,
                        ...C ? {
                            top: 0
                        } : {
                            bottom: 0
                        },
                        ...R
                    }
                },
                eE = u `
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`,
                Ie = ({
                    reverseOrder: m,
                    position: _ = "top-center",
                    toastOptions: C,
                    gutter: R,
                    children: L,
                    containerStyle: B,
                    containerClassName: U
                }) => {
                    let {
                        toasts: H,
                        handlers: q
                    } = D(C);
                    return F.createElement("div", {
                        style: {
                            position: "fixed",
                            zIndex: 9999,
                            top: 16,
                            left: 16,
                            right: 16,
                            bottom: 16,
                            pointerEvents: "none",
                            ...B
                        },
                        className: U,
                        onMouseEnter: q.startPause,
                        onMouseLeave: q.endPause
                    }, H.map(C => {
                        let B = C.position || _,
                            U = Re(B, q.calculateOffset(C, {
                                reverseOrder: m,
                                gutter: R,
                                defaultPosition: _
                            }));
                        return F.createElement(Ee, {
                            id: C.id,
                            key: C.id,
                            onHeightUpdate: q.updateHeight,
                            className: C.visible ? eE : "",
                            style: U
                        }, "custom" === C.type ? T(C.message, C) : L ? L(C) : F.createElement(ew, {
                            toast: C,
                            position: B
                        }))
                    }))
                },
                ek = dist_n
        }
    },
    function(m) {
        var __webpack_exec__ = function(_) {
            return m(m.s = _)
        };
        m.O(0, [9774, 179], function() {
            return __webpack_exec__(53215), __webpack_exec__(6840), __webpack_exec__(32059)
        }), _N_E = m.O()
    }
]);